diff -Naur gala/src/Background/Animation.vala gala-3.14/src/Background/Animation.vala
--- gala/src/Background/Animation.vala	1970-01-01 01:00:00.000000000 +0100
+++ gala-3.14/src/Background/Animation.vala	2014-12-26 21:37:58.389301000 +0100
@@ -0,0 +1,76 @@
+//
+//  Copyright (C) 2014 Tom Beckmann
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+//
+
+namespace Gala
+{
+	public class Animation : Object
+	{
+		public string filename { get; construct; }
+		public string[] key_frame_files { get; private set; default = {}; }
+		public double transition_progress { get; private set; default = 0.0; }
+		public double transition_duration { get; private set; default = 0.0; }
+		public bool loaded { get; private set; default = false; }
+
+		Gnome.BGSlideShow? show = null;
+
+		public Animation (string filename)
+		{
+			Object (filename: filename);
+		}
+
+		public async void load ()
+		{
+			show = new Gnome.BGSlideShow (filename);
+
+			show.load_async (null, (obj, res) => {
+				loaded = true;
+
+				load.callback ();
+			});
+
+			yield;
+		}
+
+		public void update (Meta.Rectangle monitor)
+		{
+			string[] key_frame_files = {};
+
+			if (show == null)
+				return;
+
+			if (show.get_num_slides () < 1)
+				return;
+
+			double progress, duration;
+			bool is_fixed;
+			string file1, file2;
+			show.get_current_slide (monitor.width, monitor.height, out progress, out duration, out is_fixed, out file1, out file2);
+
+			transition_duration = duration;
+			transition_progress = progress;
+
+			if (file1 != null)
+				key_frame_files += file1;
+
+			if (file2 != null)
+				key_frame_files += file2;
+
+			this.key_frame_files = key_frame_files;
+		}
+	}
+}
+
diff -Naur gala/src/Background/Background.vala gala-3.14/src/Background/Background.vala
--- gala/src/Background/Background.vala	2014-12-26 21:37:36.907203000 +0100
+++ gala-3.14/src/Background/Background.vala	2014-12-26 21:37:58.389301000 +0100
@@ -1,5 +1,5 @@
 //
-//  Copyright (C) 2013 Tom Beckmann, Rico Tzschichholz
+//  Copyright (C) 2014 Tom Beckmann
 //
 //  This program is free software: you can redistribute it and/or modify
 //  it under the terms of the GNU General Public License as published by
@@ -17,185 +17,273 @@
 
 namespace Gala
 {
-	/**
-	 * Group that holds a pattern at the very bottom and then an image showing the
-	 * current wallpaper above (and one more additional image for transitions).
-	 * It listens to changes on the provided settings object and updates accordingly.
-	 */
-	public class Background : Meta.BackgroundGroup
+	public class Background : Object
 	{
-		const uint ANIMATION_TRANSITION_DURATION = 1500;
+		const double ANIMATION_OPACITY_STEP_INCREMENT = 4.0;
+		const double ANIMATION_MIN_WAKEUP_INTERVAL = 1.0;
 
 		public signal void changed ();
+		public signal void loaded ();
 
 		public Meta.Screen screen { get; construct; }
-		public int monitor { get; construct; }
-		public Settings settings { get; construct; }
+		public int monitor_index { get; construct; }
+		public BackgroundSource background_source { get; construct; }
+		public bool is_loaded { get; private set; default = false; }
+		public GDesktop.BackgroundStyle style { get; construct; }
+		public string? filename { get; construct; }
+		public Meta.Background background { get; private set; }
+
+		Animation? animation = null;
+		Gee.HashMap<string,ulong> file_watches;
+		Cancellable cancellable;
+		uint update_animation_timeout_id = 0;
 
-		Meta.BackgroundActor pattern;
-		Clutter.Actor? image = null;
-
-		public Background (Meta.Screen screen, int monitor, Settings settings)
+		public Background (Meta.Screen screen, int monitor_index, string? filename,
+				BackgroundSource background_source, GDesktop.BackgroundStyle style)
 		{
-			Object (screen: screen, monitor: monitor, settings: settings);
+			Object (screen: screen,
+					monitor_index: monitor_index,
+					background_source: background_source,
+					style: style,
+					filename: filename);
 		}
 
 		construct
 		{
-			pattern = new Meta.BackgroundActor ();
-			pattern.add_constraint (new Clutter.BindConstraint (this, Clutter.BindCoordinate.SIZE, 0));
-			add_child (pattern);
+			background = new Meta.Background (screen);
+			background.set_data<Background> ("delegate", this);
+
+			file_watches = new Gee.HashMap<string,ulong> ();
+			cancellable = new Cancellable ();
+
+			background_source.changed.connect (settings_changed);
+
+			load ();
+		}
+
+		public void destroy ()
+		{
+			cancellable.cancel ();
+			remove_animation_timeout ();
+
+			var cache = BackgroundCache.get_default ();
+
+			foreach (var watch in file_watches.values) {
+				SignalHandler.disconnect (cache, watch);
+			}
+
+			background_source.settings.changed.disconnect (settings_changed);
+		}
+
+		public void update_resolution ()
+		{
+			if (animation != null) {
+				remove_animation_timeout ();
+				update_animation ();
+			}
+		}
+
+		void set_loaded ()
+		{
+			if (is_loaded)
+				return;
 
-			load (null);
+			is_loaded = true;
 
-			settings.changed.connect (load);
+			Idle.add (() => {
+				loaded ();
+				return false;
+			});
 		}
 
-		~Background ()
+		void load_pattern ()
 		{
-			settings.changed.disconnect (load);
+			string color_string;
+			var settings = background_source.settings;
+
+			color_string = settings.get_string ("primary-color");
+			var color = Clutter.Color.from_string (color_string);
+
+			color_string = settings.get_string("secondary-color");
+			var second_color = Clutter.Color.from_string (color_string);
+
+			var shading_type = settings.get_enum ("color-shading-type");
+
+			if (shading_type == GDesktop.BackgroundShading.SOLID)
+				background.set_color (color);
+			else
+				background.set_gradient ((GDesktop.BackgroundShading) shading_type, color, second_color);
 		}
 
-		/**
-		 * (Re)loads all components if key_changed is null or only the key_changed component
-		 */
-		void load (string? key_changed)
+		void watch_file (string filename)
 		{
-			var all = key_changed == null;
+			if (file_watches.has_key (filename))
+				return;
+
 			var cache = BackgroundCache.get_default ();
 
-			// update images
-			if (all || key_changed == "picture-uri" || key_changed == "picture-options") {
-				var style = style_string_to_enum (settings.get_string ("picture-options"));
-				var uri = settings.get_string ("picture-uri");
-
-				string filename;
-				if (GLib.Uri.parse_scheme (uri) != null)
-					filename = File.new_for_uri (uri).get_path ();
+			cache.monitor_file (filename);
+
+			file_watches[filename] = cache.file_changed.connect ((changed_file) => {
+				if (changed_file == filename) {
+					var image_cache = Meta.BackgroundImageCache.get_default ();
+#if HAS_MUTTER316
+					image_cache.purge (File.new_for_path (changed_file));
+#else
+					image_cache.purge (changed_file);
+#endif
+					changed ();
+				}
+			});
+		}
+
+		void remove_animation_timeout ()
+		{
+			if (update_animation_timeout_id != 0) {
+				Source.remove (update_animation_timeout_id);
+				update_animation_timeout_id = 0;
+			}
+		}
+
+		void update_animation ()
+		{
+			update_animation_timeout_id = 0;
+
+			animation.update (screen.get_monitor_geometry (monitor_index));
+			var files = animation.key_frame_files;
+
+			Clutter.Callback finish = () => {
+				set_loaded ();
+
+				if (files.length > 1)
+#if HAS_MUTTER316
+					background.set_blend (File.new_for_path (files[0]), File.new_for_path (files[1]), animation.transition_progress, style);
+				else if (files.length > 0)
+					background.set_file (File.new_for_path (files[0]), style);
+				else
+					background.set_file (null, style);
+#else
+					background.set_blend (files[0], files[1], animation.transition_progress, style);
+				else if (files.length > 0)
+					background.set_filename (files[0], style);
 				else
-					filename = uri;
+					background.set_filename (null, style);
+#endif
 
-				// no image at all or malformed picture-uri
-				if (filename == null || filename == "" || style == GDesktop.BackgroundStyle.NONE) {
-					set_current (null);
-				// animation
-				} else if (filename.has_suffix (".xml")) {
-					var slides = new SlideShow (filename, screen, 0, style);
-
-					slides.load.begin ((obj, res) => {
-						if (!slides.load.end (res))
-							set_current (null);
-						else
-							set_current (slides);
-					});
-				// normal wallpaper
+				queue_update_animation ();
+			};
+
+			var cache = Meta.BackgroundImageCache.get_default ();
+			var num_pending_images = files.length;
+			for (var i = 0; i < files.length; i++) {
+				watch_file (files[i]);
+
+#if HAS_MUTTER316
+				var image = cache.load (File.new_for_path (files[i]));
+#else
+				var image = cache.load (files[i]);
+#endif
+
+				if (image.is_loaded ()) {
+					num_pending_images--;
+					if (num_pending_images == 0)
+						finish (null);
 				} else {
-					cache.load_image.begin (filename, monitor, style, (obj, res) => {
-						var content = cache.load_image.end (res);
-						if (content == null) {
-							set_current (null);
-							return;
-						}
-
-						var new_image = new Meta.BackgroundActor ();
-						new_image.content = content;
-						set_current (new_image);
+					ulong handler = 0;
+					handler = image.loaded.connect (() => {
+						SignalHandler.disconnect (image, handler);
+						if (--num_pending_images == 0)
+							finish (null);
 					});
 				}
 			}
+		}
 
-			// update image opacity
-			if (all || key_changed == "picture-opacity") {
-				if (image != null)
-					image.opacity = (uint8)(settings.get_int ("picture-opacity") / 100.0 * 255);
+		void queue_update_animation () {
+			if (update_animation_timeout_id != 0)
+				return;
 
-				changed ();
-			}
+			if (cancellable == null || cancellable.is_cancelled ())
+				return;
 
-			// update pattern
-			if (all
-				|| key_changed == "primary-color"
-				|| key_changed == "secondary-color"
-				|| key_changed == "color-shading-type") {
-				var primary_color = Clutter.Color.from_string (settings.get_string ("primary-color"));
-				var secondary_color = Clutter.Color.from_string (settings.get_string ("secondary-color"));
-				var shading_type = shading_string_to_enum (settings.get_string ("color-shading-type"));
-				pattern.content = cache.load_pattern (monitor, primary_color, secondary_color, shading_type);
+			if (animation.transition_duration == 0)
+				return;
 
-				changed ();
-			}
+			var n_steps = 255.0 / ANIMATION_OPACITY_STEP_INCREMENT;
+			var time_per_step = (animation.transition_duration * 1000) / n_steps;
+
+			var interval = (uint32) Math.fmax (ANIMATION_MIN_WAKEUP_INTERVAL * 1000, time_per_step);
+
+			if (interval > uint32.MAX)
+				return;
+
+			update_animation_timeout_id = Timeout.add (interval, () => {
+				update_animation_timeout_id = 0;
+				update_animation ();
+				return false;
+			});
 		}
 
-		/**
-		 * Fade a new image over the old, then destroy the old one and replace it with the new one
-		 * if new_image is null, fade out and destroy the current image to show the pattern
-		 */
-		void set_current (Clutter.Actor? new_image)
+		async void load_animation (string filename)
 		{
-			if (new_image == null) {
-				if (image != null)
-					image.animate (Clutter.AnimationMode.EASE_OUT_QUAD, ANIMATION_TRANSITION_DURATION,
-						opacity: 0).completed.connect (() => {
-						image.destroy ();
+			animation = yield BackgroundCache.get_default ().get_animation (filename);
 
-						changed ();
-					});
+			if (animation == null || cancellable.is_cancelled ()) {
+				set_loaded();
 				return;
 			}
 
-			new_image.opacity = 0;
-			new_image.add_constraint (new Clutter.BindConstraint (this, Clutter.BindCoordinate.SIZE, 0));
-			insert_child_above (new_image, null);
-
-			var dest_opacity = (uint8)(settings.get_int ("picture-opacity") / 100.0 * 255);
-			new_image.animate (Clutter.AnimationMode.EASE_OUT_QUAD, ANIMATION_TRANSITION_DURATION,
-				opacity: dest_opacity).completed.connect (() => {
-				if (image != null)
-					image.destroy ();
-				image = new_image;
-
-				changed ();
-			});
+			update_animation ();
+			watch_file (filename);
 		}
 
-		/**
-		 *  translates the string returned from gsettings for the color-shading-type key to the
-		 *  appropriate GDesktop.BackgroundShading enum value
-		 */
-		static GDesktop.BackgroundShading shading_string_to_enum (string shading)
-		{
-			switch (shading) {
-				case "horizontal":
-					return GDesktop.BackgroundShading.HORIZONTAL;
-				case "vertical":
-					return GDesktop.BackgroundShading.VERTICAL;
-			}
-
-			return GDesktop.BackgroundShading.SOLID;
-		}
-
-		/**
-		 *  translates the string returned from gsettings for the picture-options key to the
-		 *  appropriate GDesktop.BackgroundStyle enum value
-		 */
-		static GDesktop.BackgroundStyle style_string_to_enum (string style)
-		{
-			switch (style) {
-				case "wallpaper":
-					return GDesktop.BackgroundStyle.WALLPAPER;
-				case "centered":
-					return GDesktop.BackgroundStyle.CENTERED;
-				case "scaled":
-					return GDesktop.BackgroundStyle.SCALED;
-				case "stretched":
-					return GDesktop.BackgroundStyle.STRETCHED;
-				case "zoom":
-					return GDesktop.BackgroundStyle.ZOOM;
-				case "spanned":
-					return GDesktop.BackgroundStyle.SPANNED;
+		void load_image (string filename)
+		{
+#if HAS_MUTTER316
+			background.set_file (File.new_for_path (filename), style);
+#else
+			background.set_filename (filename, style);
+#endif
+			watch_file (filename);
+
+			var cache = Meta.BackgroundImageCache.get_default ();
+#if HAS_MUTTER316
+			var image = cache.load (File.new_for_path (filename));
+#else
+			var image = cache.load (filename);
+#endif
+			if (image.is_loaded ())
+				set_loaded();
+			else {
+				ulong handler = 0;
+				handler = image.loaded.connect (() => {
+					set_loaded ();
+					SignalHandler.disconnect (image, handler);
+				});
 			}
+		}
 
-			return GDesktop.BackgroundStyle.NONE;
+		void load_file (string filename)
+		{
+			if (filename.has_suffix (".xml"))
+				load_animation.begin (filename);
+			else
+				load_image (filename);
+		}
+
+		void load ()
+		{
+			load_pattern ();
+
+			if (filename == null)
+				set_loaded ();
+			else
+				load_file (filename);
+		}
+
+		void settings_changed ()
+		{
+			changed ();
 		}
 	}
 }
diff -Naur gala/src/Background/BackgroundCache.vala gala-3.14/src/Background/BackgroundCache.vala
--- gala/src/Background/BackgroundCache.vala	2014-12-26 21:37:36.907203000 +0100
+++ gala-3.14/src/Background/BackgroundCache.vala	2014-12-26 21:37:58.389301000 +0100
@@ -1,5 +1,5 @@
 //
-//  Copyright (C) 2013 Tom Beckmann, Rico Tzschichholz
+//  Copyright (C) 2014 Tom Beckmann
 //
 //  This program is free software: you can redistribute it and/or modify
 //  it under the terms of the GNU General Public License as published by
@@ -19,99 +19,100 @@
 {
 	public class BackgroundCache : Object
 	{
-		struct WaitingCallback
-		{
-			unowned SourceFunc func;
-			string hash;
-		}
-
 		static BackgroundCache? instance = null;
 
-		public static void init (Meta.Screen screen)
-		{
-			instance = new BackgroundCache (screen);
-		}
-
 		public static BackgroundCache get_default ()
-			requires (instance != null)
 		{
+			if (instance == null)
+				instance = new BackgroundCache ();
+
 			return instance;
 		}
 
-		public Meta.Screen screen { get; construct; }
+		public signal void file_changed (string filename);
+
+		Gee.HashMap<string,FileMonitor> file_monitors;
+		Gee.HashMap<string,BackgroundSource> background_sources;
 
-		Gee.HashMap<string,Meta.Background> image_cache;
-		Gee.HashMap<string,Meta.Background> pattern_cache;
-		Gee.LinkedList<WaitingCallback?> waiting_callbacks;
+		Animation animation;
+		string animation_filename;
 
-		BackgroundCache (Meta.Screen screen)
+		public BackgroundCache ()
 		{
-			Object (screen: screen);
+			Object ();
 		}
 
 		construct
 		{
-			image_cache = new Gee.HashMap<string,Meta.Background> ();
-			pattern_cache = new Gee.HashMap<string,Meta.Background> ();
-			waiting_callbacks = new Gee.LinkedList<WaitingCallback?> ();
-		}
-
-		public async Meta.Background? load_image (string file, int monitor,
-			GDesktop.BackgroundStyle style)
-		{
-			string hash = "%s#%i".printf (file, style);
-			Meta.Background? content = image_cache.get (hash);
-
-			if (content != null) {
-				// the content has been created, but the file is still loading, so we wait
-				if (content.get_filename () == null) {
-					waiting_callbacks.add ({ load_image.callback, hash });
-					yield;
-				}
-
-				return content.copy (monitor, Meta.BackgroundEffects.NONE);
-			}
-
-			content = new Meta.Background (screen, monitor, Meta.BackgroundEffects.NONE);
+			file_monitors = new Gee.HashMap<string,FileMonitor> ();
+			background_sources = new Gee.HashMap<string,BackgroundSource> ();
+		}
 
-			image_cache.set (hash, content);
+		public void monitor_file (string filename)
+		{
+			if (file_monitors.has_key (filename))
+				return;
 
+			var file = File.new_for_path (filename);
 			try {
-				yield content.load_file_async (file, style, null);
+				var monitor = file.monitor (FileMonitorFlags.NONE, null);
+				monitor.changed.connect(() => {
+					file_changed (filename);
+				});
+
+				file_monitors[filename] = monitor;
 			} catch (Error e) {
-				warning (e.message);
-				return null;
+				warning ("Failed to monitor %s: %s", filename, e.message);
 			}
+		}
 
-			foreach (var callback in waiting_callbacks) {
-				if (callback.hash == hash) {
-					callback.func ();
-					waiting_callbacks.remove (callback);
-				}
+		public async Animation get_animation (string filename)
+		{
+			if (animation_filename == filename) {
+				Idle.add (() => {
+					get_animation.callback ();
+					return false;
+				});
+				yield;
+
+				return animation;
 			}
 
-			return content;
-		}
+			var animation = new Animation (filename);
 
-		public Meta.Background load_pattern (int monitor, Clutter.Color primary, Clutter.Color secondary,
-			GDesktop.BackgroundShading shading_type)
-		{
-			string hash = "%s#%s#%i".printf (primary.to_string (), secondary.to_string (), shading_type);
-			Meta.Background? content = pattern_cache.get (hash);
+			yield animation.load ();
+
+			Idle.add (() => {
+				get_animation.callback ();
+				return false;
+			});
+			yield;
 
-			if (content != null)
-				return content.copy (monitor, Meta.BackgroundEffects.NONE);
+			return animation;
+		}
 
-			content = new Meta.Background (screen, monitor, Meta.BackgroundEffects.NONE);
-			if (shading_type == GDesktop.BackgroundShading.SOLID)
-				content.load_color (primary);
-			else
-				content.load_gradient (shading_type, primary, secondary);
+		public BackgroundSource get_background_source (Meta.Screen screen, string settings_schema)
+		{
+			var background_source = background_sources[settings_schema];
+			if (background_source == null) {
+				background_source = new BackgroundSource (screen, settings_schema);
+				background_source.use_count = 1;
+				background_sources[settings_schema] = background_source;
+			} else
+				background_source.use_count++;
 
-			pattern_cache.set (hash, content);
+			return background_source;
+		}
 
-			return content;
+		public void release_background_source (string settings_schema)
+		{
+			if (background_sources.has_key (settings_schema)) {
+				var source = background_sources[settings_schema];
+				if (--source.use_count == 0) {
+					background_sources.unset (settings_schema);
+					source.destroy ();
+				}
+			}
 		}
 	}
 }
-
diff -Naur gala/src/Background/BackgroundContainer.vala gala-3.14/src/Background/BackgroundContainer.vala
--- gala/src/Background/BackgroundContainer.vala	1970-01-01 01:00:00.000000000 +0100
+++ gala-3.14/src/Background/BackgroundContainer.vala	2014-12-26 21:37:58.389301000 +0100
@@ -0,0 +1,68 @@
+//
+//  Copyright (C) 2013 Tom Beckmann, Rico Tzschichholz
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+//
+
+namespace Gala
+{
+	public class BackgroundContainer : Meta.BackgroundGroup
+	{
+		public signal void changed ();
+
+		public Meta.Screen screen { get; construct; }
+
+		public BackgroundContainer (Meta.Screen screen)
+		{
+			Object (screen: screen);
+		}
+
+		construct
+		{
+			screen.monitors_changed.connect (update);
+
+			update ();
+		}
+
+		~BackgroundContainer ()
+		{
+			screen.monitors_changed.disconnect (update);
+		}
+
+		void update ()
+		{
+			var reference_child = (get_child_at_index (0) as BackgroundManager);
+			if (reference_child != null)
+				reference_child.changed.disconnect (background_changed);
+
+			destroy_all_children ();
+
+			for (var i = 0; i < screen.get_n_monitors (); i++) {
+				var background = new BackgroundManager (screen, i);
+
+				add_child (background);
+
+				if (i == 0)
+					background.changed.connect (background_changed);
+			}
+		}
+
+		void background_changed ()
+		{
+			changed ();
+		}
+	}
+}
+
+
diff -Naur gala/src/Background/BackgroundManager.vala gala-3.14/src/Background/BackgroundManager.vala
--- gala/src/Background/BackgroundManager.vala	2014-12-26 21:37:36.907203000 +0100
+++ gala-3.14/src/Background/BackgroundManager.vala	2014-12-26 21:37:58.389301000 +0100
@@ -1,5 +1,5 @@
 //
-//  Copyright (C) 2013 Tom Beckmann, Rico Tzschichholz
+//  Copyright (C) 2014 Tom Beckmann
 //
 //  This program is free software: you can redistribute it and/or modify
 //  it under the terms of the GNU General Public License as published by
@@ -19,54 +19,141 @@
 {
 	public class BackgroundManager : Meta.BackgroundGroup
 	{
-		public Meta.Screen screen { get; construct; }
+		const string BACKGROUND_SCHEMA = "org.gnome.desktop.background";
+		const int FADE_ANIMATION_TIME = 1000;
+
 		public signal void changed ();
 
-		public BackgroundManager (Meta.Screen screen)
+		public Meta.Screen screen { get; construct; }
+		public int monitor_index { get; construct; }
+		public bool control_position { get; construct; }
+
+		BackgroundSource background_source;
+		Meta.BackgroundActor background_actor;
+		Meta.BackgroundActor? new_background_actor = null;
+
+		public BackgroundManager (Meta.Screen screen, int monitor_index, bool control_position = true)
 		{
-			Object (screen: screen);
+			Object (screen: screen, monitor_index: monitor_index, control_position: control_position);
 		}
 
 		construct
 		{
-			screen.monitors_changed.connect (update);
+			background_source = BackgroundCache.get_default ().get_background_source (screen, BACKGROUND_SCHEMA);
 
-			update ();
+			background_actor = create_background_actor ();
 		}
 
-		~BackgroundManager ()
+		public override void destroy ()
 		{
-			screen.monitors_changed.disconnect (update);
-		}
+			BackgroundCache.get_default ().release_background_source (BACKGROUND_SCHEMA);
+			background_source = null;
 
-		void update ()
-		{
-			var reference_child = get_child_at_index (0);
-			if (reference_child != null) {
-				(reference_child as Background).changed.disconnect (background_changed);
+			if (new_background_actor != null) {
+				new_background_actor.destroy ();
+				new_background_actor = null;
 			}
 
-			destroy_all_children ();
+			if (background_actor != null) {
+				background_actor.destroy ();
+				background_actor = null;
+			}
 
-			var settings = BackgroundSettings.get_default ().schema;
+			base.destroy ();
+		}
 
-			for (var i = 0; i < screen.get_n_monitors (); i++) {
-				var geom = screen.get_monitor_geometry (i);
-				var background = new Background (screen, i, settings);
+		void swap_background_actor ()
+		{
+			var old_background_actor = background_actor;
+			background_actor = new_background_actor;
+			new_background_actor = null;
+
+			if (old_background_actor == null)
+				return;
+
+			var transition = new Clutter.PropertyTransition ("opacity");
+			transition.set_from_value (255);
+			transition.set_to_value (0);
+			transition.duration = FADE_ANIMATION_TIME;
+			transition.progress_mode = Clutter.AnimationMode.EASE_OUT_QUAD;
+			transition.remove_on_complete = true;
+			transition.completed.connect (() => {
+				old_background_actor.destroy ();
 
-				background.set_position (geom.x, geom.y);
-				background.set_size (geom.width, geom.height);
+				changed ();
+			});
 
-				add_child (background);
+			old_background_actor.add_transition ("fade-out", transition);
+		}
 
-				if (i == 0)
-					background.changed.connect (background_changed);
+		void update_background_actor ()
+		{
+			if (new_background_actor != null) {
+				// Skip displaying existing background queued for load
+				new_background_actor.destroy ();
+				new_background_actor = null;
 			}
+
+			new_background_actor = create_background_actor ();
+			new_background_actor.vignette_sharpness = background_actor.vignette_sharpness;
+			new_background_actor.brightness = background_actor.brightness;
+			new_background_actor.visible = background_actor.visible;
+
+			var background = new_background_actor.background.get_data<Background> ("delegate");
+
+			if (background.is_loaded) {
+				swap_background_actor ();
+				return;
+			}
+
+			ulong handler = 0;
+			handler = background.loaded.connect (() => {
+				SignalHandler.disconnect (background, handler);
+				background.set_data<ulong> ("background-loaded-handler", 0);
+
+				swap_background_actor ();
+			});
+			background.set_data<ulong> ("background-loaded-handler", handler);
 		}
 
-		void background_changed ()
+		Meta.BackgroundActor create_background_actor ()
 		{
-			changed ();
+			var background = background_source.get_background (monitor_index);
+			var background_actor = new Meta.BackgroundActor (screen, monitor_index);
+
+			background_actor.background = background.background;
+
+			insert_child_below (background_actor, null);
+
+			var monitor = screen.get_monitor_geometry (monitor_index);
+
+			background_actor.set_size (monitor.width, monitor.height);
+
+			if (control_position) {
+				background_actor.set_position (monitor.x, monitor.y);
+			}
+
+			ulong changed_handler = 0;
+			changed_handler = background.changed.connect (() => {
+				SignalHandler.disconnect (background, changed_handler);
+				changed_handler = 0;
+				update_background_actor ();
+			});
+
+			background_actor.destroy.connect (() => {
+				if (changed_handler != 0) {
+					SignalHandler.disconnect (background, changed_handler);
+					changed_handler = 0;
+				}
+
+				var loaded_handler = background.get_data<ulong> ("background-loaded-handler");
+				if (loaded_handler != 0) {
+					SignalHandler.disconnect (background, loaded_handler);
+					background.set_data<ulong> ("background-loaded-handler", 0);
+				}
+			});
+
+			return background_actor;
 		}
 	}
 }
diff -Naur gala/src/Background/BackgroundSource.vala gala-3.14/src/Background/BackgroundSource.vala
--- gala/src/Background/BackgroundSource.vala	1970-01-01 01:00:00.000000000 +0100
+++ gala-3.14/src/Background/BackgroundSource.vala	2014-12-26 21:37:58.389301000 +0100
@@ -0,0 +1,162 @@
+//
+//  Copyright (C) 2014 Tom Beckmann
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+//
+
+namespace Gala
+{
+	public class BackgroundSource : Object
+	{
+		public signal void changed ();
+
+		public Meta.Screen screen { get; construct; }
+		public Settings settings { get; construct; }
+
+		internal int use_count { get; set; default = 0; }
+
+		Gee.HashMap<int,Background> backgrounds;
+
+		public BackgroundSource (Meta.Screen screen, string settings_schema)
+		{
+			Object (screen: screen, settings: new Settings (settings_schema));
+		}
+
+		construct
+		{
+			backgrounds = new Gee.HashMap<int,Background> ();
+
+			screen.monitors_changed.connect (monitors_changed);
+
+			settings_hash_cache = get_current_settings_hash_cache ();
+			settings.changed.connect (settings_changed);
+		}
+
+		void monitors_changed ()
+		{
+			var n = screen.get_n_monitors ();
+			var i = 0;
+
+			foreach (var background in backgrounds.values) {
+				if (i++ < n) {
+					background.update_resolution ();
+					continue;
+				}
+
+				background.changed.disconnect (background_changed);
+				background.destroy ();
+				// TODO can we remove from a list while iterating?
+				backgrounds.unset (i);
+			}
+		}
+
+		public Background get_background (int monitor_index)
+		{
+			string? filename = null;
+
+			var style = settings.get_enum ("picture-options");
+			if (style != GDesktop.BackgroundStyle.NONE) {
+				var uri = settings.get_string ("picture-uri");
+				if (Uri.parse_scheme (uri) != null)
+					filename = File.new_for_uri (uri).get_path ();
+				else
+					filename = uri;
+			}
+
+			// Animated backgrounds are (potentially) per-monitor, since
+			// they can have variants that depend on the aspect ratio and
+			// size of the monitor; for other backgrounds we can use the
+			// same background object for all monitors.
+			if (filename == null || !filename.has_suffix (".xml"))
+				monitor_index = 0;
+
+			if (!backgrounds.has_key (monitor_index)) {
+				var background = new Background (screen, monitor_index, filename, this, (GDesktop.BackgroundStyle) style);
+
+				background.changed.connect (background_changed);
+
+				backgrounds[monitor_index] = background;
+			}
+
+			return backgrounds[monitor_index];
+		}
+
+		void background_changed (Background background)
+		{
+			background.changed.disconnect (background_changed);
+			background.destroy ();
+			backgrounds.unset (background.monitor_index);
+		}
+
+		public void destroy ()
+		{
+			screen.monitors_changed.disconnect (monitors_changed);
+
+			foreach (var background in backgrounds) {
+				background.changed.disconnect (background_changed);
+				background.destroy ();
+			}
+		}
+
+		// unfortunately the settings sometimes tend to fire random changes even though
+		// nothing actually happend. The code below is used to prevent us from spamming
+		// new actors all the time, which lead to some problems in other areas of the code
+
+		// helper struct which stores the hash values generated by g_variant_hash
+		struct SettingsHashCache
+		{
+			uint color_shading_type;
+			uint picture_opacity;
+			uint picture_options;
+			uint picture_uri;
+			uint primar_color;
+			uint secondary_color;
+		}
+
+		SettingsHashCache settings_hash_cache;
+
+		// list of keys that are actually relevant for us
+		const string[] options = { "color-shading-type", "picture-opacity",
+				"picture-options", "picture-uri", "primary-color", "secondary-color" };
+
+		void settings_changed (string key)
+		{
+			if (!(key in options))
+				return;
+
+			var current = get_current_settings_hash_cache ();
+
+			if (Memory.cmp (&settings_hash_cache, &current, sizeof (SettingsHashCache)) == 0) {
+				return;
+			}
+
+			Memory.copy (&settings_hash_cache, &current, sizeof (SettingsHashCache));
+
+			changed ();
+		}
+
+		SettingsHashCache get_current_settings_hash_cache ()
+		{
+			return {
+				settings.get_value ("color-shading-type").hash (),
+				settings.get_value ("picture-opacity").hash (),
+				settings.get_value ("picture-options").hash (),
+				settings.get_value ("picture-uri").hash (),
+				settings.get_value ("primary-color").hash (),
+				settings.get_value ("secondary-color").hash ()
+			};
+		}
+	}
+}
+
diff -Naur gala/src/Background/SlideShow.vala gala-3.14/src/Background/SlideShow.vala
--- gala/src/Background/SlideShow.vala	2014-12-26 21:37:36.907203000 +0100
+++ gala-3.14/src/Background/SlideShow.vala	1970-01-01 01:00:00.000000000 +0100
@@ -1,155 +0,0 @@
-//
-//  Copyright (C) 2013 Tom Beckmann, Rico Tzschichholz
-//
-//  This program is free software: you can redistribute it and/or modify
-//  it under the terms of the GNU General Public License as published by
-//  the Free Software Foundation, either version 3 of the License, or
-//  (at your option) any later version.
-//
-//  This program is distributed in the hope that it will be useful,
-//  but WITHOUT ANY WARRANTY; without even the implied warranty of
-//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-//  GNU General Public License for more details.
-//
-//  You should have received a copy of the GNU General Public License
-//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-//
-
-namespace Gala
-{
-	public class SlideShow : Meta.BackgroundGroup
-	{
-		const double ANIMATION_OPACITY_STEP_INCREMENT = 4.0;
-		const double ANIMATION_MIN_WAKEUP_INTERVAL = 1.0;
-
-		public string file { get; construct set; }
-		public Meta.Screen screen { get; construct set; }
-		public int monitor { get; construct set; }
-		public GDesktop.BackgroundStyle style { get; construct set; }
-
-		Gnome.BGSlideShow? animation = null;
-
-		double animation_duration = 0.0;
-		double animation_progress = 0.0;
-
-		uint update_animation_timeout_id;
-
-		Meta.BackgroundActor image_from;
-		Meta.BackgroundActor image_to;
-
-		public SlideShow (string file, Meta.Screen screen, int monitor, GDesktop.BackgroundStyle style)
-		{
-			Object (file: file, screen: screen, monitor: monitor, style: style);
-		}
-
-		construct
-		{
-			var geom = screen.get_monitor_geometry (monitor);
-			width = geom.width;
-			height = geom.height;
-
-			image_to = new Meta.BackgroundActor ();
-			image_from = new Meta.BackgroundActor ();
-
-			add_child (image_from);
-			add_child (image_to);
-		}
-
-		~SlideShow ()
-		{
-			if (update_animation_timeout_id > 0)
-				Source.remove (update_animation_timeout_id);
-		}
-
-		public async bool load ()
-		{
-			animation = new Gnome.BGSlideShow (file);
-			animation.load_async (null, (obj, res) => {
-				load.callback ();
-			});
-			yield;
-
-			yield update_animation ();
-
-			return true;
-		}
-
-		/**
-		 * SlideShow animation related functions
-		 */
-		async void update_animation ()
-		{
-			if (animation == null)
-				return;
-
-			update_animation_timeout_id = 0;
-
-			bool is_fixed;
-			string file_from, file_to;
-			double progress, duration;
-			animation.get_current_slide ((int)width, (int)height, out progress,
-				out duration, out is_fixed, out file_from, out file_to);
-
-			animation_duration = duration;
-			animation_progress = progress;
-
-			if (file_from == null && file_to == null) {
-				queue_update_animation ();
-				return;
-			}
-
-			if (image_from.content == null
-				|| (image_from.content as Meta.Background).get_filename () != file_from) {
-				yield update_image (image_from, file_from);
-			}
-			if (image_to.content == null
-				|| (image_to.content as Meta.Background).get_filename () != file_to) {
-				yield update_image (image_to, file_to);
-			}
-
-			update_animation_progress ();
-		}
-
-		/**
-		 * Returns the passed orig_image with the correct content or a new one if orig_image was null
-		 */
-		async void update_image (Meta.BackgroundActor image, string? file)
-		{
-			if (file == null) {
-				image.visible = false;
-				return;
-			}
-
-			image.visible = true;
-			image.content = yield BackgroundCache.get_default ().load_image (file, monitor, style);
-		}
-
-		void queue_update_animation ()
-		{
-			if (update_animation_timeout_id != 0 || animation_duration == 0.0)
-				return;
-
-			var n_steps = 255 / ANIMATION_OPACITY_STEP_INCREMENT;
-			var time_per_step = (uint)((animation_duration * 1000) / n_steps);
-			var interval = uint.max ((uint)(ANIMATION_MIN_WAKEUP_INTERVAL * 1000), time_per_step);
-
-			if (interval > uint.MAX)
-				return;
-
-			update_animation_timeout_id = Clutter.Threads.Timeout.add (interval, () => {
-				update_animation_timeout_id = 0;
-				update_animation.begin ();
-				return false;
-			});
-		}
-
-		void update_animation_progress ()
-		{
-			if (image_to != null)
-				image_to.opacity = (uint)(animation_progress * 255);
-
-			queue_update_animation ();
-		}
-	}
-}
-
diff -Naur gala/src/Background/SystemBackground.vala gala-3.14/src/Background/SystemBackground.vala
--- gala/src/Background/SystemBackground.vala	2014-12-26 21:37:36.907203000 +0100
+++ gala-3.14/src/Background/SystemBackground.vala	2014-12-26 21:37:58.389301000 +0100
@@ -1,5 +1,5 @@
 //
-//  Copyright (C) 2013 Tom Beckmann, Rico Tzschichholz
+//  Copyright (C) 2014 Tom Beckmann
 //
 //  This program is free software: you can redistribute it and/or modify
 //  it under the terms of the GNU General Public License as published by
@@ -19,18 +19,52 @@
 {
 	public class SystemBackground : Meta.BackgroundActor
 	{
-		public SystemBackground ()
+		const Clutter.Color DEFAULT_BACKGROUND_COLOR = { 0x2e, 0x34, 0x36, 0xff };
+		const string DEFAULT_BACKGROUND_FILE = Config.PKGDATADIR + "/texture.png";
+
+		static Meta.Background? system_background = null;
+
+		public signal void loaded ();
+
+		public SystemBackground (Meta.Screen screen)
 		{
-			Object ();
+			Object (meta_screen: screen, monitor: 0);
 		}
 
 		construct
 		{
-			var cache = BackgroundCache.get_default ();
-			cache.load_image.begin (Config.PKGDATADIR + "/texture.png", 0,
-				GDesktop.BackgroundStyle.WALLPAPER, (obj, res) => {
-				content = cache.load_image.end (res);
-			});
+			if (system_background == null) {
+				system_background = new Meta.Background (meta_screen);
+				system_background.set_color (DEFAULT_BACKGROUND_COLOR);
+#if HAS_MUTTER316
+				system_background.set_file (File.new_for_path (DEFAULT_BACKGROUND_FILE), GDesktop.BackgroundStyle.WALLPAPER);
+#else
+				system_background.set_filename (DEFAULT_BACKGROUND_FILE, GDesktop.BackgroundStyle.WALLPAPER);
+#endif
+			}
+
+			background = system_background;
+
+			var cache = Meta.BackgroundImageCache.get_default ();
+#if HAS_MUTTER316
+			var image = cache.load (File.new_for_path (DEFAULT_BACKGROUND_FILE));
+#else
+			var image = cache.load (DEFAULT_BACKGROUND_FILE);
+#endif
+			if (image.is_loaded ()) {
+				image = null;
+				Idle.add(() => {
+					loaded ();
+					return false;
+				});
+			} else {
+				ulong handler = 0;
+				handler = image.loaded.connect (() => {
+					loaded ();
+					SignalHandler.disconnect (image, handler);
+					image = null;
+				});
+			}
 		}
 	}
 }
diff -Naur gala/src/DBus.vala gala-3.14/src/DBus.vala
--- gala/src/DBus.vala	2014-12-26 21:37:36.907203000 +0100
+++ gala-3.14/src/DBus.vala	2014-12-26 21:37:58.389301000 +0100
@@ -44,7 +44,7 @@
 		private DBus ()
 		{
 			if (wm.background_group != null)
-				(wm.background_group as BackgroundManager).changed.connect (() => background_changed ());
+				(wm.background_group as BackgroundContainer).changed.connect (() => background_changed ());
 			else
 				assert_not_reached ();
 		}
diff -Naur gala/src/Makefile.am gala-3.14/src/Makefile.am
--- gala/src/Makefile.am	2014-12-26 21:37:36.907203000 +0100
+++ gala-3.14/src/Makefile.am	2014-12-26 21:37:58.389301000 +0100
@@ -43,10 +43,12 @@
 	WindowListener.vala \
 	WindowManager.vala \
 	WorkspaceManager.vala \
+	Background/Animation.vala \
 	Background/Background.vala \
 	Background/BackgroundCache.vala \
+	Background/BackgroundContainer.vala \
 	Background/BackgroundManager.vala \
-	Background/SlideShow.vala \
+	Background/BackgroundSource.vala \
 	Background/SystemBackground.vala \
 	Widgets/IconGroup.vala \
 	Widgets/IconGroupContainer.vala \
diff -Naur gala/src/Widgets/MonitorClone.vala gala-3.14/src/Widgets/MonitorClone.vala
--- gala/src/Widgets/MonitorClone.vala	2014-12-26 21:37:36.907203000 +0100
+++ gala-3.14/src/Widgets/MonitorClone.vala	2014-12-26 21:37:58.389301000 +0100
@@ -35,7 +35,7 @@
 		public int monitor { get; construct; }
 
 		WindowCloneContainer window_container;
-		Background background;
+		BackgroundManager background;
 
 		public MonitorClone (Screen screen, int monitor)
 		{
@@ -46,7 +46,7 @@
 		{
 			reactive = true;
 
-			background = new Background (screen, monitor, BackgroundSettings.get_default ().schema);
+			background = new BackgroundManager (screen, monitor, false);
 			background.set_easing_duration (300);
 
 			window_container = new WindowCloneContainer ();
diff -Naur gala/src/Widgets/WorkspaceClone.vala gala-3.14/src/Widgets/WorkspaceClone.vala
--- gala/src/Widgets/WorkspaceClone.vala	2014-12-26 21:37:36.907203000 +0100
+++ gala-3.14/src/Widgets/WorkspaceClone.vala	2014-12-26 21:37:58.389301000 +0100
@@ -23,14 +23,13 @@
 	/**
 	 * Utility class which adds a border and a shadow to a Background
 	 */
-	class FramedBackground : Background
+	class FramedBackground : BackgroundManager
 	{
 		public FramedBackground (Screen screen)
 		{
-			Object (screen: screen, monitor: screen.get_primary_monitor (), 
-				settings: BackgroundSettings.get_default ().schema);
+			Object (screen: screen, monitor_index: screen.get_primary_monitor (), control_position: false);
 		}
-		
+
 		construct
 		{
 			var primary = screen.get_primary_monitor ();
@@ -111,7 +110,7 @@
 			}
 		}
 
-		Background background;
+		BackgroundManager background;
 		bool opened;
 
 		uint hover_activate_timeout = 0;
diff -Naur gala/src/WindowManager.vala gala-3.14/src/WindowManager.vala
--- gala/src/WindowManager.vala	2014-12-26 21:37:36.907203000 +0100
+++ gala-3.14/src/WindowManager.vala	2014-12-26 21:37:58.389301000 +0100
@@ -89,7 +89,6 @@
 			var screen = get_screen ();
 
 			DBus.init (this);
-			BackgroundCache.init (screen);
 			WindowListener.init (screen);
 
 			// Due to a bug which enables access to the stage when using multiple monitors
@@ -121,7 +120,7 @@
 			 * +-- top window group
 		     */
 
-			var system_background = new SystemBackground ();
+			var system_background = new SystemBackground (screen);
 			system_background.add_constraint (new Clutter.BindConstraint (stage,
 				Clutter.BindCoordinate.ALL, 0));
 			stage.insert_child_below (system_background, null);
@@ -134,7 +133,7 @@
 			stage.remove_child (window_group);
 			ui_group.add_child (window_group);
 
-			background_group = new BackgroundManager (screen);
+			background_group = new BackgroundContainer (screen);
 			window_group.add_child (background_group);
 			window_group.set_child_below_sibling (background_group, null);
 
@@ -1177,14 +1176,14 @@
 
 				// to maintain the correct order of monitor, we need to insert the Background
 				// back manually
-				if (actor is Background) {
-					var background = (Background) actor;
+				if (actor is BackgroundManager) {
+					var background = (BackgroundManager) actor;
 
 					background.get_parent ().remove_child (background);
-					background_group.insert_child_at_index (background, background.monitor);
+					background_group.insert_child_at_index (background, background.monitor_index);
 					background.x = background.steal_data<int> ("prev-x");
 					continue;
-				} else if (actor is BackgroundManager) {
+				} else if (actor is Meta.BackgroundGroup) {
 					actor.x = 0;
 					// thankfully mutter will take care of stacking it at the right place for us
 					clutter_actor_reparent (actor, window_group);
