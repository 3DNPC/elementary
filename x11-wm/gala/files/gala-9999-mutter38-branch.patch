=== modified file 'CMakeLists.txt'
--- CMakeLists.txt	2013-09-28 22:17:35 +0000
+++ CMakeLists.txt	2013-10-10 07:33:41 +0000
@@ -31,10 +31,10 @@
 list (APPEND CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake)
 
 configure_file (${CMAKE_SOURCE_DIR}/src/Config.vala.cmake ${CMAKE_BINARY_DIR}/src/Config.vala)
-add_definitions(-DGETTEXT_PACKAGE=\"${GETTEXT_PACKAGE}\")
+add_definitions(-DGETTEXT_PACKAGE=\"${GETTEXT_PACKAGE}\" -DGNOME_DESKTOP_USE_UNSTABLE_API)
 
 find_package(PkgConfig)
-pkg_check_modules(DEPS REQUIRED libmutter>=3.4 granite clutter-1.0>=1.9.16 clutter-gtk-1.0 libbamf3 xfixes gee-1.0 plank)
+pkg_check_modules(DEPS REQUIRED libmutter>=3.4 granite clutter-1.0>=1.9.16 clutter-gtk-1.0 libbamf3 xfixes gee-1.0 plank gnome-desktop-3.0)
 
 set (MUTTER36_FLAGS "")
 pkg_check_modules(MUTTER36 QUIET libmutter>=3.5)
@@ -77,6 +77,11 @@
     src/TextShadowEffect.vala
     src/Utils.vala
     src/Zooming.vala
+    src/Background/Animation.vala
+    src/Background/Background.vala
+    src/Background/BackgroundCache.vala
+    src/Background/BackgroundManager.vala
+    src/Background/SystemBackground.vala
     src/Widgets/AppIcon.vala
     src/Widgets/WindowOverview.vala
     src/Widgets/WindowSwitcher.vala
@@ -92,6 +97,7 @@
     clutter-gtk-1.0
     gdk-x11-3.0
     gdesktopenums-3.0
+    gnome-desktop-3.0
     xfixes-4.0
 OPTIONS
     -g

=== modified file 'data/texture.png'
Binary files data/texture.png	2013-02-17 00:38:16 +0000 and data/texture.png	2013-10-10 07:33:41 +0000 differ
=== added directory 'src/Background'
=== added file 'src/Background/Animation.vala'
--- src/Background/Animation.vala	1970-01-01 00:00:00 +0000
+++ src/Background/Animation.vala	2013-10-10 07:33:41 +0000
@@ -0,0 +1,76 @@
+//  
+//  Copyright (C) 2013 Tom Beckmann, Rico Tzschichholz
+// 
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+// 
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+// 
+
+namespace Gala
+{
+	public class Animation : Object
+	{
+		public string filename { get; construct set; }
+		public Meta.Screen screen { get; construct set; }
+
+		public Gee.LinkedList<string> key_frame_files { get; private set; }
+		public double transition_progress { get; private set; default = 0.0; }
+		public double transition_duration { get; private set; default = 0.0; }
+		public bool loaded { get; private set; default = false; }
+
+		Gnome.BGSlideShow? show = null;
+
+		public Animation (Meta.Screen screen, string filename)
+		{
+			Object (filename: filename, screen: screen);
+			key_frame_files = new Gee.LinkedList<string> ();
+		}
+
+		public async void load ()
+		{
+			show = new Gnome.BGSlideShow (filename);
+
+			//FIXME yield show.load_async (null);
+			show.load ();
+			loaded = true;
+		}
+
+		public void update (int monitor_index)
+		{
+			key_frame_files = new Gee.LinkedList<string> ();
+
+			if (show == null)
+				return;
+
+			if (show.get_num_slides () < 1)
+				return;
+
+			var monitor = screen.get_monitor_geometry (monitor_index);
+
+			bool is_fixed;
+			string file1, file2;
+			double progress, duration;
+			show.get_current_slide (monitor.width, monitor.height, out progress, 
+				out duration, out is_fixed, out file1, out file2);
+
+			transition_progress = progress;
+			transition_duration = duration;
+
+			if (file1 != null)
+				key_frame_files.add (file1);
+
+			if (file2 != null)
+				key_frame_files.add (file2);
+		}
+	}
+}
+

=== added file 'src/Background/Background.vala'
--- src/Background/Background.vala	1970-01-01 00:00:00 +0000
+++ src/Background/Background.vala	2013-10-10 07:33:41 +0000
@@ -0,0 +1,381 @@
+//  
+//  Copyright (C) 2013 Tom Beckmann, Rico Tzschichholz
+// 
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+// 
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+// 
+
+// Code has been ported from gnome-shell's js/ui/background.js
+
+namespace Gala
+{
+	public class Background : Object
+	{
+		const string BACKGROUND_SCHEMA = "org.gnome.desktop.background";
+		const string PRIMARY_COLOR_KEY = "primary-color";
+		const string SECONDARY_COLOR_KEY = "secondary-color";
+		const string COLOR_SHADING_TYPE_KEY = "color-shading-type";
+		const string BACKGROUND_STYLE_KEY = "picture-options";
+		const string PICTURE_OPACITY_KEY = "picture-opacity";
+		const string PICTURE_URI_KEY = "picture-uri";
+
+		const uint FADE_ANIMATION_TIME = 1000;
+
+		// These parameters affect how often we redraw.
+		// The first is how different (percent crossfaded) the slide show
+		// has to look before redrawing and the second is the minimum
+		// frequency (in seconds) we're willing to wake up
+		const double ANIMATION_OPACITY_STEP_INCREMENT = 4.0;
+		const double ANIMATION_MIN_WAKEUP_INTERVAL = 1.0;
+
+		public Meta.BackgroundEffects effects { get; construct set; }
+		public Settings settings { get; construct set; }
+		public int monitor_index { get; construct set; }
+
+		public Meta.BackgroundGroup actor { get; private set; }
+		public bool is_loaded { get; private set; }
+
+		// those two are set by the BackgroundManager
+		internal ulong change_signal_id = 0;
+		internal ulong loaded_signal_id = 0;
+
+		float _brightness;
+		public float brightness {
+			get {
+				return _brightness;
+			}
+			set {
+				_brightness = value;
+				if (pattern != null && pattern.content != null)
+					(pattern.content as Meta.Background).brightness = value;
+
+				foreach (var image in images) {
+					if (image != null && image.content != null)
+						(image.content as Meta.Background).brightness = brightness;
+				}
+			}
+		}
+
+		float _vignette_sharpness;
+		public float vignette_sharpness {
+			get {
+				return _vignette_sharpness;
+			}
+			set {
+				_vignette_sharpness = value;
+				if (pattern != null && pattern.content != null)
+					(pattern.content as Meta.Background).vignette_sharpness = value;
+
+				foreach (var image in images) {
+					if (image != null && image.content != null)
+						(image.content as Meta.Background).vignette_sharpness = vignette_sharpness;
+				}
+			}
+		}
+
+		GDesktop.BackgroundStyle style;
+
+		Meta.BackgroundActor? pattern;
+		BackgroundCache cache;
+
+		Animation animation;
+
+		Cancellable? cancellable = null;
+		uint update_animation_timeout_id = 0;
+
+		Meta.BackgroundActor images[2];
+		Gee.HashMap<string,ulong> file_watches;
+
+		string filename;
+		uint num_pending_images;
+
+		public signal void changed ();
+		public signal void loaded ();
+
+		public Background (int monitor_index, Meta.BackgroundEffects effects, Settings settings)
+		{
+			Object (monitor_index: monitor_index, effects: effects, settings: settings);
+			actor = new Meta.BackgroundGroup ();
+
+			file_watches = new Gee.HashMap<string,ulong> ();
+			pattern = null;
+			// contains a single image for static backgrounds and
+			// two images (from and to) for slide shows
+			images = { null, null };
+
+			brightness = 1.0f;
+			vignette_sharpness = 0.2f;
+			cancellable = new Cancellable ();
+			is_loaded = false;
+
+			settings.changed.connect (() => {
+				changed ();
+			});
+
+			load ();
+
+			actor.destroy.connect (destroy);
+		}
+
+		public void destroy ()
+		{
+			if (cancellable != null)
+				cancellable.cancel ();
+
+			if (update_animation_timeout_id != 0) {
+				Source.remove (update_animation_timeout_id);
+				update_animation_timeout_id = 0;
+			}
+
+			foreach (var key in file_watches.keys) {
+				cache.disconnect (file_watches.get (key));
+			}
+			file_watches = null;
+
+			if (pattern != null) {
+				if (pattern.content != null)
+					cache.remove_pattern_content (pattern.content as Meta.Background);
+
+				pattern.destroy ();
+				pattern = null;
+			}
+
+			foreach (var image in images) {
+				if (image == null)
+					continue;
+
+				if (image.content != null)
+					cache.remove_image_content (image.content as Meta.Background);
+
+				image.destroy ();
+			}
+		}
+
+		public void set_loaded ()
+		{
+			if (is_loaded)
+				return;
+
+			is_loaded = true;
+
+			Idle.add (() => {
+				loaded ();
+				return false;
+			});
+		}
+
+		public void load_pattern ()
+		{
+			var color = Clutter.Color.from_string (settings.get_string (PRIMARY_COLOR_KEY));
+			var second_color = Clutter.Color.from_string (settings.get_string (SECONDARY_COLOR_KEY));
+
+			var shading_type = (GDesktop.BackgroundShading)settings.get_enum (COLOR_SHADING_TYPE_KEY);
+
+			var content = cache.get_pattern_content (monitor_index, color, second_color, shading_type, effects);
+
+			pattern = new Meta.BackgroundActor ();
+			actor.add_child (pattern);
+
+			pattern.content = content;
+		}
+
+		public void watch_cache_file (string filename)
+		{
+			if (file_watches.has_key (filename))
+				return;
+
+			var signal_id = cache.file_changed.connect ((changed_file) => {
+				if (changed_file == filename) {
+					changed ();
+				}
+			});
+
+			file_watches.set (filename, signal_id);
+		}
+
+		public void add_image (Meta.Background content, int index, string filename) {
+			content.brightness = brightness;
+			content.vignette_sharpness = vignette_sharpness;
+
+			var actor = new Meta.BackgroundActor ();
+			actor.content = content;
+
+			// The background pattern is the first actor in
+			// the group, and all images should be above that.
+			this.actor.insert_child_at_index (actor, index + 1);
+
+			images[index] = actor;
+			watch_cache_file (filename);
+		}
+
+		public void update_image (Meta.Background content, int index, string filename) {
+			content.brightness = brightness;
+			content.vignette_sharpness = vignette_sharpness;
+
+			cache.remove_image_content (images[index].content as Meta.Background);
+			images[index].content = content;
+			watch_cache_file (filename);
+		}
+
+		public void update_animation_progress ()
+		{
+			if (images[1] != null)
+				images[1].opacity = (uint)(animation.transition_progress * 255);
+
+			queue_update_animation();
+		}
+
+		public void update_animation ()
+		{
+			update_animation_timeout_id = 0;
+
+			animation.update (monitor_index);
+			var files = animation.key_frame_files;
+
+			if (files.size == 0) {
+				set_loaded ();
+				queue_update_animation ();
+				return;
+			}
+
+			num_pending_images = files.size;
+			for (var i = 0; i < files.size; i++) {
+				var image = images[i];
+				if (image != null && image.content != null &&
+					(image.content as Meta.Background).get_filename () == files.get (i)) {
+
+					num_pending_images--;
+					if (num_pending_images == 0)
+						update_animation_progress ();
+
+					continue;
+				}
+
+				cache.get_image_content (monitor_index, style, files[i], effects,
+					this, get_update_animation_callback (i), cancellable);
+			}
+		}
+
+		// FIXME wrap callback method to keep the i at the correct value, I suppose
+		//	   we should find a nicer way to do this
+		PendingFileLoadFinished get_update_animation_callback (int i) {
+			return (userdata, content) => {
+				var self = userdata as Background;
+				self.num_pending_images--;
+
+				if (content == null) {
+					self.set_loaded ();
+					if (self.num_pending_images == 0)
+						self.update_animation_progress ();
+					return;
+				}
+
+				if (self.images[i] == null) {
+					self.add_image (content, i, self.animation.key_frame_files.get (i));
+				} else {
+					self.update_image (content, i, self.animation.key_frame_files.get (i));
+				}
+
+				if (self.num_pending_images == 0) {
+					self.set_loaded ();
+					self.update_animation_progress ();
+				}
+			};
+		}
+
+		public void queue_update_animation ()
+		{
+			if (update_animation_timeout_id != 0)
+				return;
+
+			if (cancellable == null || cancellable.is_cancelled ())
+				return;
+
+			if (animation.transition_duration == 0.0)
+				return;
+
+			var n_steps = 255 / ANIMATION_OPACITY_STEP_INCREMENT;
+			var time_per_step = (uint)((animation.transition_duration * 1000) / n_steps);
+
+			var interval = uint.max ((uint)(ANIMATION_MIN_WAKEUP_INTERVAL * 1000), time_per_step);
+
+			if (interval > uint.MAX)
+				return;
+
+			update_animation_timeout_id = Timeout.add (interval, () => {
+				update_animation_timeout_id = 0;
+				update_animation ();
+				return false;
+			});
+		}
+
+		public void load_animation (string filename)
+		{
+			cache.get_animation.begin (filename, (obj, res) => {
+				animation = cache.get_animation.end (res);
+
+				if (animation == null || cancellable.is_cancelled ()) {
+					set_loaded ();
+					return;
+				}
+
+				update_animation ();
+				watch_cache_file (filename);
+			});
+		}
+
+		public void load_file (string filename)
+		{
+			this.filename = filename;
+			cache.get_image_content (monitor_index, style, filename, effects, this, (userdata, content) => {
+				var self = userdata as Background;
+				if (content == null) {
+					if (!self.cancellable.is_cancelled ())
+						self.load_animation (self.filename);
+					return;
+				}
+
+				self.add_image (content, 0, self.filename);
+				self.set_loaded ();
+			}, cancellable);
+		}
+
+		public void load ()
+		{
+			cache = BackgroundCache.get_default ();
+
+			load_pattern ();
+
+			style = (GDesktop.BackgroundStyle)settings.get_enum (BACKGROUND_STYLE_KEY);
+			if (style == GDesktop.BackgroundStyle.NONE) {
+				set_loaded ();
+				return;
+			}
+
+			var uri = settings.get_string (PICTURE_URI_KEY);
+			string filename;
+			if (Uri.parse_scheme (uri) != null)
+				filename = File.new_for_uri (uri).get_path ();
+			else
+				filename = uri;
+
+			if (filename == null) {
+				set_loaded ();
+				return;
+			}
+
+			load_file (filename);
+		}
+	}
+}
+

=== added file 'src/Background/BackgroundCache.vala'
--- src/Background/BackgroundCache.vala	1970-01-01 00:00:00 +0000
+++ src/Background/BackgroundCache.vala	2013-10-10 07:33:41 +0000
@@ -0,0 +1,284 @@
+//  
+//  Copyright (C) 2013 Tom Beckmann, Rico Tzschichholz
+// 
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+// 
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+// 
+
+namespace Gala
+{
+	public delegate void PendingFileLoadFinished (Object userdata, Meta.Background? content);
+
+	struct PendingFileLoad
+	{
+		string filename;
+		GDesktop.BackgroundStyle style;
+		Gee.LinkedList<PendingFileLoadCaller?> callers;
+	}
+
+	struct PendingFileLoadCaller
+	{
+		bool should_copy;
+		int monitor_index;
+		Meta.BackgroundEffects effects;
+		PendingFileLoadFinished on_finished;
+		Object userdata;
+	}
+
+	public class BackgroundCache : Object
+	{
+		static BackgroundCache? instance = null;
+
+		Meta.Screen screen;
+
+		Gee.LinkedList<Meta.Background> patterns;
+		Gee.LinkedList<Meta.Background> images;
+		Gee.LinkedList<PendingFileLoad?> pending_file_loads;
+		Gee.HashMap<string,FileMonitor> file_monitors;
+
+		string animation_filename;
+		Animation animation;
+
+		public signal void file_changed (string filename);
+
+		public BackgroundCache (Meta.Screen _screen)
+		{
+			screen = _screen;
+
+			patterns = new Gee.LinkedList<Meta.Background> ();
+			images = new Gee.LinkedList<Meta.Background> ();
+			pending_file_loads = new Gee.LinkedList<PendingFileLoad?> ();
+			file_monitors = new Gee.HashMap<string,FileMonitor> ();
+		}
+
+		public Meta.Background get_pattern_content (int monitor_index, Clutter.Color color,
+			Clutter.Color second_color, GDesktop.BackgroundShading shading_type, Meta.BackgroundEffects effects)
+		{
+			Meta.Background? content = null, candidate_content = null;
+
+			foreach (var pattern in patterns) {
+				if (pattern == null)
+					continue;
+
+				if (pattern.get_shading() != shading_type)
+					continue;
+
+				if (color.equal(pattern.get_color ()))
+					continue;
+
+				if (shading_type != GDesktop.BackgroundShading.SOLID &&
+					!second_color.equal(pattern.get_second_color ()))
+					continue;
+
+				candidate_content = pattern;
+
+				if (effects != pattern.effects)
+					continue;
+
+				break;
+			}
+
+			if (candidate_content != null) {
+				content = candidate_content.copy (monitor_index, effects);
+			} else {
+				content = new Meta.Background (screen, monitor_index, effects);
+
+				if (shading_type == GDesktop.BackgroundShading.SOLID) {
+					content.load_color (color);
+				} else {
+					content.load_gradient (shading_type, color, second_color);
+				}
+			}
+
+			patterns.add (content);
+
+			return content;
+		}
+
+		public void monitor_file (string filename)
+		{
+			if (file_monitors.has_key (filename))
+				return;
+
+			var file = File.new_for_path (filename);
+			try {
+				var monitor = file.monitor (FileMonitorFlags.NONE);
+
+				//TODO maybe do this in a cleaner way
+				ulong signal_id = 0;
+				signal_id = monitor.changed.connect (() => {
+					foreach (var image in images) {
+						if (image.get_filename () == filename)
+							images.remove (image);
+					}
+
+					monitor.disconnect (signal_id);
+
+					file_changed (filename);
+				});
+
+				file_monitors.set (filename, monitor);
+			} catch (Error e) { warning (e.message); }
+		}
+
+		public void remove_content (Gee.LinkedList<Meta.Background> content_list, Meta.Background content) {
+			content_list.remove (content);
+		}
+
+		public void remove_pattern_content (Meta.Background content) {
+			remove_content (patterns, content);
+		}
+
+		public void remove_image_content (Meta.Background content) {
+			var filename = content.get_filename();
+
+			if (filename != null && file_monitors.has_key (filename))
+				//TODO disconnect filemonitor and delete it properly
+				file_monitors.unset (filename);
+
+			remove_content(images, content);
+		}
+
+		//FIXME as we may have to get a number of callbacks fired when this finishes,
+		//	  we can't use vala's async system, but use a callback based system instead
+		public void load_image_content (int monitor_index,
+			GDesktop.BackgroundStyle style, string filename, Meta.BackgroundEffects effects,
+			Object userdata, PendingFileLoadFinished on_finished, Cancellable? cancellable = null)
+		{
+			foreach (var pending_file_load in pending_file_loads) {
+				if (pending_file_load.filename == filename &&
+					pending_file_load.style == style) {
+					pending_file_load.callers.add ({true, monitor_index, effects, on_finished, userdata});
+					return;
+				}
+			}
+
+			PendingFileLoad load = {filename, style, new Gee.LinkedList<PendingFileLoadCaller?> ()};
+			load.callers.add ({false, monitor_index, effects, on_finished, userdata});
+			pending_file_loads.add (load);
+
+			var content = new Meta.Background (screen, monitor_index, effects);
+			content.load_file_async.begin (filename, style, cancellable, (obj, res) => {
+				try {
+				  content.load_file_async.end (res);
+
+				  monitor_file (filename);
+				  images.add (content);
+				} catch (Error e) {
+				  content = null;
+				}
+
+				foreach (var pending_load in pending_file_loads) {
+					if (pending_load.filename != filename ||
+						pending_load.style != style)
+						continue;
+
+					foreach (var caller in pending_load.callers) {
+						if (caller.on_finished != null) {
+							if (content != null && caller.should_copy) {
+								content = (obj as Meta.Background).copy (caller.monitor_index, caller.effects);
+							}
+
+							caller.on_finished (caller.userdata, content);
+						}
+					}
+
+					pending_file_loads.remove (pending_load);
+				}
+			});
+		}
+
+		public void get_image_content (int monitor_index, GDesktop.BackgroundStyle style, 
+			string filename, Meta.BackgroundEffects effects, Object userdata, 
+			PendingFileLoadFinished on_finished, Cancellable? cancellable = null)
+		{
+			Meta.Background content = null, candidate_content = null;
+			foreach (var image in images) {
+				if (image == null)
+					continue;
+
+				if (image.get_style () != style)
+					continue;
+
+				if (image.get_filename () != filename)
+					continue;
+
+				if (style == GDesktop.BackgroundStyle.SPANNED &&
+					image.monitor != monitor_index)
+					continue;
+
+				candidate_content = image;
+
+				if (effects != image.effects)
+					continue;
+
+				break;
+			}
+
+			if (candidate_content != null) {
+				content = candidate_content.copy (monitor_index, effects);
+
+				if (cancellable != null && cancellable.is_cancelled ())
+					content = null;
+				else
+					images.add (content);
+
+				on_finished (userdata, content);
+			} else {
+				load_image_content (monitor_index, style, filename, effects, userdata, on_finished, cancellable);
+			}
+		}
+
+		public async Animation get_animation (string filename)
+		{
+			Animation animation;
+
+			if (animation_filename == filename) {
+				animation = this.animation;
+
+				//FIXME do we need those Idles?
+				Idle.add (() => {
+					get_animation.callback ();
+					return false;
+				});
+			} else {
+				animation = new Animation (screen, filename);
+
+				yield animation.load ();
+
+				monitor_file (filename);
+				animation_filename = filename;
+				this.animation = animation;
+
+				Idle.add (() => {
+					get_animation.callback ();
+					return false;
+				});
+			}
+
+			yield;
+			return animation;
+		}
+		
+		public static void init (Meta.Screen screen)
+		{
+			instance = new BackgroundCache (screen);
+		}
+
+		public static BackgroundCache get_default ()
+		{
+			return instance;
+		}
+	}
+}
+

=== added file 'src/Background/BackgroundManager.vala'
--- src/Background/BackgroundManager.vala	1970-01-01 00:00:00 +0000
+++ src/Background/BackgroundManager.vala	2013-10-10 07:33:41 +0000
@@ -0,0 +1,121 @@
+//  
+//  Copyright (C) 2013 Tom Beckmann, Rico Tzschichholz
+// 
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+// 
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+// 
+
+namespace Gala
+{
+	public class BackgroundManager : Object
+	{
+		const string BACKGROUND_SCHEMA = "org.gnome.desktop.background";
+		const uint FADE_ANIMATION_TIME = 1000;
+
+		public Meta.BackgroundEffects effects { get; construct set; }
+		public int monitor_index { get; construct set; }
+		public bool control_position { get; construct set; }
+
+		public Settings settings { get; construct set; }
+		public Meta.Screen screen { get; construct set; }
+
+		public Clutter.Actor container { get; construct set; }
+		public Background background { get; private set; }
+		Background? new_background = null;
+
+		public signal void changed ();
+
+		public BackgroundManager (Meta.Screen screen, Clutter.Actor container, int monitor_index,
+			Meta.BackgroundEffects effects, bool control_position, string settings_schema = BACKGROUND_SCHEMA)
+		{
+			Object (settings: new Settings (settings_schema), 
+				container: container,
+				effects: effects,
+				monitor_index: monitor_index,
+				screen: screen,
+				control_position: control_position);
+
+			background = create_background ();
+		}
+
+		public void destroy ()
+		{
+			if (new_background != null) {
+				new_background.actor.destroy();
+				new_background = null;
+			}
+
+			if (background != null) {
+				background.actor.destroy();
+				background = null;
+			}
+		}
+
+		public void update_background (Background background, int monitor_index) {
+			var new_background = create_background ();
+			new_background.vignette_sharpness = background.vignette_sharpness;
+			new_background.brightness = background.brightness;
+			new_background.actor.visible = background.actor.visible;
+
+			new_background.loaded_signal_id = new_background.loaded.connect (() => {
+				new_background.disconnect (new_background.loaded_signal_id);
+				new_background.loaded_signal_id = 0;
+				background.actor.animate(Clutter.AnimationMode.EASE_OUT_QUAD, FADE_ANIMATION_TIME,
+					opacity : 0).completed.connect (() => {
+						if (this.new_background == new_background) {
+							this.background = new_background;
+							this.new_background = null;
+						} else {
+							new_background.actor.destroy ();
+						}
+
+						background.actor.destroy ();
+
+						changed ();
+				});
+			});
+
+			this.new_background = new_background;
+		}
+
+		public Background create_background ()
+		{
+			var background = new Background (monitor_index, effects, settings);
+			container.add_child (background.actor);
+
+			var monitor = screen.get_monitor_geometry (monitor_index);
+			background.actor.set_size(monitor.width, monitor.height);
+			if (control_position) {
+				background.actor.set_position (monitor.x, monitor.y);
+				background.actor.lower_bottom ();
+			}
+
+			background.change_signal_id = background.changed.connect (() => {
+				background.disconnect (background.change_signal_id);
+				update_background (background, monitor_index);
+				background.change_signal_id = 0;
+			});
+
+			background.actor.destroy.connect (() => {
+				if (background.change_signal_id != 0)
+					background.disconnect (background.change_signal_id);
+
+				if (background.loaded_signal_id != 0)
+					background.disconnect (background.loaded_signal_id);
+			});
+
+			return background;
+		}
+	}
+}
+

=== added file 'src/Background/SystemBackground.vala'
--- src/Background/SystemBackground.vala	1970-01-01 00:00:00 +0000
+++ src/Background/SystemBackground.vala	2013-10-10 07:33:41 +0000
@@ -0,0 +1,39 @@
+//  
+//  Copyright (C) 2013 Tom Beckmann, Rico Tzschichholz
+// 
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+// 
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+// 
+
+namespace Gala
+{
+	public class SystemBackground : Object
+	{
+		public Meta.BackgroundActor actor { get; private set; }
+
+		public signal void loaded ();
+
+		public SystemBackground ()
+		{
+			actor = new Meta.BackgroundActor ();
+
+			BackgroundCache.get_default ().get_image_content (0, GDesktop.BackgroundStyle.WALLPAPER,
+				Config.PKGDATADIR + "/texture.png", Meta.BackgroundEffects.NONE, this, (userdata, content) => {
+				var self = userdata as SystemBackground;
+				self.actor.content = content;
+				self.loaded ();
+			});
+		}
+	}
+}
+

=== modified file 'src/Plugin.vala'
--- src/Plugin.vala	2013-09-28 22:17:35 +0000
+++ src/Plugin.vala	2013-10-10 07:33:41 +0000
@@ -51,8 +51,8 @@
 		ScreenSaver? screensaver;
 		
 #if HAS_MUTTER38
-		// FIXME we need a proper-sized background for every monitor
-		public BackgroundActor wallpaper { get; private set; }
+		public Meta.BackgroundGroup background_group { get; private set; }
+		public Clutter.Actor ui_group { get; private set; }
 #endif
 		
 		Window? moving; //place for the window that is being moved over
@@ -90,6 +90,7 @@
 			var screen = get_screen ();
 			
 			DBus.init (this);
+			BackgroundCache.init (screen);
 			
 			// Due to a bug which enables access to the stage when using multiple monitors
 			// in the screensaver, we have to listen for changes and make sure the input area
@@ -102,12 +103,44 @@
 			
 			var stage = Compositor.get_stage_for_screen (screen) as Clutter.Stage;
 			
-			string color = new Settings ("org.gnome.desktop.background").get_string ("primary-color");
+			var color = BackgroundSettings.get_default ().primary_color;
 			stage.background_color = Clutter.Color.from_string (color);
 			
 			if (Prefs.get_dynamic_workspaces ())
 				screen.override_workspace_layout (ScreenCorner.TOPLEFT, false, 1, -1);
 			
+#if HAS_MUTTER38
+			/* our layer structure, copied from gnome-shell (from bottom to top):
+			 * stage
+			 * + system background
+			 * + ui group
+			 * +-- window group
+			 * +---- background manager
+			 * +-- shell elements
+			 * +-- top window group
+		     */
+
+			var system_background = new SystemBackground ();
+			system_background.actor.add_constraint (new Clutter.BindConstraint (stage,
+				Clutter.BindCoordinate.ALL, 0));
+			stage.insert_child_below (system_background.actor, null);
+
+			ui_group = new Clutter.Actor ();
+			ui_group.reactive = true;
+			stage.add_child (ui_group);
+
+			var window_group = Compositor.get_window_group_for_screen (screen);
+			stage.remove_child (window_group);
+			ui_group.add_child (window_group);
+
+			background_group = new Meta.BackgroundGroup ();
+			window_group.add_child (background_group);
+			window_group.set_child_below_sibling (background_group, null);
+
+			setup_background_managers ();
+			screen.monitors_changed.connect (setup_background_managers);
+#endif
+
 			workspace_view = new WorkspaceView (this);
 			workspace_view.visible = false;
 			
@@ -116,13 +149,18 @@
 			zooming = new Zooming (this);
 			window_overview = new WindowOverview (this);
 			
+#if HAS_MUTTER38
+			ui_group.add_child (workspace_view);
+			ui_group.add_child (winswitcher);
+			ui_group.add_child (window_overview);
+
+			var top_window_group = Compositor.get_top_window_group_for_screen (screen);
+			stage.remove_child (top_window_group);
+			ui_group.add_child (top_window_group);
+#else
 			stage.add_child (workspace_view);
 			stage.add_child (winswitcher);
 			stage.add_child (window_overview);
-			
-#if HAS_MUTTER38
-			// FIXME create a background for every monitor and keep them updated and properly sized
-			wallpaper = new BackgroundActor ();
 #endif
 			
 			/*keybindings*/
@@ -189,8 +227,15 @@
 				workspace_view.show (true);
 			});
 			
+#if HAS_MUTTER38
+			//FIXME we have to investigate this. Apparently alt-tab is now bound to switch-applications
+			// instead of windows, which we should probably handle too
+			KeyBinding.set_custom_handler ("switch-applications", winswitcher.handle_switch_windows);
+			KeyBinding.set_custom_handler ("switch-applications-backward", winswitcher.handle_switch_windows);
+#else
 			KeyBinding.set_custom_handler ("switch-windows", winswitcher.handle_switch_windows);
 			KeyBinding.set_custom_handler ("switch-windows-backward", winswitcher.handle_switch_windows);
+#endif
 			
 			KeyBinding.set_custom_handler ("switch-to-workspace-up", () => {});
 			KeyBinding.set_custom_handler ("switch-to-workspace-down", () => {});
@@ -281,6 +326,17 @@
 			else
 				Utils.set_input_area (screen, InputArea.NONE);
 		}
+
+		void setup_background_managers ()
+		{
+			background_group.destroy_all_children ();
+
+			var screen = get_screen ();
+			for (var i = 0; i < screen.get_n_monitors (); i++) {
+				new BackgroundManager (screen, background_group, i,
+					Meta.BackgroundEffects.NONE, true);
+			}
+		}
 		
 		public uint32[] get_all_xids ()
 		{
@@ -346,6 +402,10 @@
 #else
 			base.begin_modal (x_get_stage_window (Compositor.get_stage_for_screen (screen)), {}, 0, display.get_current_time ());
 #endif
+
+#if HAS_MUTTER38
+			Meta.Util.disable_unredirect_for_screen (screen);
+#endif
 		}
 		
 		public new void end_modal ()
@@ -355,7 +415,12 @@
 				return;
 			
 			update_input_area ();
-			base.end_modal (get_screen ().get_display ().get_current_time ());
+			
+			var screen = get_screen ();
+			base.end_modal (screen.get_display ().get_current_time ());
+#if HAS_MUTTER38
+			Meta.Util.enable_unredirect_for_screen (screen);
+#endif
 		}
 		
 		public void get_current_cursor_position (out int x, out int y)
@@ -786,7 +851,7 @@
 		/*workspace switcher*/
 		List<WindowActor>? win;
 		List<Clutter.Actor>? par; //class space for kill func
-		List<Clutter.Clone>? clones;
+		List<Clutter.Actor>? clones;
 		Clutter.Actor? in_group;
 		Clutter.Actor? out_group;
 		Clutter.Actor? moving_window_container;
@@ -834,6 +899,8 @@
 			var group = Compositor.get_window_group_for_screen (screen);
 #if !HAS_MUTTER38
 			var wallpaper = Compositor.get_background_actor_for_screen (screen);
+#else
+			var wallpaper = background_group;
 #endif
 			
 			in_group  = new Clutter.Actor ();
@@ -985,6 +1052,8 @@
 			
 #if !HAS_MUTTER38
 			var wallpaper = Compositor.get_background_actor_for_screen (screen);
+#else
+			var wallpaper = background_group;
 #endif
 			wallpaper.detach_animation ();
 			wallpaper.x = 0.0f;
@@ -1003,6 +1072,15 @@
 		{
 			return x_handle_event (event) != 0;
 		}
+
+#if HAS_MUTTER38
+		public override bool keybinding_filter (Meta.KeyBinding binding)
+		{
+			// for now we'll just block all keybindings if we're in modal mode, 
+			// do something useful with this later
+			return modal_count > 0;
+		}
+#endif
 		
 		public override unowned PluginInfo? plugin_info ()
 		{

=== modified file 'src/Settings.vala'
--- src/Settings.vala	2013-02-10 14:01:15 +0000
+++ src/Settings.vala	2013-10-10 07:33:41 +0000
@@ -151,4 +151,29 @@
 			return instance;
 		}
 	}
+
+	public class BackgroundSettings : Granite.Services.Settings
+	{
+		public string picture_options { get; set; }
+		public string picture_uri { get; set; }
+		public int picture_opacity { get; set; }
+		public string primary_color { get; set; }
+		public string secondary_color { get; set; }
+		public string color_shading_type { get; set; }
+
+		static BackgroundSettings? instance = null;
+
+		private BackgroundSettings ()
+		{
+			base ("org.gnome.desktop.background");
+		}
+
+		public static BackgroundSettings get_default ()
+		{
+			if (instance == null)
+				instance = new BackgroundSettings ();
+
+			return instance;
+		}
+	}
 }

=== modified file 'src/Widgets/WindowOverview.vala'
--- src/Widgets/WindowOverview.vala	2013-09-28 22:17:35 +0000
+++ src/Widgets/WindowOverview.vala	2013-10-10 07:33:41 +0000
@@ -578,12 +578,10 @@
 
 			screen.window_left_monitor.connect (window_left_monitor);
 			
-#if HAS_MUTTER38
-			plugin.wallpaper.
-#else
+#if !HAS_MUTTER38
 			Compositor.get_background_actor_for_screen (screen).
-#endif
 				animate (AnimationMode.EASE_OUT_QUAD, 350, dim_factor : 0.6);
+#endif
 			
 			// sort windows by stacking order
 			var windows = screen.get_display ().sort_windows_by_stacking (used_windows);
@@ -722,12 +720,10 @@
 				exposed.selected.disconnect (thumb_selected);
 			}
 			
-#if HAS_MUTTER38
-			plugin.wallpaper.
-#else
+#if !HAS_MUTTER38
 			Compositor.get_background_actor_for_screen (screen).
-#endif
 				animate (AnimationMode.EASE_OUT_QUAD, 300, dim_factor : 1.0);
+#endif
 			
 			if (animate) {
 				Timeout.add (300, () => {

=== modified file 'src/Widgets/WindowSwitcher.vala'
--- src/Widgets/WindowSwitcher.vala	2013-08-18 21:09:23 +0000
+++ src/Widgets/WindowSwitcher.vala	2013-10-10 07:33:41 +0000
@@ -220,6 +220,9 @@
 			var prev_win = current_window;
 			if (action == Meta.KeyBindingAction.SWITCH_GROUP ||
 				action == Meta.KeyBindingAction.SWITCH_WINDOWS || 
+#if HAS_MUTTER38
+				action == Meta.KeyBindingAction.SWITCH_APPLICATIONS ||
+#endif
 				event.get_key_symbol () == Clutter.Key.Right) {
 				
 				current_window = display.get_tab_next (Meta.TabList.NORMAL, screen, 
@@ -228,6 +231,9 @@
 				
 			} else if (action == Meta.KeyBindingAction.SWITCH_GROUP_BACKWARD ||
 				action == Meta.KeyBindingAction.SWITCH_WINDOWS_BACKWARD ||
+#if HAS_MUTTER38
+				action == Meta.KeyBindingAction.SWITCH_APPLICATIONS_BACKWARD ||
+#endif
 				event.get_key_symbol () == Clutter.Key.Left) {
 				
 				current_window = display.get_tab_next (Meta.TabList.NORMAL, screen, 

=== modified file 'src/Widgets/WorkspaceThumb.vala'
--- src/Widgets/WorkspaceThumb.vala	2013-08-09 12:52:20 +0000
+++ src/Widgets/WorkspaceThumb.vala	2013-10-10 07:33:41 +0000
@@ -60,7 +60,11 @@
 		
 		uint hover_timer = 0;
 		
+#if HAS_MUTTER38
+		public WorkspaceThumb (Workspace _workspace, Meta.BackgroundGroup _wallpaper)
+#else
 		public WorkspaceThumb (Workspace _workspace)
+#endif
 		{
 			workspace = _workspace;
 			screen = workspace.get_screen ();
@@ -91,7 +95,8 @@
 			
 			// FIXME find a nice way to draw a border around it, maybe combinable with the indicator using a ShaderEffect
 #if HAS_MUTTER38
-			wallpaper = new Clutter.Actor ();
+			//FIXME we probably want to keep the BackgroundManager and not just save its actor
+			wallpaper = new BackgroundManager (screen, this, 0, Meta.BackgroundEffects.NONE, false).background.actor;
 #else
 			wallpaper = new Clone (Compositor.get_background_actor_for_screen (screen));
 #endif
@@ -121,7 +126,9 @@
 			windows.clip_to_allocation = true;
 			
 			add_child (indicator);
+#if !HAS_MUTTER38
 			add_child (wallpaper);
+#endif
 			add_child (windows);
 			add_child (icons);
 			add_child (close_button);
@@ -202,6 +209,10 @@
 			indicator.width = width + 2 * INDICATOR_BORDER;
 			(indicator.content as Canvas).set_size ((int)indicator.width, (int)indicator.height);
 
+#if HAS_MUTTER38
+			wallpaper.scale_x = width / swidth;
+			wallpaper.scale_y = THUMBNAIL_HEIGHT / sheight;
+#endif
 			wallpaper.width = width;
 			windows.width = width;
 

=== modified file 'src/Widgets/WorkspaceView.vala'
--- src/Widgets/WorkspaceView.vala	2013-08-03 11:15:11 +0000
+++ src/Widgets/WorkspaceView.vala	2013-10-10 07:33:41 +0000
@@ -29,7 +29,9 @@
 		
 		Clutter.Actor thumbnails;
 		Clutter.Actor scroll;
+#if !HAS_MUTTER38
 		Clutter.Actor click_catcher; //invisible plane that catches clicks outside the view
+#endif
 		
 		bool animating; // delay closing the popup
 		
@@ -67,13 +69,17 @@
 			scroll.content = new Clutter.Canvas ();
 			(scroll.content as Clutter.Canvas).draw.connect (draw_scroll);
 			
+#if HAS_MUTTER38
+			plugin.ui_group.button_release_event.connect (outside_clicked);
+#else
 			click_catcher = new Clutter.Actor ();
 			click_catcher.reactive = true;
 			click_catcher.button_release_event.connect ((e) => {
 				hide ();
 				return true;
 			});
-			Compositor.get_stage_for_screen (screen).add_child (click_catcher);
+			Compositor.get_stage_for_screen (screen).insert_child_below (click_catcher);
+#endif
 			
 			add_child (thumbnails);
 			add_child (scroll);
@@ -114,7 +120,7 @@
 		void init_thumbnails ()
 		{
 			foreach (var workspace in screen.get_workspaces ()) {
-				var thumb = new WorkspaceThumb (workspace);
+				var thumb = new WorkspaceThumb (workspace, plugin.background_group);
 				thumb.clicked.connect (hide);
 				thumb.closed.connect (remove_workspace);
 				thumb.window_on_last.connect (add_workspace);
@@ -128,6 +134,14 @@
 				&& Utils.get_n_windows (screen.get_workspaces ().first ().data) > 0)
 				add_workspace ();
 		}
+
+#if HAS_MUTTER38
+		bool outside_clicked (Clutter.ButtonEvent event)
+		{
+			hide ();
+			return true;
+		}
+#endif
 		
 		bool draw_background (Cairo.Context cr)
 		{
@@ -168,7 +182,7 @@
 		
 		void create_workspace_thumb (Meta.Workspace workspace)
 		{
-			var thumb = new WorkspaceThumb (workspace);
+			var thumb = new WorkspaceThumb (workspace, plugin.background_group);
 			thumb.clicked.connect (hide);
 			thumb.closed.connect (remove_workspace);
 			thumb.window_on_last.connect (add_workspace);
@@ -414,11 +428,13 @@
 			int swidth, sheight;
 			screen.get_size (out swidth, out sheight);
 			
+#if !HAS_MUTTER38
 			click_catcher.width = swidth;
 			click_catcher.height = sheight;
 			click_catcher.x = 0;
 			click_catcher.y = 0;
 			click_catcher.visible = true;
+#endif
 			
 			animating = true;
 			Timeout.add (50, () => {
@@ -431,13 +447,15 @@
 			wins.x = 0.0f;
 			
 			animate (Clutter.AnimationMode.EASE_OUT_QUAD, 250, y : (area.height + area.y) - height);
-			wins.animate (Clutter.AnimationMode.EASE_OUT_QUAD, 250, y : -height + 1);
+			wins.animate (Clutter.AnimationMode.EASE_OUT_QUAD, 250, y : -height + 1.01f);
 		}
 		
 		public new void hide ()
 		{
 			if (!visible || animating)
 				return;
+
+			plugin.ui_group.button_release_event.disconnect (outside_clicked);
 			
 			float width, height;
 			plugin.get_screen ().get_size (out width, out height);
@@ -454,7 +472,9 @@
 				visible = false;
 			});
 			
+#if !HAS_MUTTER38
 			click_catcher.visible = false;
+#endif
 			
 			var wins = Compositor.get_window_group_for_screen (screen);
 			wins.detach_animation ();

=== modified file 'vapi/gdesktopenums-3.0.vapi'
--- vapi/gdesktopenums-3.0.vapi	2012-08-19 13:56:07 +0000
+++ vapi/gdesktopenums-3.0.vapi	2013-10-10 07:33:41 +0000
@@ -34,6 +34,20 @@
 		SMART,
 		STRICT
 	}
+	[CCode (cheader_filename = "gsettings-desktop-schemas/gdesktop-enums.h", cprefix = "G_DESKTOP_MAGNIFIER_CARET_TRACKING_MODE_", has_type_id = false)]
+	public enum MagnifierCaretTrackingMode {
+		NONE,
+		CENTERED,
+		PROPORTIONAL,
+		PUSH
+	}
+	[CCode (cheader_filename = "gsettings-desktop-schemas/gdesktop-enums.h", cprefix = "G_DESKTOP_MAGNIFIER_FOCUS_TRACKING_MODE_", has_type_id = false)]
+	public enum MagnifierFocusTrackingMode {
+		NONE,
+		CENTERED,
+		PROPORTIONAL,
+		PUSH
+	}
 	[CCode (cheader_filename = "gsettings-desktop-schemas/gdesktop-enums.h", cprefix = "G_DESKTOP_MAGNIFIER_MOUSE_TRACKING_MODE_", has_type_id = false)]
 	public enum MagnifierMouseTrackingMode {
 		NONE,

=== added file 'vapi/gnome-desktop-3.0.deps'
--- vapi/gnome-desktop-3.0.deps	1970-01-01 00:00:00 +0000
+++ vapi/gnome-desktop-3.0.deps	2013-10-10 07:33:41 +0000
@@ -0,0 +1,7 @@
+atk
+cairo
+gio-2.0
+gdesktopenums-3.0
+gdk-pixbuf-2.0
+gdk-3.0
+gtk+-3.0

=== added file 'vapi/gnome-desktop-3.0.vapi'
--- vapi/gnome-desktop-3.0.vapi	1970-01-01 00:00:00 +0000
+++ vapi/gnome-desktop-3.0.vapi	2013-10-10 07:33:41 +0000
@@ -0,0 +1,310 @@
+/* gnome-desktop-3.0.vapi generated by vapigen, do not modify. */
+
+[CCode (cprefix = "Gnome", gir_namespace = "GnomeDesktop", gir_version = "3.0", lower_case_cprefix = "gnome_")]
+namespace Gnome {
+	namespace DesktopThumbnail {
+		[CCode (cheader_filename = "libgnome-desktop/gnome-desktop-thumbnail.h")]
+		public static bool has_uri (Gdk.Pixbuf pixbuf, string uri);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-desktop-thumbnail.h")]
+		public static bool is_valid (Gdk.Pixbuf pixbuf, string uri, long mtime);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-desktop-thumbnail.h")]
+		[Deprecated (since = "2.22")]
+		public static string md5 (string uri);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-desktop-thumbnail.h")]
+		public static string path_for_uri (string uri, Gnome.DesktopThumbnailSize size);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-desktop-thumbnail.h")]
+		public static Gdk.Pixbuf scale_down_pixbuf (Gdk.Pixbuf pixbuf, int dest_width, int dest_height);
+	}
+	namespace Languages {
+		[CCode (array_length = false, array_null_terminated = true, cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_get_all_languages")]
+		public static string[] get_all_languages ();
+		[CCode (array_length = false, array_null_terminated = true, cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_get_all_locales")]
+		public static string[] get_all_locales ();
+		[CCode (cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_get_country_from_code")]
+		public static string get_country_from_code (string code, string? translation);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_get_country_from_locale")]
+		public static string get_country_from_locale (string locale, string? translation);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_get_input_source_from_locale")]
+		public static bool get_input_source_from_locale (string locale, out unowned string type, out unowned string id);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_get_language_from_code")]
+		public static string get_language_from_code (string code, string? translation);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_get_language_from_locale")]
+		public static string get_language_from_locale (string locale, string? translation);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_language_has_translations")]
+		public static bool language_has_translations (string code);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_normalize_locale")]
+		public static string normalize_locale (string locale);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_parse_locale")]
+		public static bool parse_locale (string locale, out string language_codep, out string country_codep, out string codesetp, out string modifierp);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-bg.h", type_id = "gnome_bg_get_type ()")]
+	public class BG : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public BG ();
+		public bool changes_with_time ();
+		public Gdk.Pixbuf create_frame_thumbnail (Gnome.DesktopThumbnailFactory factory, Gdk.Screen screen, int dest_width, int dest_height, int frame_num);
+		public Cairo.Surface create_surface (Gdk.Window window, int width, int height, bool root);
+		public Gdk.Pixbuf create_thumbnail (Gnome.DesktopThumbnailFactory factory, Gdk.Screen screen, int dest_width, int dest_height);
+		public void draw (Gdk.Pixbuf dest, Gdk.Screen screen, bool is_root);
+		public void get_color (GDesktop.BackgroundShading type, Gdk.Color primary, Gdk.Color secondary);
+		public bool get_draw_background ();
+		public unowned string get_filename ();
+		public bool get_image_size (Gnome.DesktopThumbnailFactory factory, int best_width, int best_height, int width, int height);
+		public GDesktop.BackgroundStyle get_placement ();
+		public static Cairo.Surface get_surface_from_root (Gdk.Screen screen);
+		public bool has_multiple_sizes ();
+		public bool is_dark (int dest_width, int dest_height);
+		public void load_from_preferences (GLib.Settings settings);
+		public void save_to_preferences (GLib.Settings settings);
+		public void set_color (GDesktop.BackgroundShading type, Gdk.Color primary, Gdk.Color secondary);
+		public void set_draw_background (bool draw_background);
+		public void set_filename (string filename);
+		public void set_placement (GDesktop.BackgroundStyle placement);
+		public static void set_surface_as_root (Gdk.Screen screen, Cairo.Surface surface);
+		public static Gnome.BGCrossfade set_surface_as_root_with_crossfade (Gdk.Screen screen, Cairo.Surface surface);
+		public signal void changed ();
+		public signal void transitioned ();
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-bg-crossfade.h", type_id = "gnome_bg_crossfade_get_type ()")]
+	public class BGCrossfade : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public BGCrossfade (int width, int height);
+		public bool is_started ();
+		public bool set_end_surface (Cairo.Surface surface);
+		public bool set_start_surface (Cairo.Surface surface);
+		public void start (Gdk.Window window);
+		public void stop ();
+		[NoAccessorMethod]
+		public int height { get; construct; }
+		[NoAccessorMethod]
+		public int width { get; construct; }
+		public virtual signal void finished (GLib.Object window);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-bg-slide-show.h", type_id = "gnome_bg_slide_show_get_type ()")]
+	public class BGSlideShow : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public BGSlideShow (string filename);
+		public void get_current_slide (int width, int height, out double progress, out double duration, out bool is_fixed, out unowned string file1, out unowned string file2);
+		public bool get_has_multiple_sizes ();
+		public int get_num_slides ();
+		public bool get_slide (int frame_number, int width, int height, double progress, out double duration, out bool is_fixed, out unowned string file1, out unowned string file2);
+		public double get_start_time ();
+		public double get_total_duration ();
+		public bool load () throws GLib.Error;
+		public void load_async (GLib.Cancellable? cancellable, GLib.AsyncReadyCallback callback);
+		[NoAccessorMethod]
+		public string filename { owned get; construct; }
+		public bool has_multiple_sizes { get; }
+		public double start_time { get; }
+		public double total_duration { get; }
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-desktop-thumbnail.h", type_id = "gnome_desktop_thumbnail_factory_get_type ()")]
+	public class DesktopThumbnailFactory : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public DesktopThumbnailFactory (Gnome.DesktopThumbnailSize size);
+		public bool can_thumbnail (string uri, string mime_type, long mtime);
+		public void create_failed_thumbnail (string uri, long mtime);
+		public Gdk.Pixbuf generate_thumbnail (string uri, string mime_type);
+		public bool has_valid_failed_thumbnail (string uri, long mtime);
+		public string lookup (string uri, long mtime);
+		public void save_thumbnail (Gdk.Pixbuf thumbnail, string uri, long original_mtime);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-idle-monitor.h", type_id = "gnome_idle_monitor_get_type ()")]
+	public class IdleMonitor : GLib.Object, GLib.Initable {
+		[CCode (has_construct_function = false)]
+		public IdleMonitor ();
+		public uint add_idle_watch (uint64 interval_msec, owned Gnome.IdleMonitorWatchFunc? callback);
+		public uint add_user_active_watch (owned Gnome.IdleMonitorWatchFunc? callback);
+		[CCode (has_construct_function = false)]
+		public IdleMonitor.for_device (Gdk.Device device) throws GLib.Error;
+		public uint64 get_idletime ();
+		public void remove_watch (uint id);
+		[NoAccessorMethod]
+		public Gdk.Device device { owned get; construct; }
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-pnp-ids.h", type_id = "gnome_pnp_ids_get_type ()")]
+	public class PnpIds : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public PnpIds ();
+		public string get_pnp_id (string pnp_id);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr-config.h", type_id = "gnome_rr_config_get_type ()")]
+	public class RRConfig : GLib.Object {
+		[CCode (has_construct_function = false)]
+		protected RRConfig ();
+		public bool applicable (Gnome.RRScreen screen) throws GLib.Error;
+		public bool apply (Gnome.RRScreen screen) throws GLib.Error;
+		public bool apply_persistent (Gnome.RRScreen screen) throws GLib.Error;
+		[CCode (has_construct_function = false)]
+		public RRConfig.current (Gnome.RRScreen screen) throws GLib.Error;
+		public bool ensure_primary ();
+		public bool equal (Gnome.RRConfig config2);
+		public bool get_clone ();
+		[CCode (array_length = false, array_null_terminated = true)]
+		public unowned Gnome.RROutputInfo[] get_outputs ();
+		public bool load_current () throws GLib.Error;
+		public bool match (Gnome.RRConfig config2);
+		public void sanitize ();
+		public void set_clone (bool clone);
+		public Gnome.RRScreen screen { construct; }
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "gnome_rr_crtc_get_type ()")]
+	[Compact]
+	public class RRCrtc {
+		public bool can_drive_output (Gnome.RROutput output);
+		public Gnome.RRMode get_current_mode ();
+		public Gnome.RRRotation get_current_rotation ();
+		public bool get_gamma (int size, ushort red, ushort green, ushort blue);
+		public uint32 get_id ();
+		public void get_position (out int x, out int y);
+		public Gnome.RRRotation get_rotations ();
+		public bool set_gamma (int size, ushort red, ushort green, ushort blue);
+		public bool supports_rotation (Gnome.RRRotation rotation);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "gnome_rr_mode_get_type ()")]
+	[Compact]
+	public class RRMode {
+		public int get_freq ();
+		public uint get_height ();
+		public uint32 get_id ();
+		public uint get_width ();
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "gnome_rr_output_get_type ()")]
+	[Compact]
+	public class RROutput {
+		public bool can_clone (Gnome.RROutput clone);
+		public int get_backlight ();
+		public Gnome.RRCrtc get_crtc ();
+		public Gnome.RRMode get_current_mode ();
+		public unowned string get_display_name ();
+		public uint8 get_edid_data (size_t size);
+		public uint32 get_id ();
+		public void get_ids_from_edid (out string vendor, out string product, out string serial);
+		public bool get_is_primary ();
+		public unowned string get_name ();
+		public void get_physical_size (out int width_mm, out int height_mm);
+		public void get_position (out int x, out int y);
+		public Gnome.RRCrtc get_possible_crtcs ();
+		public Gnome.RRMode get_preferred_mode ();
+		public bool is_builtin_display ();
+		public Gnome.RRMode list_modes ();
+		public bool set_backlight (int value) throws GLib.Error;
+		public bool supports_mode (Gnome.RRMode mode);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr-config.h", type_id = "gnome_rr_output_info_get_type ()")]
+	public class RROutputInfo : GLib.Object {
+		[CCode (has_construct_function = false)]
+		protected RROutputInfo ();
+		public double get_aspect_ratio ();
+		public unowned string get_display_name ();
+		public void get_geometry (out int x, out int y, out int width, out int height);
+		public unowned string get_name ();
+		public int get_preferred_height ();
+		public int get_preferred_width ();
+		public bool get_primary ();
+		public unowned string get_product ();
+		public int get_refresh_rate ();
+		public Gnome.RRRotation get_rotation ();
+		public unowned string get_serial ();
+		public unowned string get_vendor ();
+		public bool is_active ();
+		public bool is_connected ();
+		public void set_active (bool active);
+		public void set_geometry (int x, int y, int width, int height);
+		public void set_primary (bool primary);
+		public void set_refresh_rate (int rate);
+		public void set_rotation (Gnome.RRRotation rotation);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr.h", type_id = "gnome_rr_screen_get_type ()")]
+	public class RRScreen : GLib.Object, GLib.AsyncInitable, GLib.Initable {
+		[CCode (has_construct_function = false)]
+		public RRScreen (Gdk.Screen screen) throws GLib.Error;
+		public Gnome.RRMode create_clone_modes ();
+		[CCode (cname = "gnome_rr_screen_new_async", has_construct_function = false)]
+		public async RRScreen.from_async (Gdk.Screen screen) throws GLib.Error;
+		public unowned Gnome.RRCrtc get_crtc_by_id (uint32 id);
+		public bool get_dpms_mode (out Gnome.RRDpmsMode mode) throws GLib.Error;
+		public unowned Gnome.RROutput get_output_by_id (uint32 id);
+		public unowned Gnome.RROutput get_output_by_name (string name);
+		public void get_ranges (out int min_width, out int max_width, out int min_height, out int max_height);
+		[CCode (array_length = false, array_null_terminated = true)]
+		public unowned Gnome.RRMode[] list_clone_modes ();
+		[CCode (array_length = false, array_null_terminated = true)]
+		public unowned Gnome.RRCrtc[] list_crtcs ();
+		[CCode (array_length = false, array_null_terminated = true)]
+		public unowned Gnome.RRMode[] list_modes ();
+		[CCode (array_length = false, array_null_terminated = true)]
+		public unowned Gnome.RROutput[] list_outputs ();
+		public bool refresh () throws GLib.Error;
+		public bool set_dpms_mode (Gnome.RRDpmsMode mode) throws GLib.Error;
+		[NoAccessorMethod]
+		public Gdk.Screen gdk_screen { owned get; construct; }
+		public virtual signal void changed ();
+		public virtual signal void output_connected (void* output);
+		public virtual signal void output_disconnected (void* output);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-wall-clock.h", type_id = "gnome_wall_clock_get_type ()")]
+	public class WallClock : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public WallClock ();
+		public unowned string get_clock ();
+		public unowned GLib.TimeZone get_timezone ();
+		public string clock { get; }
+		[NoAccessorMethod]
+		public bool time_only { get; set; }
+		public GLib.TimeZone timezone { get; }
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-xkb-info.h", type_id = "gnome_xkb_info_get_type ()")]
+	public class XkbInfo : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public XkbInfo ();
+		public unowned string description_for_group (string group_id);
+		public unowned string description_for_option (string group_id, string id);
+		public GLib.List<weak string> get_all_layouts ();
+		public GLib.List<weak string> get_all_option_groups ();
+		public bool get_layout_info (string id, out unowned string display_name, out unowned string short_name, out unowned string xkb_layout, out unowned string xkb_variant);
+		public GLib.List<weak string> get_layouts_for_country (string country_code);
+		public GLib.List<weak string> get_layouts_for_language (string language_code);
+		public GLib.List<weak string> get_options_for_group (string group_id);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-desktop-thumbnail.h", cprefix = "GNOME_DESKTOP_THUMBNAIL_SIZE_", has_type_id = false)]
+	public enum DesktopThumbnailSize {
+		NORMAL,
+		LARGE
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr.h", cprefix = "GNOME_RR_DPMS_", has_type_id = false)]
+	public enum RRDpmsMode {
+		ON,
+		STANDBY,
+		SUSPEND,
+		OFF,
+		DISABLED,
+		UNKNOWN
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr.h", cprefix = "GNOME_RR_", has_type_id = false)]
+	[Flags]
+	public enum RRRotation {
+		ROTATION_NEXT,
+		ROTATION_0,
+		ROTATION_90,
+		ROTATION_180,
+		ROTATION_270,
+		REFLECT_X,
+		REFLECT_Y
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr.h", cprefix = "GNOME_RR_ERROR_")]
+	public errordomain RRError {
+		UNKNOWN,
+		NO_RANDR_EXTENSION,
+		RANDR_ERROR,
+		BOUNDS_ERROR,
+		CRTC_ASSIGNMENT,
+		NO_MATCHING_CONFIG,
+		NO_DPMS_EXTENSION;
+		public static GLib.Quark quark ();
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-idle-monitor.h", instance_pos = 2.9)]
+	public delegate void IdleMonitorWatchFunc (Gnome.IdleMonitor monitor, uint id);
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr.h", cname = "GNOME_RR_CONNECTOR_TYPE_PANEL")]
+	public const string RR_CONNECTOR_TYPE_PANEL;
+}

