=== modified file 'CMakeLists.txt'
--- CMakeLists.txt	2013-11-16 16:18:45 +0000
+++ CMakeLists.txt	2013-11-28 10:12:02 +0000
@@ -31,10 +31,10 @@
 list (APPEND CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake)
 
 configure_file (${CMAKE_SOURCE_DIR}/src/Config.vala.cmake ${CMAKE_BINARY_DIR}/src/Config.vala)
-add_definitions(-DGETTEXT_PACKAGE=\"${GETTEXT_PACKAGE}\")
+add_definitions(-DGETTEXT_PACKAGE=\"${GETTEXT_PACKAGE}\" -DGNOME_DESKTOP_USE_UNSTABLE_API -w)
 
 find_package(PkgConfig)
-pkg_check_modules(DEPS REQUIRED libmutter>=3.4 granite clutter-1.0>=1.9.16 clutter-gtk-1.0 libbamf3 xfixes gee-1.0 plank)
+pkg_check_modules(DEPS REQUIRED libmutter>=3.4 granite clutter-1.0>=1.9.16 clutter-gtk-1.0 libbamf3 xfixes gee-1.0 plank gnome-desktop-3.0)
 
 set (MUTTER36_FLAGS "")
 pkg_check_modules(MUTTER36 QUIET libmutter>=3.5)
@@ -84,6 +84,11 @@
     src/TextShadowEffect.vala
     src/Utils.vala
     src/Zooming.vala
+    src/Background/Background.vala
+    src/Background/BackgroundCache.vala
+    src/Background/BackgroundManager.vala
+    src/Background/SlideShow.vala
+    src/Background/SystemBackground.vala
     src/Widgets/AppIcon.vala
     src/Widgets/WindowOverview.vala
     src/Widgets/WindowSwitcher.vala
@@ -99,6 +104,7 @@
     clutter-gtk-1.0
     gdk-x11-3.0
     gdesktopenums-3.0
+    gnome-desktop-3.0
     xfixes-4.0
 OPTIONS
     -g

=== modified file 'data/texture.png'
Binary files data/texture.png	2013-02-17 00:38:16 +0000 and data/texture.png	2013-11-28 10:12:02 +0000 differ
=== added directory 'src/Background'
=== added file 'src/Background/Background.vala'
--- src/Background/Background.vala	1970-01-01 00:00:00 +0000
+++ src/Background/Background.vala	2013-11-28 10:12:02 +0000
@@ -0,0 +1,194 @@
+//  
+//  Copyright (C) 2013 Tom Beckmann, Rico Tzschichholz
+// 
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+// 
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+// 
+
+namespace Gala
+{
+#if HAS_MUTTER38
+	/**
+	 * Group that holds a pattern at the very bottom and then an image showing the
+	 * current wallpaper above (and one more additional image for transitions).
+	 * It listens to changes on the provided settings object and updates accordingly.
+	 */
+	public class Background : Meta.BackgroundGroup
+	{
+		const uint ANIMATION_TRANSITION_DURATION = 1500;
+
+		public Meta.Screen screen { get; construct; }
+		public int monitor { get; construct; }
+		public Settings settings { get; construct; }
+
+		Meta.BackgroundActor pattern;
+		Clutter.Actor? image = null;
+
+		public Background (Meta.Screen screen, int monitor, Settings settings)
+		{
+			Object (screen: screen, monitor: monitor, settings: settings);
+		}
+		
+		construct
+		{
+			pattern = new Meta.BackgroundActor ();
+			pattern.add_constraint (new Clutter.BindConstraint (this, Clutter.BindCoordinate.SIZE, 0));
+			add_child (pattern);
+
+			load (null);
+
+			settings.changed.connect (load);
+		}
+
+		~Background ()
+		{
+			settings.changed.disconnect (load);
+		}
+
+		/**
+		 * (Re)loads all components if key_changed is null or only the key_changed component
+		 */
+		void load (string? key_changed)
+		{
+			var all = key_changed == null;
+			var cache = BackgroundCache.get_default ();
+
+			// update images
+			if (all || key_changed == "picture-uri" || key_changed == "picture-options") {
+				var style = style_string_to_enum (settings.get_string ("picture-options"));
+				var uri = settings.get_string ("picture-uri");
+
+				string filename;
+				if (GLib.Uri.parse_scheme (uri) != null)
+					filename = File.new_for_uri (uri).get_path ();
+				else
+					filename = uri;
+
+				// no image at all or malformed picture-uri
+				if (filename == null || filename == "" || style == GDesktop.BackgroundStyle.NONE) {
+					set_current (null);
+				// animation
+				} else if (filename.has_suffix (".xml")) {
+					var slides = new SlideShow (filename, screen, 0, style);
+
+					slides.load.begin ((obj, res) => {
+						if (!slides.load.end (res))
+							set_current (null);
+						else
+							set_current (slides);
+					});
+				// normal wallpaper
+				} else {
+					cache.load_image.begin (filename, monitor, style, (obj, res) => {
+						var content = cache.load_image.end (res);
+						if (content == null) {
+							set_current (null);
+							return;
+						}
+
+						var new_image = new Meta.BackgroundActor ();
+						new_image.content = content;
+						set_current (new_image);
+					});
+				}
+			}
+
+			// update image opacity
+			if (all || key_changed == "picture-opacity") {
+				if (image != null)
+					image.opacity = (uint8)(settings.get_int ("picture-opacity") / 100.0 * 255);
+			}
+
+			// update pattern
+			if (all
+				|| key_changed == "primary-color"
+				|| key_changed == "secondary-color"
+				|| key_changed == "color-shading-type") {
+				var primary_color = Clutter.Color.from_string (settings.get_string ("primary-color"));
+				var secondary_color = Clutter.Color.from_string (settings.get_string ("secondary-color"));
+				var shading_type = shading_string_to_enum (settings.get_string ("color-shading-type"));
+				pattern.content = cache.load_pattern (monitor, primary_color, secondary_color, shading_type);
+			}
+		}
+
+		/**
+		 * Fade a new image over the old, then destroy the old one and replace it with the new one
+		 * if new_image is null, fade out and destroy the current image to show the pattern
+		 */
+		void set_current (Clutter.Actor? new_image)
+		{
+			if (new_image == null) {
+				if (image != null)
+					image.animate (Clutter.AnimationMode.EASE_OUT_QUAD, ANIMATION_TRANSITION_DURATION,
+						opacity: 0).completed.connect (() => {
+						image.destroy ();
+					});
+				return;
+			}
+
+			new_image.opacity = 0;
+			new_image.add_constraint (new Clutter.BindConstraint (this, Clutter.BindCoordinate.SIZE, 0));
+			insert_child_above (new_image, null);
+
+			var dest_opacity = (uint8)(settings.get_int ("picture-opacity") / 100.0 * 255);
+			new_image.animate (Clutter.AnimationMode.EASE_OUT_QUAD, ANIMATION_TRANSITION_DURATION,
+				opacity: dest_opacity).completed.connect (() => {
+				if (image != null)
+					image.destroy ();
+				image = new_image;
+			});
+		}
+
+		/**
+		 *  translates the string returned from gsettings for the color-shading-type key to the
+		 *  appropriate GDesktop.BackgroundShading enum value
+		 */
+		static GDesktop.BackgroundShading shading_string_to_enum (string shading)
+		{
+			switch (shading) {
+				case "horizontal":
+					return GDesktop.BackgroundShading.HORIZONTAL;
+				case "vertical":
+					return GDesktop.BackgroundShading.VERTICAL;
+			}
+
+			return GDesktop.BackgroundShading.SOLID;
+		}
+
+		/**
+		 *  translates the string returned from gsettings for the picture-options key to the
+		 *  appropriate GDesktop.BackgroundStyle enum value
+		 */
+		static GDesktop.BackgroundStyle style_string_to_enum (string style)
+		{
+			switch (style) {
+				case "wallpaper":
+					return GDesktop.BackgroundStyle.WALLPAPER;
+				case "centered":
+					return GDesktop.BackgroundStyle.CENTERED;
+				case "scaled":
+					return GDesktop.BackgroundStyle.SCALED;
+				case "stretched":
+					return GDesktop.BackgroundStyle.STRETCHED;
+				case "zoom":
+					return GDesktop.BackgroundStyle.ZOOM;
+				case "spanned":
+					return GDesktop.BackgroundStyle.SPANNED;
+			}
+
+			return GDesktop.BackgroundStyle.NONE;
+		}
+	}
+#endif
+}
+

=== added file 'src/Background/BackgroundCache.vala'
--- src/Background/BackgroundCache.vala	1970-01-01 00:00:00 +0000
+++ src/Background/BackgroundCache.vala	2013-11-28 10:12:02 +0000
@@ -0,0 +1,119 @@
+//  
+//  Copyright (C) 2013 Tom Beckmann, Rico Tzschichholz
+// 
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+// 
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+// 
+
+namespace Gala
+{
+#if HAS_MUTTER38
+	public class BackgroundCache : Object
+	{
+		struct WaitingCallback
+		{
+			SourceFunc func;
+			string hash;
+		}
+
+		static BackgroundCache? instance = null;
+
+		public static void init (Meta.Screen screen)
+		{
+			instance = new BackgroundCache (screen);
+		}
+
+		public static BackgroundCache get_default ()
+			requires (instance != null)
+		{
+			return instance;
+		}
+		
+		public Meta.Screen screen { get; construct; }
+
+		Gee.HashMap<string,Meta.Background> image_cache;
+		Gee.HashMap<string,Meta.Background> pattern_cache;
+		Gee.LinkedList<WaitingCallback?> waiting_callbacks;
+
+		BackgroundCache (Meta.Screen screen)
+		{
+			Object (screen: screen);
+		}
+		
+		construct
+		{
+			image_cache = new Gee.HashMap<string,Meta.Background> ();
+			pattern_cache = new Gee.HashMap<string,Meta.Background> ();
+			waiting_callbacks = new Gee.LinkedList<WaitingCallback?> ();
+		}
+
+		public async Meta.Background? load_image (string file, int monitor,
+			GDesktop.BackgroundStyle style)
+		{
+			string hash = "%s#%i".printf (file, style);
+			Meta.Background? content = image_cache.get (hash);
+
+			if (content != null) {
+				// the content has been created, but the file is still loading, so we wait
+				if (content.get_filename () == null) {
+					waiting_callbacks.add ({ load_image.callback, hash });
+					yield;
+				}
+
+				return content.copy (monitor, Meta.BackgroundEffects.NONE);
+			}
+
+			content = new Meta.Background (screen, monitor, Meta.BackgroundEffects.NONE);
+
+			image_cache.set (hash, content);
+
+			try {
+				yield content.load_file_async (file, style, null);
+			} catch (Error e) {
+				warning (e.message);
+				return null;
+			}
+
+			foreach (var callback in waiting_callbacks) {
+				if (callback.hash == hash) {
+					callback.func ();
+					waiting_callbacks.remove (callback);
+				}
+			}
+
+			return content;
+		}
+
+		public Meta.Background load_pattern (int monitor, Clutter.Color primary, Clutter.Color secondary,
+			GDesktop.BackgroundShading shading_type)
+		{
+			string hash = "%s#%s#%i".printf (primary.to_string (), secondary.to_string (), shading_type);
+			Meta.Background? content = pattern_cache.get (hash);
+
+			if (content != null)
+				return content.copy (monitor, Meta.BackgroundEffects.NONE);
+
+			content = new Meta.Background (screen, monitor, Meta.BackgroundEffects.NONE);
+			if (shading_type == GDesktop.BackgroundShading.SOLID)
+				content.load_color (primary);
+			else
+				content.load_gradient (shading_type, primary, secondary);
+
+			pattern_cache.set (hash, content);
+
+			return content;
+		}
+	}
+#endif
+}
+

=== added file 'src/Background/BackgroundManager.vala'
--- src/Background/BackgroundManager.vala	1970-01-01 00:00:00 +0000
+++ src/Background/BackgroundManager.vala	2013-11-28 10:12:02 +0000
@@ -0,0 +1,61 @@
+//  
+//  Copyright (C) 2013 Tom Beckmann, Rico Tzschichholz
+// 
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+// 
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+// 
+
+namespace Gala
+{
+#if HAS_MUTTER38
+	public class BackgroundManager : Meta.BackgroundGroup
+	{
+		public Meta.Screen screen { get; construct; }
+
+		public BackgroundManager (Meta.Screen screen)
+		{
+			Object (screen: screen);
+		}
+		
+		construct
+		{
+			screen.monitors_changed.connect (update);
+
+			update ();
+		}
+
+		~BackgroundManager ()
+		{
+			screen.monitors_changed.disconnect (update);
+		}
+
+		void update ()
+		{
+			remove_all_children ();
+
+			var settings = BackgroundSettings.get_default ().schema;
+
+			for (var i = 0; i < screen.get_n_monitors (); i++) {
+				var geom = screen.get_monitor_geometry (i);
+				var background = new Background (screen, i, settings);
+
+				background.set_position (geom.x, geom.y);
+				background.set_size (geom.width, geom.height);
+
+				add_child (background);
+			}
+		}
+	}
+#endif
+}
+

=== added file 'src/Background/SlideShow.vala'
--- src/Background/SlideShow.vala	1970-01-01 00:00:00 +0000
+++ src/Background/SlideShow.vala	2013-11-28 10:12:02 +0000
@@ -0,0 +1,163 @@
+//  
+//  Copyright (C) 2013 Tom Beckmann, Rico Tzschichholz
+// 
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+// 
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+// 
+
+namespace Gala
+{
+#if HAS_MUTTER38
+	public class SlideShow : Meta.BackgroundGroup
+	{
+		const double ANIMATION_OPACITY_STEP_INCREMENT = 4.0;
+		const double ANIMATION_MIN_WAKEUP_INTERVAL = 1.0;
+
+		public string file { get; construct set; }
+		public Meta.Screen screen { get; construct set; }
+		public int monitor { get; construct set; }
+		public GDesktop.BackgroundStyle style { get; construct set; }
+
+		Gnome.BGSlideShow? animation = null;
+
+		double animation_duration = 0.0;
+		double animation_progress = 0.0;
+
+		uint update_animation_timeout_id;
+
+		Meta.BackgroundActor image_from;
+		Meta.BackgroundActor image_to;
+
+		public SlideShow (string file, Meta.Screen screen, int monitor, GDesktop.BackgroundStyle style)
+		{
+			Object (file: file, screen: screen, monitor: monitor, style: style);
+		}
+
+		construct
+		{
+			var geom = screen.get_monitor_geometry (monitor);
+			width = geom.width;
+			height = geom.height;
+
+			image_to = new Meta.BackgroundActor ();
+			image_from = new Meta.BackgroundActor ();
+
+			add_child (image_from);
+			add_child (image_to);
+		}
+
+		~SlideShow ()
+		{
+			if (update_animation_timeout_id > 0)
+				Source.remove (update_animation_timeout_id);
+		}
+
+		public async bool load ()
+		{
+			animation = new Gnome.BGSlideShow (file);
+			try {
+				animation.load_async (null, (obj, res) => {
+					load.callback ();
+				});
+				yield;
+
+				yield update_animation ();
+
+				return true;
+			} catch (Error e) {
+				warning (e.message);
+			}
+			
+			return false;
+		}
+
+		/**
+		 * SlideShow animation related functions
+		 */
+		async void update_animation ()
+		{
+			if (animation == null)
+				return;
+
+			update_animation_timeout_id = 0;
+
+			bool is_fixed;
+			string file_from, file_to;
+			double progress, duration;
+			animation.get_current_slide ((int)width, (int)height, out progress,
+				out duration, out is_fixed, out file_from, out file_to);
+
+			animation_duration = duration;
+			animation_progress = progress;
+
+			if (file_from == null && file_to == null) {
+				queue_update_animation ();
+				return;
+			}
+
+			if (image_from.content == null
+				|| (image_from.content as Meta.Background).get_filename () != file_from) {
+				yield update_image (image_from, file_from);
+			}
+			if (image_to.content == null
+				|| (image_to.content as Meta.Background).get_filename () != file_to) {
+				yield update_image (image_to, file_to);
+			}
+
+			update_animation_progress ();
+		}
+
+		/**
+		 * Returns the passed orig_image with the correct content or a new one if orig_image was null
+		 */
+		async void update_image (Meta.BackgroundActor image, string? file)
+		{
+			if (file == null) {
+				image.visible = false;
+				return;
+			}
+
+			image.visible = true;
+			image.content = yield BackgroundCache.get_default ().load_image (file, monitor, style);
+		}
+
+		void queue_update_animation ()
+		{
+			if (update_animation_timeout_id != 0 || animation_duration == 0.0)
+				return;
+
+			var n_steps = 255 / ANIMATION_OPACITY_STEP_INCREMENT;
+			var time_per_step = (uint)((animation_duration * 1000) / n_steps);
+			var interval = uint.max ((uint)(ANIMATION_MIN_WAKEUP_INTERVAL * 1000), time_per_step);
+
+			if (interval > uint.MAX)
+				return;
+
+			update_animation_timeout_id = Clutter.Threads.Timeout.add (interval, () => {
+				update_animation_timeout_id = 0;
+				update_animation.begin ();
+				return false;
+			});
+		}
+
+		void update_animation_progress ()
+		{
+			if (image_to != null)
+				image_to.opacity = (uint)(animation_progress * 255);
+
+			queue_update_animation ();
+		}
+	}
+#endif
+}
+

=== added file 'src/Background/SystemBackground.vala'
--- src/Background/SystemBackground.vala	1970-01-01 00:00:00 +0000
+++ src/Background/SystemBackground.vala	2013-11-28 10:12:02 +0000
@@ -0,0 +1,39 @@
+//  
+//  Copyright (C) 2013 Tom Beckmann, Rico Tzschichholz
+// 
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+// 
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+// 
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+// 
+
+namespace Gala
+{
+#if HAS_MUTTER38
+	public class SystemBackground : Meta.BackgroundActor
+	{
+		public SystemBackground ()
+		{
+			Object ();
+		}
+		
+		construct
+		{
+			var cache = BackgroundCache.get_default ();
+			cache.load_image.begin (Config.PKGDATADIR + "/texture.png", 0,
+				GDesktop.BackgroundStyle.WALLPAPER, (obj, res) => {
+				content = cache.load_image.end (res);
+			});
+		}
+	}
+#endif
+}
+

=== modified file 'src/Plugin.vala'
--- src/Plugin.vala	2013-09-28 22:17:35 +0000
+++ src/Plugin.vala	2013-11-28 10:12:02 +0000
@@ -51,8 +51,8 @@
 		ScreenSaver? screensaver;
 		
 #if HAS_MUTTER38
-		// FIXME we need a proper-sized background for every monitor
-		public BackgroundActor wallpaper { get; private set; }
+		public Meta.BackgroundGroup background_group { get; private set; }
+		public Clutter.Actor ui_group { get; private set; }
 #endif
 		
 		Window? moving; //place for the window that is being moved over
@@ -90,6 +90,9 @@
 			var screen = get_screen ();
 			
 			DBus.init (this);
+#if HAS_MUTTER38
+			BackgroundCache.init (screen);
+#endif
 			
 			// Due to a bug which enables access to the stage when using multiple monitors
 			// in the screensaver, we have to listen for changes and make sure the input area
@@ -102,12 +105,41 @@
 			
 			var stage = Compositor.get_stage_for_screen (screen) as Clutter.Stage;
 			
-			string color = new Settings ("org.gnome.desktop.background").get_string ("primary-color");
+			var color = BackgroundSettings.get_default ().primary_color;
 			stage.background_color = Clutter.Color.from_string (color);
 			
 			if (Prefs.get_dynamic_workspaces ())
 				screen.override_workspace_layout (ScreenCorner.TOPLEFT, false, 1, -1);
 			
+#if HAS_MUTTER38
+			/* our layer structure, copied from gnome-shell (from bottom to top):
+			 * stage
+			 * + system background
+			 * + ui group
+			 * +-- window group
+			 * +---- background manager
+			 * +-- shell elements
+			 * +-- top window group
+		     */
+
+			var system_background = new SystemBackground ();
+			system_background.add_constraint (new Clutter.BindConstraint (stage,
+				Clutter.BindCoordinate.ALL, 0));
+			stage.insert_child_below (system_background, null);
+
+			ui_group = new Clutter.Actor ();
+			ui_group.reactive = true;
+			stage.add_child (ui_group);
+
+			var window_group = Compositor.get_window_group_for_screen (screen);
+			stage.remove_child (window_group);
+			ui_group.add_child (window_group);
+
+			background_group = new BackgroundManager (screen);
+			window_group.add_child (background_group);
+			window_group.set_child_below_sibling (background_group, null);
+#endif
+
 			workspace_view = new WorkspaceView (this);
 			workspace_view.visible = false;
 			
@@ -116,13 +148,18 @@
 			zooming = new Zooming (this);
 			window_overview = new WindowOverview (this);
 			
+#if HAS_MUTTER38
+			ui_group.add_child (workspace_view);
+			ui_group.add_child (winswitcher);
+			ui_group.add_child (window_overview);
+
+			var top_window_group = Compositor.get_top_window_group_for_screen (screen);
+			stage.remove_child (top_window_group);
+			ui_group.add_child (top_window_group);
+#else
 			stage.add_child (workspace_view);
 			stage.add_child (winswitcher);
 			stage.add_child (window_overview);
-			
-#if HAS_MUTTER38
-			// FIXME create a background for every monitor and keep them updated and properly sized
-			wallpaper = new BackgroundActor ();
 #endif
 			
 			/*keybindings*/
@@ -189,8 +226,15 @@
 				workspace_view.show (true);
 			});
 			
+#if HAS_MUTTER38
+			//FIXME we have to investigate this. Apparently alt-tab is now bound to switch-applications
+			// instead of windows, which we should probably handle too
+			KeyBinding.set_custom_handler ("switch-applications", winswitcher.handle_switch_windows);
+			KeyBinding.set_custom_handler ("switch-applications-backward", winswitcher.handle_switch_windows);
+#else
 			KeyBinding.set_custom_handler ("switch-windows", winswitcher.handle_switch_windows);
 			KeyBinding.set_custom_handler ("switch-windows-backward", winswitcher.handle_switch_windows);
+#endif
 			
 			KeyBinding.set_custom_handler ("switch-to-workspace-up", () => {});
 			KeyBinding.set_custom_handler ("switch-to-workspace-down", () => {});
@@ -217,6 +261,9 @@
 
 #if HAS_MUTTER38
 			stage.show ();
+
+			// let the session manager move to the next phase
+			Meta.register_with_session ();
 			
 			return false;
 #endif
@@ -281,7 +328,7 @@
 			else
 				Utils.set_input_area (screen, InputArea.NONE);
 		}
-		
+
 		public uint32[] get_all_xids ()
 		{
 			var list = new Gee.ArrayList<uint32> ();
@@ -346,6 +393,10 @@
 #else
 			base.begin_modal (x_get_stage_window (Compositor.get_stage_for_screen (screen)), {}, 0, display.get_current_time ());
 #endif
+
+#if HAS_MUTTER38
+			Meta.Util.disable_unredirect_for_screen (screen);
+#endif
 		}
 		
 		public new void end_modal ()
@@ -355,7 +406,12 @@
 				return;
 			
 			update_input_area ();
-			base.end_modal (get_screen ().get_display ().get_current_time ());
+			
+			var screen = get_screen ();
+			base.end_modal (screen.get_display ().get_current_time ());
+#if HAS_MUTTER38
+			Meta.Util.enable_unredirect_for_screen (screen);
+#endif
 		}
 		
 		public void get_current_cursor_position (out int x, out int y)
@@ -786,7 +842,7 @@
 		/*workspace switcher*/
 		List<WindowActor>? win;
 		List<Clutter.Actor>? par; //class space for kill func
-		List<Clutter.Clone>? clones;
+		List<Clutter.Actor>? clones;
 		Clutter.Actor? in_group;
 		Clutter.Actor? out_group;
 		Clutter.Actor? moving_window_container;
@@ -834,6 +890,8 @@
 			var group = Compositor.get_window_group_for_screen (screen);
 #if !HAS_MUTTER38
 			var wallpaper = Compositor.get_background_actor_for_screen (screen);
+#else
+			var wallpaper = background_group;
 #endif
 			
 			in_group  = new Clutter.Actor ();
@@ -985,6 +1043,8 @@
 			
 #if !HAS_MUTTER38
 			var wallpaper = Compositor.get_background_actor_for_screen (screen);
+#else
+			var wallpaper = background_group;
 #endif
 			wallpaper.detach_animation ();
 			wallpaper.x = 0.0f;
@@ -1003,6 +1063,15 @@
 		{
 			return x_handle_event (event) != 0;
 		}
+
+#if HAS_MUTTER38
+		public override bool keybinding_filter (Meta.KeyBinding binding)
+		{
+			// for now we'll just block all keybindings if we're in modal mode, 
+			// do something useful with this later
+			return modal_count > 0;
+		}
+#endif
 		
 		public override unowned PluginInfo? plugin_info ()
 		{

=== modified file 'src/Settings.vala'
--- src/Settings.vala	2013-02-10 14:01:15 +0000
+++ src/Settings.vala	2013-11-28 10:12:02 +0000
@@ -151,4 +151,29 @@
 			return instance;
 		}
 	}
+
+	public class BackgroundSettings : Granite.Services.Settings
+	{
+		public string picture_options { get; set; }
+		public string picture_uri { get; set; }
+		public int picture_opacity { get; set; }
+		public string primary_color { get; set; }
+		public string secondary_color { get; set; }
+		public string color_shading_type { get; set; }
+
+		static BackgroundSettings? instance = null;
+
+		private BackgroundSettings ()
+		{
+			base ("org.gnome.desktop.background");
+		}
+
+		public static BackgroundSettings get_default ()
+		{
+			if (instance == null)
+				instance = new BackgroundSettings ();
+
+			return instance;
+		}
+	}
 }

=== modified file 'src/Widgets/WindowOverview.vala'
--- src/Widgets/WindowOverview.vala	2013-09-28 22:17:35 +0000
+++ src/Widgets/WindowOverview.vala	2013-11-28 10:12:02 +0000
@@ -578,12 +578,10 @@
 
 			screen.window_left_monitor.connect (window_left_monitor);
 			
-#if HAS_MUTTER38
-			plugin.wallpaper.
-#else
+#if !HAS_MUTTER38
 			Compositor.get_background_actor_for_screen (screen).
-#endif
 				animate (AnimationMode.EASE_OUT_QUAD, 350, dim_factor : 0.6);
+#endif
 			
 			// sort windows by stacking order
 			var windows = screen.get_display ().sort_windows_by_stacking (used_windows);
@@ -693,7 +691,7 @@
 			} else {
 				close (true);
 				//wait for the animation to finish before switching
-				Timeout.add (400, () => {
+				Clutter.Threads.Timeout.add (400, () => {
 					window.get_workspace ().activate_with_focus (window, screen.get_display ().get_current_time ());
 					return false;
 				});
@@ -722,15 +720,13 @@
 				exposed.selected.disconnect (thumb_selected);
 			}
 			
-#if HAS_MUTTER38
-			plugin.wallpaper.
-#else
+#if !HAS_MUTTER38
 			Compositor.get_background_actor_for_screen (screen).
-#endif
 				animate (AnimationMode.EASE_OUT_QUAD, 300, dim_factor : 1.0);
+#endif
 			
 			if (animate) {
-				Timeout.add (300, () => {
+				Clutter.Threads.Timeout.add (300, () => {
 					visible = false;
 					ready = true;
 					

=== modified file 'src/Widgets/WindowSwitcher.vala'
--- src/Widgets/WindowSwitcher.vala	2013-08-18 21:09:23 +0000
+++ src/Widgets/WindowSwitcher.vala	2013-11-28 10:12:02 +0000
@@ -220,6 +220,9 @@
 			var prev_win = current_window;
 			if (action == Meta.KeyBindingAction.SWITCH_GROUP ||
 				action == Meta.KeyBindingAction.SWITCH_WINDOWS || 
+#if HAS_MUTTER38
+				action == Meta.KeyBindingAction.SWITCH_APPLICATIONS ||
+#endif
 				event.get_key_symbol () == Clutter.Key.Right) {
 				
 				current_window = display.get_tab_next (Meta.TabList.NORMAL, screen, 
@@ -228,6 +231,9 @@
 				
 			} else if (action == Meta.KeyBindingAction.SWITCH_GROUP_BACKWARD ||
 				action == Meta.KeyBindingAction.SWITCH_WINDOWS_BACKWARD ||
+#if HAS_MUTTER38
+				action == Meta.KeyBindingAction.SWITCH_APPLICATIONS_BACKWARD ||
+#endif
 				event.get_key_symbol () == Clutter.Key.Left) {
 				
 				current_window = display.get_tab_next (Meta.TabList.NORMAL, screen, 
@@ -255,7 +261,7 @@
 			if (prev_window != current_window) {
 				dim_windows ();
 				// wait for the dimming to finish
-				Timeout.add (250, () => {
+				Clutter.Threads.Timeout.add (250, () => {
 					close (event.time);
 					return false;
 				});

=== modified file 'src/Widgets/WindowThumb.vala'
--- src/Widgets/WindowThumb.vala	2013-08-27 06:22:58 +0000
+++ src/Widgets/WindowThumb.vala	2013-11-28 10:12:02 +0000
@@ -88,7 +88,7 @@
 			window.delete (window.get_screen ().get_display ().get_current_time ());
 			// see if the window is still alive after the animation ended. If it is, it's pretty certain that it
 			// popped up some kind of confirmation dialog, so we focus it
-			Timeout.add (AnimationSettings.get_default ().close_duration + WAIT_FOR_CONFIRMATION_DIALOG, () => {
+			Clutter.Threads.Timeout.add (AnimationSettings.get_default ().close_duration + WAIT_FOR_CONFIRMATION_DIALOG, () => {
 				if (clone != null && clone.source != null && !(clone.source as Meta.WindowActor).is_destroyed ()) {
 					clone.source.opacity = 255;
 					selected (window);

=== modified file 'src/Widgets/WorkspaceThumb.vala'
--- src/Widgets/WorkspaceThumb.vala	2013-08-09 12:52:20 +0000
+++ src/Widgets/WorkspaceThumb.vala	2013-11-28 10:12:02 +0000
@@ -50,6 +50,7 @@
 		
 #if HAS_MUTTER38
 		internal Actor wallpaper;
+		Actor wallpaper_manager;
 #else
 		internal Clone wallpaper;
 #endif
@@ -60,7 +61,11 @@
 		
 		uint hover_timer = 0;
 		
+#if HAS_MUTTER38
+		public WorkspaceThumb (Workspace _workspace, Meta.BackgroundGroup _wallpaper)
+#else
 		public WorkspaceThumb (Workspace _workspace)
+#endif
 		{
 			workspace = _workspace;
 			screen = workspace.get_screen ();
@@ -89,9 +94,12 @@
 			
 			handle_workspace_switched (-1, screen.get_active_workspace_index (), MotionDirection.LEFT);
 			
-			// FIXME find a nice way to draw a border around it, maybe combinable with the indicator using a ShaderEffect
 #if HAS_MUTTER38
+			wallpaper_manager = new BackgroundManager (screen);
+			//FIXME apparently there are issues with scaling and animating the opacity. The wallpaper will
+			//      start flickering when the opacity changes. Wrapping it in a container solves this.
 			wallpaper = new Clutter.Actor ();
+			wallpaper.add_child (wallpaper_manager);
 #else
 			wallpaper = new Clone (Compositor.get_background_actor_for_screen (screen));
 #endif
@@ -202,6 +210,10 @@
 			indicator.width = width + 2 * INDICATOR_BORDER;
 			(indicator.content as Canvas).set_size ((int)indicator.width, (int)indicator.height);
 
+#if HAS_MUTTER38
+			wallpaper_manager.scale_x = width / swidth;
+			wallpaper_manager.scale_y = THUMBNAIL_HEIGHT / sheight;
+#endif
 			wallpaper.width = width;
 			windows.width = width;
 
@@ -270,7 +282,7 @@
 					window.delete (screen.get_display ().get_current_time ());
 			}
 			
-			GLib.Timeout.add (250, () => {
+			Clutter.Threads.Timeout.add (250, () => {
 				//wait for confirmation dialogs to popup
 				if (Utils.get_n_windows (workspace) == 0) {
 					workspace.window_added.disconnect (handle_window_added);
@@ -486,7 +498,7 @@
 				return;
 			
 			// we need to wait untill the animation ended, otherwise we get trouble with focus handling
-			Timeout.add (AnimationSettings.get_default ().workspace_switch_duration + 10, () => {
+			Clutter.Threads.Timeout.add (AnimationSettings.get_default ().workspace_switch_duration + 10, () => {
 				// check again, maybe something opened
 				if (workspace == null || Utils.get_n_windows (workspace) > 0)
 					return false;
@@ -525,7 +537,7 @@
 			workspace.activate (screen.get_display ().get_current_time ());
 			
 			// wait for the animation to be finished before closing, for aesthetic reasons
-			Timeout.add (AnimationSettings.get_default ().workspace_switch_duration, () => {
+			Clutter.Threads.Timeout.add (AnimationSettings.get_default ().workspace_switch_duration, () => {
 				clicked ();
 				return false;
 			});
@@ -551,7 +563,7 @@
 			if (hover_timer > 0)
 				GLib.Source.remove (hover_timer);
 			
-			hover_timer = Timeout.add (CLOSE_BUTTON_DELAY, () => {
+			hover_timer = Clutter.Threads.Timeout.add (CLOSE_BUTTON_DELAY, () => {
 				close_button.visible = true;
 				close_button.animate (AnimationMode.EASE_OUT_ELASTIC, 400, scale_x : 1.0f, scale_y : 1.0f);
 				return false;

=== modified file 'src/Widgets/WorkspaceView.vala'
--- src/Widgets/WorkspaceView.vala	2013-08-03 11:15:11 +0000
+++ src/Widgets/WorkspaceView.vala	2013-11-28 10:12:02 +0000
@@ -29,7 +29,9 @@
 		
 		Clutter.Actor thumbnails;
 		Clutter.Actor scroll;
+#if !HAS_MUTTER38
 		Clutter.Actor click_catcher; //invisible plane that catches clicks outside the view
+#endif
 		
 		bool animating; // delay closing the popup
 		
@@ -67,6 +69,7 @@
 			scroll.content = new Clutter.Canvas ();
 			(scroll.content as Clutter.Canvas).draw.connect (draw_scroll);
 			
+#if !HAS_MUTTER38
 			click_catcher = new Clutter.Actor ();
 			click_catcher.reactive = true;
 			click_catcher.button_release_event.connect ((e) => {
@@ -74,6 +77,7 @@
 				return true;
 			});
 			Compositor.get_stage_for_screen (screen).add_child (click_catcher);
+#endif
 			
 			add_child (thumbnails);
 			add_child (scroll);
@@ -114,7 +118,11 @@
 		void init_thumbnails ()
 		{
 			foreach (var workspace in screen.get_workspaces ()) {
+#if HAS_MUTTER38
+				var thumb = new WorkspaceThumb (workspace, plugin.background_group);
+#else
 				var thumb = new WorkspaceThumb (workspace);
+#endif
 				thumb.clicked.connect (hide);
 				thumb.closed.connect (remove_workspace);
 				thumb.window_on_last.connect (add_workspace);
@@ -128,6 +136,14 @@
 				&& Utils.get_n_windows (screen.get_workspaces ().first ().data) > 0)
 				add_workspace ();
 		}
+
+#if HAS_MUTTER38
+		bool outside_clicked (Clutter.ButtonEvent event)
+		{
+			hide ();
+			return true;
+		}
+#endif
 		
 		bool draw_background (Cairo.Context cr)
 		{
@@ -168,7 +184,11 @@
 		
 		void create_workspace_thumb (Meta.Workspace workspace)
 		{
+#if HAS_MUTTER38
+			var thumb = new WorkspaceThumb (workspace, plugin.background_group);
+#else
 			var thumb = new WorkspaceThumb (workspace);
+#endif
 			thumb.clicked.connect (hide);
 			thumb.closed.connect (remove_workspace);
 			thumb.window_on_last.connect (add_workspace);
@@ -390,6 +410,10 @@
 			
 			plugin.begin_modal ();
 			
+#if HAS_MUTTER38
+			plugin.ui_group.button_release_event.connect (outside_clicked);
+#endif
+			
 			var area = screen.get_monitor_geometry (screen.get_primary_monitor ());
 			y = area.height + area.y;
 			x = area.x;
@@ -414,14 +438,16 @@
 			int swidth, sheight;
 			screen.get_size (out swidth, out sheight);
 			
+#if !HAS_MUTTER38
 			click_catcher.width = swidth;
 			click_catcher.height = sheight;
 			click_catcher.x = 0;
 			click_catcher.y = 0;
 			click_catcher.visible = true;
+#endif
 			
 			animating = true;
-			Timeout.add (50, () => {
+			Clutter.Threads.Timeout.add (50, () => {
 				animating = false;
 				return false;
 			}); //catch hot corner hiding problem
@@ -431,13 +457,17 @@
 			wins.x = 0.0f;
 			
 			animate (Clutter.AnimationMode.EASE_OUT_QUAD, 250, y : (area.height + area.y) - height);
-			wins.animate (Clutter.AnimationMode.EASE_OUT_QUAD, 250, y : -height + 1);
+			wins.animate (Clutter.AnimationMode.EASE_OUT_QUAD, 250, y : -height + 1.01f);
 		}
 		
 		public new void hide ()
 		{
 			if (!visible || animating)
 				return;
+
+#if HAS_MUTTER38
+			plugin.ui_group.button_release_event.disconnect (outside_clicked);
+#endif
 			
 			float width, height;
 			plugin.get_screen ().get_size (out width, out height);
@@ -454,7 +484,9 @@
 				visible = false;
 			});
 			
+#if !HAS_MUTTER38
 			click_catcher.visible = false;
+#endif
 			
 			var wins = Compositor.get_window_group_for_screen (screen);
 			wins.detach_animation ();

=== modified file 'src/Zooming.vala'
--- src/Zooming.vala	2012-08-28 15:49:58 +0000
+++ src/Zooming.vala	2013-11-28 10:12:02 +0000
@@ -67,7 +67,7 @@
 				wins.scale_center_x = mx;
 				wins.scale_center_y = my;
 				
-				mouse_poll_timer = Timeout.add (MOUSE_POLL_TIME, () => {
+				mouse_poll_timer = Clutter.Threads.Timeout.add (MOUSE_POLL_TIME, () => {
 					client_pointer.get_position (null, out mx, out my);
 					if (wins.scale_center_x == mx && wins.scale_center_y == my)
 						return true;

=== modified file 'vapi/gdesktopenums-3.0.vapi'
--- vapi/gdesktopenums-3.0.vapi	2012-08-19 13:56:07 +0000
+++ vapi/gdesktopenums-3.0.vapi	2013-11-28 10:12:02 +0000
@@ -34,6 +34,20 @@
 		SMART,
 		STRICT
 	}
+	[CCode (cheader_filename = "gsettings-desktop-schemas/gdesktop-enums.h", cprefix = "G_DESKTOP_MAGNIFIER_CARET_TRACKING_MODE_", has_type_id = false)]
+	public enum MagnifierCaretTrackingMode {
+		NONE,
+		CENTERED,
+		PROPORTIONAL,
+		PUSH
+	}
+	[CCode (cheader_filename = "gsettings-desktop-schemas/gdesktop-enums.h", cprefix = "G_DESKTOP_MAGNIFIER_FOCUS_TRACKING_MODE_", has_type_id = false)]
+	public enum MagnifierFocusTrackingMode {
+		NONE,
+		CENTERED,
+		PROPORTIONAL,
+		PUSH
+	}
 	[CCode (cheader_filename = "gsettings-desktop-schemas/gdesktop-enums.h", cprefix = "G_DESKTOP_MAGNIFIER_MOUSE_TRACKING_MODE_", has_type_id = false)]
 	public enum MagnifierMouseTrackingMode {
 		NONE,

=== added file 'vapi/gnome-desktop-3.0.deps'
--- vapi/gnome-desktop-3.0.deps	1970-01-01 00:00:00 +0000
+++ vapi/gnome-desktop-3.0.deps	2013-11-28 10:12:02 +0000
@@ -0,0 +1,7 @@
+atk
+cairo
+gio-2.0
+gdesktopenums-3.0
+gdk-pixbuf-2.0
+gdk-3.0
+gtk+-3.0

=== added file 'vapi/gnome-desktop-3.0.vapi'
--- vapi/gnome-desktop-3.0.vapi	1970-01-01 00:00:00 +0000
+++ vapi/gnome-desktop-3.0.vapi	2013-11-28 10:12:02 +0000
@@ -0,0 +1,310 @@
+/* gnome-desktop-3.0.vapi generated by vapigen, do not modify. */
+
+[CCode (cprefix = "Gnome", gir_namespace = "GnomeDesktop", gir_version = "3.0", lower_case_cprefix = "gnome_")]
+namespace Gnome {
+	namespace DesktopThumbnail {
+		[CCode (cheader_filename = "libgnome-desktop/gnome-desktop-thumbnail.h")]
+		public static bool has_uri (Gdk.Pixbuf pixbuf, string uri);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-desktop-thumbnail.h")]
+		public static bool is_valid (Gdk.Pixbuf pixbuf, string uri, long mtime);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-desktop-thumbnail.h")]
+		[Deprecated (since = "2.22")]
+		public static string md5 (string uri);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-desktop-thumbnail.h")]
+		public static string path_for_uri (string uri, Gnome.DesktopThumbnailSize size);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-desktop-thumbnail.h")]
+		public static Gdk.Pixbuf scale_down_pixbuf (Gdk.Pixbuf pixbuf, int dest_width, int dest_height);
+	}
+	namespace Languages {
+		[CCode (array_length = false, array_null_terminated = true, cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_get_all_languages")]
+		public static string[] get_all_languages ();
+		[CCode (array_length = false, array_null_terminated = true, cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_get_all_locales")]
+		public static string[] get_all_locales ();
+		[CCode (cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_get_country_from_code")]
+		public static string get_country_from_code (string code, string? translation);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_get_country_from_locale")]
+		public static string get_country_from_locale (string locale, string? translation);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_get_input_source_from_locale")]
+		public static bool get_input_source_from_locale (string locale, out unowned string type, out unowned string id);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_get_language_from_code")]
+		public static string get_language_from_code (string code, string? translation);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_get_language_from_locale")]
+		public static string get_language_from_locale (string locale, string? translation);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_language_has_translations")]
+		public static bool language_has_translations (string code);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_normalize_locale")]
+		public static string normalize_locale (string locale);
+		[CCode (cheader_filename = "libgnome-desktop/gnome-languages.h", cname = "gnome_parse_locale")]
+		public static bool parse_locale (string locale, out string language_codep, out string country_codep, out string codesetp, out string modifierp);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-bg.h", type_id = "gnome_bg_get_type ()")]
+	public class BG : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public BG ();
+		public bool changes_with_time ();
+		public Gdk.Pixbuf create_frame_thumbnail (Gnome.DesktopThumbnailFactory factory, Gdk.Screen screen, int dest_width, int dest_height, int frame_num);
+		public Cairo.Surface create_surface (Gdk.Window window, int width, int height, bool root);
+		public Gdk.Pixbuf create_thumbnail (Gnome.DesktopThumbnailFactory factory, Gdk.Screen screen, int dest_width, int dest_height);
+		public void draw (Gdk.Pixbuf dest, Gdk.Screen screen, bool is_root);
+		public void get_color (GDesktop.BackgroundShading type, Gdk.Color primary, Gdk.Color secondary);
+		public bool get_draw_background ();
+		public unowned string get_filename ();
+		public bool get_image_size (Gnome.DesktopThumbnailFactory factory, int best_width, int best_height, int width, int height);
+		public GDesktop.BackgroundStyle get_placement ();
+		public static Cairo.Surface get_surface_from_root (Gdk.Screen screen);
+		public bool has_multiple_sizes ();
+		public bool is_dark (int dest_width, int dest_height);
+		public void load_from_preferences (GLib.Settings settings);
+		public void save_to_preferences (GLib.Settings settings);
+		public void set_color (GDesktop.BackgroundShading type, Gdk.Color primary, Gdk.Color secondary);
+		public void set_draw_background (bool draw_background);
+		public void set_filename (string filename);
+		public void set_placement (GDesktop.BackgroundStyle placement);
+		public static void set_surface_as_root (Gdk.Screen screen, Cairo.Surface surface);
+		public static Gnome.BGCrossfade set_surface_as_root_with_crossfade (Gdk.Screen screen, Cairo.Surface surface);
+		public signal void changed ();
+		public signal void transitioned ();
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-bg-crossfade.h", type_id = "gnome_bg_crossfade_get_type ()")]
+	public class BGCrossfade : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public BGCrossfade (int width, int height);
+		public bool is_started ();
+		public bool set_end_surface (Cairo.Surface surface);
+		public bool set_start_surface (Cairo.Surface surface);
+		public void start (Gdk.Window window);
+		public void stop ();
+		[NoAccessorMethod]
+		public int height { get; construct; }
+		[NoAccessorMethod]
+		public int width { get; construct; }
+		public virtual signal void finished (GLib.Object window);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-bg-slide-show.h", type_id = "gnome_bg_slide_show_get_type ()")]
+	public class BGSlideShow : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public BGSlideShow (string filename);
+		public void get_current_slide (int width, int height, out double progress, out double duration, out bool is_fixed, out unowned string file1, out unowned string file2);
+		public bool get_has_multiple_sizes ();
+		public int get_num_slides ();
+		public bool get_slide (int frame_number, int width, int height, double progress, out double duration, out bool is_fixed, out unowned string file1, out unowned string file2);
+		public double get_start_time ();
+		public double get_total_duration ();
+		public bool load () throws GLib.Error;
+		public void load_async (GLib.Cancellable? cancellable, GLib.AsyncReadyCallback callback);
+		[NoAccessorMethod]
+		public string filename { owned get; construct; }
+		public bool has_multiple_sizes { get; }
+		public double start_time { get; }
+		public double total_duration { get; }
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-desktop-thumbnail.h", type_id = "gnome_desktop_thumbnail_factory_get_type ()")]
+	public class DesktopThumbnailFactory : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public DesktopThumbnailFactory (Gnome.DesktopThumbnailSize size);
+		public bool can_thumbnail (string uri, string mime_type, long mtime);
+		public void create_failed_thumbnail (string uri, long mtime);
+		public Gdk.Pixbuf generate_thumbnail (string uri, string mime_type);
+		public bool has_valid_failed_thumbnail (string uri, long mtime);
+		public string lookup (string uri, long mtime);
+		public void save_thumbnail (Gdk.Pixbuf thumbnail, string uri, long original_mtime);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-idle-monitor.h", type_id = "gnome_idle_monitor_get_type ()")]
+	public class IdleMonitor : GLib.Object, GLib.Initable {
+		[CCode (has_construct_function = false)]
+		public IdleMonitor ();
+		public uint add_idle_watch (uint64 interval_msec, owned Gnome.IdleMonitorWatchFunc? callback);
+		public uint add_user_active_watch (owned Gnome.IdleMonitorWatchFunc? callback);
+		[CCode (has_construct_function = false)]
+		public IdleMonitor.for_device (Gdk.Device device) throws GLib.Error;
+		public uint64 get_idletime ();
+		public void remove_watch (uint id);
+		[NoAccessorMethod]
+		public Gdk.Device device { owned get; construct; }
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-pnp-ids.h", type_id = "gnome_pnp_ids_get_type ()")]
+	public class PnpIds : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public PnpIds ();
+		public string get_pnp_id (string pnp_id);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr-config.h", type_id = "gnome_rr_config_get_type ()")]
+	public class RRConfig : GLib.Object {
+		[CCode (has_construct_function = false)]
+		protected RRConfig ();
+		public bool applicable (Gnome.RRScreen screen) throws GLib.Error;
+		public bool apply (Gnome.RRScreen screen) throws GLib.Error;
+		public bool apply_persistent (Gnome.RRScreen screen) throws GLib.Error;
+		[CCode (has_construct_function = false)]
+		public RRConfig.current (Gnome.RRScreen screen) throws GLib.Error;
+		public bool ensure_primary ();
+		public bool equal (Gnome.RRConfig config2);
+		public bool get_clone ();
+		[CCode (array_length = false, array_null_terminated = true)]
+		public unowned Gnome.RROutputInfo[] get_outputs ();
+		public bool load_current () throws GLib.Error;
+		public bool match (Gnome.RRConfig config2);
+		public void sanitize ();
+		public void set_clone (bool clone);
+		public Gnome.RRScreen screen { construct; }
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "gnome_rr_crtc_get_type ()")]
+	[Compact]
+	public class RRCrtc {
+		public bool can_drive_output (Gnome.RROutput output);
+		public Gnome.RRMode get_current_mode ();
+		public Gnome.RRRotation get_current_rotation ();
+		public bool get_gamma (int size, ushort red, ushort green, ushort blue);
+		public uint32 get_id ();
+		public void get_position (out int x, out int y);
+		public Gnome.RRRotation get_rotations ();
+		public bool set_gamma (int size, ushort red, ushort green, ushort blue);
+		public bool supports_rotation (Gnome.RRRotation rotation);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "gnome_rr_mode_get_type ()")]
+	[Compact]
+	public class RRMode {
+		public int get_freq ();
+		public uint get_height ();
+		public uint32 get_id ();
+		public uint get_width ();
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "gnome_rr_output_get_type ()")]
+	[Compact]
+	public class RROutput {
+		public bool can_clone (Gnome.RROutput clone);
+		public int get_backlight ();
+		public Gnome.RRCrtc get_crtc ();
+		public Gnome.RRMode get_current_mode ();
+		public unowned string get_display_name ();
+		public uint8 get_edid_data (size_t size);
+		public uint32 get_id ();
+		public void get_ids_from_edid (out string vendor, out string product, out string serial);
+		public bool get_is_primary ();
+		public unowned string get_name ();
+		public void get_physical_size (out int width_mm, out int height_mm);
+		public void get_position (out int x, out int y);
+		public Gnome.RRCrtc get_possible_crtcs ();
+		public Gnome.RRMode get_preferred_mode ();
+		public bool is_builtin_display ();
+		public Gnome.RRMode list_modes ();
+		public bool set_backlight (int value) throws GLib.Error;
+		public bool supports_mode (Gnome.RRMode mode);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr-config.h", type_id = "gnome_rr_output_info_get_type ()")]
+	public class RROutputInfo : GLib.Object {
+		[CCode (has_construct_function = false)]
+		protected RROutputInfo ();
+		public double get_aspect_ratio ();
+		public unowned string get_display_name ();
+		public void get_geometry (out int x, out int y, out int width, out int height);
+		public unowned string get_name ();
+		public int get_preferred_height ();
+		public int get_preferred_width ();
+		public bool get_primary ();
+		public unowned string get_product ();
+		public int get_refresh_rate ();
+		public Gnome.RRRotation get_rotation ();
+		public unowned string get_serial ();
+		public unowned string get_vendor ();
+		public bool is_active ();
+		public bool is_connected ();
+		public void set_active (bool active);
+		public void set_geometry (int x, int y, int width, int height);
+		public void set_primary (bool primary);
+		public void set_refresh_rate (int rate);
+		public void set_rotation (Gnome.RRRotation rotation);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr.h", type_id = "gnome_rr_screen_get_type ()")]
+	public class RRScreen : GLib.Object, GLib.AsyncInitable, GLib.Initable {
+		[CCode (has_construct_function = false)]
+		public RRScreen (Gdk.Screen screen) throws GLib.Error;
+		public Gnome.RRMode create_clone_modes ();
+		[CCode (cname = "gnome_rr_screen_new_async", has_construct_function = false)]
+		public async RRScreen.from_async (Gdk.Screen screen) throws GLib.Error;
+		public unowned Gnome.RRCrtc get_crtc_by_id (uint32 id);
+		public bool get_dpms_mode (out Gnome.RRDpmsMode mode) throws GLib.Error;
+		public unowned Gnome.RROutput get_output_by_id (uint32 id);
+		public unowned Gnome.RROutput get_output_by_name (string name);
+		public void get_ranges (out int min_width, out int max_width, out int min_height, out int max_height);
+		[CCode (array_length = false, array_null_terminated = true)]
+		public unowned Gnome.RRMode[] list_clone_modes ();
+		[CCode (array_length = false, array_null_terminated = true)]
+		public unowned Gnome.RRCrtc[] list_crtcs ();
+		[CCode (array_length = false, array_null_terminated = true)]
+		public unowned Gnome.RRMode[] list_modes ();
+		[CCode (array_length = false, array_null_terminated = true)]
+		public unowned Gnome.RROutput[] list_outputs ();
+		public bool refresh () throws GLib.Error;
+		public bool set_dpms_mode (Gnome.RRDpmsMode mode) throws GLib.Error;
+		[NoAccessorMethod]
+		public Gdk.Screen gdk_screen { owned get; construct; }
+		public virtual signal void changed ();
+		public virtual signal void output_connected (void* output);
+		public virtual signal void output_disconnected (void* output);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-wall-clock.h", type_id = "gnome_wall_clock_get_type ()")]
+	public class WallClock : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public WallClock ();
+		public unowned string get_clock ();
+		public unowned GLib.TimeZone get_timezone ();
+		public string clock { get; }
+		[NoAccessorMethod]
+		public bool time_only { get; set; }
+		public GLib.TimeZone timezone { get; }
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-xkb-info.h", type_id = "gnome_xkb_info_get_type ()")]
+	public class XkbInfo : GLib.Object {
+		[CCode (has_construct_function = false)]
+		public XkbInfo ();
+		public unowned string description_for_group (string group_id);
+		public unowned string description_for_option (string group_id, string id);
+		public GLib.List<weak string> get_all_layouts ();
+		public GLib.List<weak string> get_all_option_groups ();
+		public bool get_layout_info (string id, out unowned string display_name, out unowned string short_name, out unowned string xkb_layout, out unowned string xkb_variant);
+		public GLib.List<weak string> get_layouts_for_country (string country_code);
+		public GLib.List<weak string> get_layouts_for_language (string language_code);
+		public GLib.List<weak string> get_options_for_group (string group_id);
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-desktop-thumbnail.h", cprefix = "GNOME_DESKTOP_THUMBNAIL_SIZE_", has_type_id = false)]
+	public enum DesktopThumbnailSize {
+		NORMAL,
+		LARGE
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr.h", cprefix = "GNOME_RR_DPMS_", has_type_id = false)]
+	public enum RRDpmsMode {
+		ON,
+		STANDBY,
+		SUSPEND,
+		OFF,
+		DISABLED,
+		UNKNOWN
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr.h", cprefix = "GNOME_RR_", has_type_id = false)]
+	[Flags]
+	public enum RRRotation {
+		ROTATION_NEXT,
+		ROTATION_0,
+		ROTATION_90,
+		ROTATION_180,
+		ROTATION_270,
+		REFLECT_X,
+		REFLECT_Y
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr.h", cprefix = "GNOME_RR_ERROR_")]
+	public errordomain RRError {
+		UNKNOWN,
+		NO_RANDR_EXTENSION,
+		RANDR_ERROR,
+		BOUNDS_ERROR,
+		CRTC_ASSIGNMENT,
+		NO_MATCHING_CONFIG,
+		NO_DPMS_EXTENSION;
+		public static GLib.Quark quark ();
+	}
+	[CCode (cheader_filename = "libgnome-desktop/gnome-idle-monitor.h", instance_pos = 2.9)]
+	public delegate void IdleMonitorWatchFunc (Gnome.IdleMonitor monitor, uint id);
+	[CCode (cheader_filename = "libgnome-desktop/gnome-rr.h", cname = "GNOME_RR_CONNECTOR_TYPE_PANEL")]
+	public const string RR_CONNECTOR_TYPE_PANEL;
+}

