=== modified file 'configure.ac'
--- configure.ac	2014-12-11 10:40:36 +0000
+++ configure.ac	2015-01-03 19:55:40 +0000
@@ -163,6 +163,7 @@
     VALAFLAGS="$VALAFLAGS --define HAS_MUTTER314"
     MUTTER_API="3.14"
 fi
+AM_CONDITIONAL([HAVE_MUTTER314], [test "x$have_mutter314" = "xyes"])
 
 # 3.16
 PKG_CHECK_MODULES(MUTTER316, [libmutter >= 3.15], [have_mutter316=yes], [have_mutter316=no])

=== modified file 'src/DBus.vala'
--- src/DBus.vala	2014-10-12 08:55:43 +0000
+++ src/DBus.vala	2015-01-03 20:43:04 +0000
@@ -44,7 +44,11 @@
 		private DBus ()
 		{
 			if (wm.background_group != null)
+#if HAS_MUTTER314
 				(wm.background_group as BackgroundContainer).changed.connect (() => background_changed ());
+#else
+				(wm.background_group as BackgroundManager).changed.connect (() => background_changed ());
+#endif
 			else
 				assert_not_reached ();
 		}

=== modified file 'src/Makefile.am'
--- src/Makefile.am	2014-10-12 08:55:43 +0000
+++ src/Makefile.am	2015-01-03 20:00:51 +0000
@@ -43,23 +43,34 @@
 	WindowListener.vala \
 	WindowManager.vala \
 	WorkspaceManager.vala \
-	Background/Animation.vala \
-	Background/Background.vala \
-	Background/BackgroundCache.vala \
-	Background/BackgroundContainer.vala \
-	Background/BackgroundManager.vala \
-	Background/BackgroundSource.vala \
-	Background/SystemBackground.vala \
 	Widgets/IconGroup.vala \
 	Widgets/IconGroupContainer.vala \
 	Widgets/MonitorClone.vala \
 	Widgets/MultitaskingView.vala \
 	Widgets/WindowClone.vala \
 	Widgets/WindowCloneContainer.vala \
+	Widgets/WindowMenu.vala \
 	Widgets/WindowOverview.vala \
 	Widgets/WindowSwitcher.vala \
-	Widgets/WorkspaceClone.vala \
-	$(NULL)
+	Widgets/WorkspaceClone.vala
+
+if HAVE_MUTTER314
+gala_VALASOURCES += Background/Animation.vala \
+	Background/Background.vala \
+	Background/BackgroundCache.vala \
+	Background/BackgroundContainer.vala \
+	Background/BackgroundManager.vala \
+	Background/BackgroundSource.vala \
+	Background/SystemBackground.vala
+else
+gala_VALASOURCES += Background312/Background.vala \
+	Background312/BackgroundCache.vala \
+	Background312/BackgroundManager.vala \
+	Background312/SlideShow.vala \
+	Background312/SystemBackground.vala
+endif
+
+gala_VALASOURCES += $(NULL)
 
 nodist_gala_SOURCES = \
 	gala_vala.stamp \

=== modified file 'src/Widgets/MonitorClone.vala'
--- src/Widgets/MonitorClone.vala	2014-10-12 08:55:43 +0000
+++ src/Widgets/MonitorClone.vala	2015-01-03 19:55:40 +0000
@@ -35,7 +35,11 @@
 		public int monitor { get; construct; }
 
 		WindowCloneContainer window_container;
+#if HAS_MUTTER314
 		BackgroundManager background;
+#else
+		Background background;
+#endif
 
 		public MonitorClone (Screen screen, int monitor)
 		{
@@ -46,7 +50,11 @@
 		{
 			reactive = true;
 
+#if HAS_MUTTER314
 			background = new BackgroundManager (screen, monitor, false);
+#else
+			background = new Background (screen, monitor, BackgroundSettings.get_default ().schema);
+#endif
 			background.set_easing_duration (300);
 
 			window_container = new WindowCloneContainer ();

=== added file 'src/Widgets/WindowMenu.vala'
--- src/Widgets/WindowMenu.vala	1970-01-01 00:00:00 +0000
+++ src/Widgets/WindowMenu.vala	2015-01-03 20:25:58 +0000
@@ -0,0 +1,152 @@
+//
+//  Copyright (C) 2014 Gala Developers
+//
+//  This program is free software: you can redistribute it and/or modify
+//  it under the terms of the GNU General Public License as published by
+//  the Free Software Foundation, either version 3 of the License, or
+//  (at your option) any later version.
+//
+//  This program is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU General Public License for more details.
+//
+//  You should have received a copy of the GNU General Public License
+//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+//
+//  Authored By: Tom Beckmann
+//
+
+#if HAS_MUTTER314
+
+namespace Gala
+{
+	/**
+	 * GtkMenu that is spawned on windows e.g. by rightclick on titlebar
+	 * Prior to mutter3.14 this was provided by libmutter
+	 */
+	public class WindowMenu : Gtk.Menu
+	{
+		public Meta.Window current_window {
+			get {
+				return _current_window;
+			}
+			set {
+				_current_window = value;
+				update_window ();
+			}
+		}
+
+		Meta.Window _current_window;
+
+		Gtk.MenuItem minimize;
+		Gtk.MenuItem maximize;
+		Gtk.MenuItem move;
+		Gtk.MenuItem resize;
+		Gtk.CheckMenuItem always_on_top;
+		Gtk.CheckMenuItem on_visible_workspace;
+		Gtk.MenuItem move_left;
+		Gtk.MenuItem move_right;
+		Gtk.MenuItem close;
+
+		public WindowMenu ()
+		{
+		}
+
+		construct
+		{
+			minimize = new Gtk.MenuItem.with_label (_("Minimize"));
+			minimize.activate.connect (() => {
+				current_window.minimize ();
+			});
+			append (minimize);
+
+			maximize = new Gtk.MenuItem.with_label ("");
+			maximize.activate.connect (() => {
+				if (current_window.get_maximized () > 0)
+					current_window.unmaximize (Meta.MaximizeFlags.BOTH);
+				else
+					current_window.maximize (Meta.MaximizeFlags.BOTH);
+			});
+			append (maximize);
+
+			move = new Gtk.MenuItem.with_label (_("Move"));
+			move.activate.connect (() => {
+				current_window.begin_grab_op (Meta.GrabOp.KEYBOARD_MOVING, true,
+					Gtk.get_current_event_time ());
+			});
+			append (move);
+
+			resize = new Gtk.MenuItem.with_label (_("Resize"));
+			resize.activate.connect (() => {
+				current_window.begin_grab_op (Meta.GrabOp.KEYBOARD_RESIZING_UNKNOWN, true,
+					Gtk.get_current_event_time ());
+			});
+			append (resize);
+
+			always_on_top = new Gtk.CheckMenuItem.with_label (_("Always on Top"));
+			always_on_top.activate.connect (() => {
+				if (current_window.is_above ())
+					current_window.unmake_above ();
+				else
+					current_window.make_above ();
+			});
+			append (always_on_top);
+
+			on_visible_workspace = new Gtk.CheckMenuItem.with_label (_("Always on Visible Workspace"));
+			on_visible_workspace.activate.connect (() => {
+				if (current_window.on_all_workspaces)
+					current_window.unstick ();
+				else
+					current_window.stick ();
+			});
+			append (on_visible_workspace);
+
+			move_left = new Gtk.MenuItem.with_label (_("Move to Workspace Left"));
+			move_left.activate.connect (() => {
+				var wp = current_window.get_workspace ().get_neighbor (Meta.MotionDirection.LEFT);
+				if (wp != null)
+					current_window.change_workspace (wp);
+			});
+			append (move_left);
+
+			move_right = new Gtk.MenuItem.with_label (_("Move to Workspace Right"));
+			move_right.activate.connect (() => {
+				var wp = current_window.get_workspace ().get_neighbor (Meta.MotionDirection.RIGHT);
+				if (wp != null)
+					current_window.change_workspace (wp);
+			});
+			append (move_right);
+
+			close = new Gtk.MenuItem.with_label (_("Close"));
+			close.activate.connect (() => {
+				current_window.@delete (Gtk.get_current_event_time ());
+			});
+			append (close);
+		}
+
+		void update_window ()
+		{
+			minimize.visible = current_window.can_minimize ();
+
+			maximize.visible = current_window.can_maximize ();
+			maximize.label = current_window.get_maximized () > 0 ? _("Unmaximize") : _("Maximize");
+
+			move.visible = current_window.allows_move ();
+
+			resize.visible = current_window.allows_resize ();
+
+			always_on_top.active = current_window.is_above ();
+
+			on_visible_workspace.active = current_window.on_all_workspaces;
+
+			move_right.visible = !current_window.on_all_workspaces;
+
+			move_left.visible = !current_window.on_all_workspaces;
+
+			close.visible = current_window.can_close ();
+		}
+	}
+}
+
+#endif

=== modified file 'src/Widgets/WorkspaceClone.vala'
--- src/Widgets/WorkspaceClone.vala	2014-10-12 08:55:43 +0000
+++ src/Widgets/WorkspaceClone.vala	2015-01-03 21:04:41 +0000
@@ -23,11 +23,20 @@
 	/**
 	 * Utility class which adds a border and a shadow to a Background
 	 */
+#if HAS_MUTTER314
 	class FramedBackground : BackgroundManager
+#else
+	class FramedBackground : Background
+#endif
 	{
 		public FramedBackground (Screen screen)
 		{
+#if HAS_MUTTER314
 			Object (screen: screen, monitor_index: screen.get_primary_monitor (), control_position: false);
+#else
+			Object (screen: screen, monitor: screen.get_primary_monitor (), 
+					settings: BackgroundSettings.get_default ().schema);
+#endif
 		}
 
 		construct
@@ -110,7 +119,11 @@
 			}
 		}
 
+#if HAS_MUTTER314
 		BackgroundManager background;
+#else
+		Background background;
+#endif
 		bool opened;
 
 		uint hover_activate_timeout = 0;

=== modified file 'src/WindowManager.vala'
--- src/WindowManager.vala	2014-10-12 08:55:43 +0000
+++ src/WindowManager.vala	2015-01-03 21:04:41 +0000
@@ -89,6 +89,9 @@
 			var screen = get_screen ();
 
 			DBus.init (this);
+#if !HAS_MUTTER314
+			BackgroundCache.init (screen);
+#endif
 			WindowListener.init (screen);
 
 			// Due to a bug which enables access to the stage when using multiple monitors
@@ -120,7 +123,11 @@
 			 * +-- top window group
 		     */
 
+#if HAS_MUTTER314
 			var system_background = new SystemBackground (screen);
+#else
+			var system_background = new SystemBackground ();
+#endif
 			system_background.add_constraint (new Clutter.BindConstraint (stage,
 				Clutter.BindCoordinate.ALL, 0));
 			stage.insert_child_below (system_background, null);
@@ -133,7 +140,11 @@
 			stage.remove_child (window_group);
 			ui_group.add_child (window_group);
 
+#if HAS_MUTTER314
 			background_group = new BackgroundContainer (screen);
+#else
+			background_group = new BackgroundManager (screen);
+#endif
 			window_group.add_child (background_group);
 			window_group.set_child_below_sibling (background_group, null);
 
@@ -617,17 +628,34 @@
 		}
 
 #if HAS_MUTTER314
+		WindowMenu? window_menu = null;
+
 		public override void show_window_menu (Meta.Window window, Meta.WindowMenuType menu, int x, int y)
 		{
-			//TODO implement window/app menus, their implementation where removed with mutter 3.13+
+#if false
+			// Spawning native menus inside mutter appears to be no longer working, mouse
+			// event are apparently never delivered to the menu. Until this is fixed, we
+			// disable windowmenus all together
+
+			var time = get_screen ().get_display ().get_current_time_roundtrip ();
+
 			switch (menu) {
-			case WindowMenuType.WM:
-				message ("TODO: show window menu for %s at %ix%i\n", window.get_description (), x, y);
-				break;
-			case WindowMenuType.APP:
-				message ("TODO: show app menu for %s at %ix%i\n", window.get_description (), x, y);
-				break;
+				case WindowMenuType.WM:
+					if (window_menu == null)
+						window_menu = new WindowMenu ();
+
+					window_menu.current_window = window;
+					window_menu.show_all ();
+					window_menu.popup (null, null, (menu, out menu_x, out menu_y, out push_in) => {
+						menu_x = x;
+						menu_y = y;
+					}, Gdk.BUTTON_SECONDARY, time);
+					break;
+				case WindowMenuType.APP:
+					// FIXME we don't have any sort of app menus
+					break;
 			}
+#endif
 		}
 
 		public override void show_window_menu_for_rect (Meta.Window window, Meta.WindowMenuType menu, Meta.Rectangle rect)
@@ -1176,14 +1204,27 @@
 
 				// to maintain the correct order of monitor, we need to insert the Background
 				// back manually
+#if HAS_MUTTER314
 				if (actor is BackgroundManager) {
 					var background = (BackgroundManager) actor;
+#else
+				if (actor is Background) {
+					var background = (Background) actor;
+#endif
 
 					background.get_parent ().remove_child (background);
+#if HAS_MUTTER314
 					background_group.insert_child_at_index (background, background.monitor_index);
+#else
+					background_group.insert_child_at_index (background, background.monitor);
+#endif
 					background.x = background.steal_data<int> ("prev-x");
 					continue;
+#if HAS_MUTTER314
 				} else if (actor is Meta.BackgroundGroup) {
+#else
+				} else if (actor is BackgroundManager) {
+#endif
 					actor.x = 0;
 					// thankfully mutter will take care of stacking it at the right place for us
 					clutter_actor_reparent (actor, window_group);

=== modified file 'src/WorkspaceManager.vala'
--- src/WorkspaceManager.vala	2014-07-16 22:47:36 +0000
+++ src/WorkspaceManager.vala	2015-01-03 22:05:26 +0000
@@ -120,7 +120,8 @@
 
 		void window_added (Workspace? workspace, Window window)
 		{
-			if (workspace == null || !Prefs.get_dynamic_workspaces ())
+			if (workspace == null || !Prefs.get_dynamic_workspaces ()
+				|| window.on_all_workspaces)
 				return;
 
 			unowned Screen screen = workspace.get_screen ();

