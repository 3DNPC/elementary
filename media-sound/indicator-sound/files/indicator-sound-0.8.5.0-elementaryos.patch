diff -Naur indicator-sound-0.8.5.0/data/com.canonical.indicator.sound.gschema.xml indicator-sound-precise/data/com.canonical.indicator.sound.gschema.xml
--- indicator-sound-0.8.5.0/data/com.canonical.indicator.sound.gschema.xml	2012-03-30 10:26:53.000000000 -0700
+++ indicator-sound-precise/data/com.canonical.indicator.sound.gschema.xml	2012-07-26 21:03:55.488143000 -0700
@@ -11,13 +11,20 @@
     </key>
     <key name="interested-media-players" type="as">
       <summary>A list of applications which at some point have registered with the sound menu</summary>
-      <default>[ 'rhythmbox' ]</default>
+      <default>['noise', 'beatbox', 'rhythmbox']</default>
       <description>
         Each media player which abides by the MPRIS2 spec will automatically appear in the menu.
         This array should contain the desktop file names (minus .desktop suffix) of applications which
         have at some point appeared in the menU. This allows the menu remember and display offlined applications.
       </description>
     </key>
+    <key name="preferred-media-players" type="as">
+      <summary>A list of applications that will have player controls visible all the time</summary>
+      <default>['noise', 'beatbox']</default>
+      <description>
+        A list of applications that will have player controls visible all the time
+      </description>
+    </key>
     <key name="global-mute" type="b">
       <default>false</default>
       <summary>Initial setting for global mute (mute all) on the menu </summary>
diff -Naur indicator-sound-0.8.5.0/.pc/applied-patches indicator-sound-precise/.pc/applied-patches
--- indicator-sound-0.8.5.0/.pc/applied-patches	1969-12-31 16:00:00.000000000 -0800
+++ indicator-sound-precise/.pc/applied-patches	2012-07-26 21:03:55.488143000 -0700
@@ -0,0 +1,5 @@
+sound_nua.patch
+sound_xubuntu.patch
+sound_ubuntustudio.patch
+lp_902715.patch
+lp_992262.patch
diff -Naur indicator-sound-0.8.5.0/.pc/lp_902715.patch/src/volume-widget.c indicator-sound-precise/.pc/lp_902715.patch/src/volume-widget.c
--- indicator-sound-0.8.5.0/.pc/lp_902715.patch/src/volume-widget.c	1969-12-31 16:00:00.000000000 -0800
+++ indicator-sound-precise/.pc/lp_902715.patch/src/volume-widget.c	2012-07-26 21:03:55.488143000 -0700
@@ -0,0 +1,319 @@
+
+/*
+Copyright 2010 Canonical Ltd.
+
+Authors:
+    Conor Curran <conor.curran@canonical.com>
+
+This program is free software: you can redistribute it and/or modify it 
+under the terms of the GNU General Public License version 3, as published 
+by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but 
+WITHOUT ANY WARRANTY; without even the implied warranties of 
+MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
+PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along 
+with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <glib/gi18n-lib.h>
+#include <math.h>
+#include <glib.h>
+#include "volume-widget.h"
+#include "common-defs.h"
+#include <libido/idoscalemenuitem.h>
+#include "indicator-sound.h"
+
+typedef struct _VolumeWidgetPrivate VolumeWidgetPrivate;
+
+struct _VolumeWidgetPrivate
+{
+  DbusmenuMenuitem* twin_item;  
+  GtkWidget* ido_volume_slider;
+  gboolean grabbed;
+  IndicatorObject* indicator;
+};
+
+#define VOLUME_WIDGET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), VOLUME_WIDGET_TYPE, VolumeWidgetPrivate))
+
+/* Prototypes */
+static void volume_widget_class_init (VolumeWidgetClass *klass);
+static void volume_widget_init       (VolumeWidget *self);
+static void volume_widget_dispose    (GObject *object);
+static void volume_widget_finalize   (GObject *object);
+static void volume_widget_set_twin_item( VolumeWidget* self,
+                                        DbusmenuMenuitem* twin_item);
+static void volume_widget_property_update( DbusmenuMenuitem* item, gchar* property, 
+                                           GVariant* value, gpointer userdata );
+
+static gboolean volume_widget_change_value_cb (GtkRange     *range,
+                                              GtkScrollType scroll,
+                                              gdouble       value,
+                                              gpointer      user_data);
+static void volume_widget_primary_clicked(GtkWidget *widget, gpointer user_data);
+static void volume_widget_secondary_clicked(GtkWidget *widget, gpointer user_data);
+static void volume_widget_slider_grabbed(GtkWidget *widget, gpointer user_data);
+static void volume_widget_slider_released(GtkWidget *widget, gpointer user_data);
+static void volume_widget_parent_changed (GtkWidget *widget, gpointer user_data);
+
+G_DEFINE_TYPE (VolumeWidget, volume_widget, G_TYPE_OBJECT);
+
+
+static void
+volume_widget_class_init (VolumeWidgetClass *klass)
+{
+  GObjectClass      *gobject_class = G_OBJECT_CLASS (klass);
+  
+  g_type_class_add_private (klass, sizeof (VolumeWidgetPrivate));
+
+  gobject_class->dispose = volume_widget_dispose;
+  gobject_class->finalize = volume_widget_finalize;
+}
+
+static void
+volume_widget_init (VolumeWidget *self)
+{
+  VolumeWidgetPrivate * priv = VOLUME_WIDGET_GET_PRIVATE(self);
+
+  priv->ido_volume_slider = ido_scale_menu_item_new_with_range ("VOLUME", IDO_RANGE_STYLE_DEFAULT,  0, 0, 100, 1);
+  g_object_ref (priv->ido_volume_slider);
+  ido_scale_menu_item_set_primary_label (IDO_SCALE_MENU_ITEM(priv->ido_volume_slider), "VOLUME");
+  ido_scale_menu_item_set_style (IDO_SCALE_MENU_ITEM (priv->ido_volume_slider), IDO_SCALE_MENU_ITEM_STYLE_IMAGE);
+  g_object_set(priv->ido_volume_slider, "reverse-scroll-events", TRUE, NULL);
+
+  g_signal_connect (priv->ido_volume_slider,
+                    "notify::parent", G_CALLBACK (volume_widget_parent_changed),
+                    NULL);
+  
+  GtkWidget* volume_widget = ido_scale_menu_item_get_scale((IdoScaleMenuItem*)priv->ido_volume_slider); 
+  
+  g_signal_connect(volume_widget, "change-value", G_CALLBACK(volume_widget_change_value_cb), self); 
+  g_signal_connect(priv->ido_volume_slider, "primary-clicked", G_CALLBACK(volume_widget_primary_clicked), self);
+  g_signal_connect(priv->ido_volume_slider, "secondary-clicked", G_CALLBACK(volume_widget_secondary_clicked), self);
+  g_signal_connect(priv->ido_volume_slider, "slider-grabbed", G_CALLBACK(volume_widget_slider_grabbed), self);
+  g_signal_connect(priv->ido_volume_slider, "slider-released", G_CALLBACK(volume_widget_slider_released), self);
+
+  GtkWidget* primary_image = ido_scale_menu_item_get_primary_image((IdoScaleMenuItem*)priv->ido_volume_slider);
+  GIcon * primary_gicon = g_themed_icon_new_with_default_fallbacks("audio-volume-low-zero-panel");
+  gtk_image_set_from_gicon(GTK_IMAGE(primary_image), primary_gicon, GTK_ICON_SIZE_MENU);
+  g_object_unref(primary_gicon);
+
+  GtkWidget* secondary_image = ido_scale_menu_item_get_secondary_image((IdoScaleMenuItem*)priv->ido_volume_slider);
+  GIcon * secondary_gicon = g_themed_icon_new_with_default_fallbacks("audio-volume-high-panel");
+  gtk_image_set_from_gicon(GTK_IMAGE(secondary_image), secondary_gicon, GTK_ICON_SIZE_MENU);
+  g_object_unref(secondary_gicon);
+
+  GtkAdjustment *adj = gtk_range_get_adjustment (GTK_RANGE (volume_widget));
+  gtk_adjustment_set_step_increment(adj, 4);
+}
+
+static void
+volume_widget_dispose (GObject *object)
+{
+  G_OBJECT_CLASS (volume_widget_parent_class)->dispose (object);
+}
+
+static void
+volume_widget_finalize (GObject *object)
+{
+  G_OBJECT_CLASS (volume_widget_parent_class)->finalize (object);
+}
+
+static void 
+volume_widget_property_update( DbusmenuMenuitem* item, gchar* property, 
+                               GVariant* value, gpointer userdata)
+{ 
+  g_return_if_fail (IS_VOLUME_WIDGET(userdata)); 
+  VolumeWidget* mitem = VOLUME_WIDGET(userdata);
+  VolumeWidgetPrivate * priv = VOLUME_WIDGET_GET_PRIVATE(mitem);
+
+  if(g_ascii_strcasecmp(DBUSMENU_VOLUME_MENUITEM_LEVEL, property) == 0){
+    g_return_if_fail (g_variant_is_of_type (value, G_VARIANT_TYPE_DOUBLE) );
+    if(priv->grabbed == FALSE){
+      GtkWidget *slider = ido_scale_menu_item_get_scale((IdoScaleMenuItem*)priv->ido_volume_slider);
+      GtkRange *range = (GtkRange*)slider;
+      gdouble update = g_variant_get_double (value);
+      gtk_range_set_value(range, update);
+/*
+      g_debug ("volume-widget::volume_widget_property_update - volume - value %f", update);
+*/
+      update_accessible_desc(priv->indicator);
+    }
+  }
+  else if(g_ascii_strcasecmp(DBUSMENU_VOLUME_MENUITEM_MUTE, property) == 0){
+    g_return_if_fail (g_variant_is_of_type (value, G_VARIANT_TYPE_BOOLEAN));
+    if(priv->grabbed == FALSE){
+      GtkWidget *slider = ido_scale_menu_item_get_scale((IdoScaleMenuItem*)priv->ido_volume_slider);
+      GtkRange *range = (GtkRange*)slider;
+      gboolean update = g_variant_get_boolean (value);
+      gdouble level;
+
+      if (update == TRUE){
+        level = 0;
+      }
+      else{
+        GVariant* variant = dbusmenu_menuitem_property_get_variant (priv->twin_item,
+                                                                    DBUSMENU_VOLUME_MENUITEM_LEVEL);
+/*
+        g_debug ("variant for the volume - is it null = %i", variant == NULL);
+*/
+        g_return_if_fail (g_variant_is_of_type (variant, G_VARIANT_TYPE_DOUBLE) );
+
+        level = g_variant_get_double (variant);
+      }
+/*
+      g_debug ("volume-widget::volume_widget_property_update - mute - value %i and level = %f", update, level);
+*/
+      gtk_range_set_value(range, level);
+    }
+  }
+}
+
+static void
+volume_widget_set_twin_item(VolumeWidget* self,
+                           DbusmenuMenuitem* twin_item)
+{
+  VolumeWidgetPrivate * priv = VOLUME_WIDGET_GET_PRIVATE(self);
+  priv->twin_item = twin_item;
+  g_object_ref(priv->twin_item);
+  g_signal_connect(G_OBJECT(twin_item), "property-changed", 
+                   G_CALLBACK(volume_widget_property_update), self);
+  gdouble initial_level = g_variant_get_double (dbusmenu_menuitem_property_get_variant(twin_item,
+                                                DBUSMENU_VOLUME_MENUITEM_LEVEL));
+  gboolean initial_mute = g_variant_get_boolean (dbusmenu_menuitem_property_get_variant(twin_item,
+                                                 DBUSMENU_VOLUME_MENUITEM_MUTE));
+
+  //g_debug("volume_widget_set_twin_item initial level = %f", initial_level);
+  GtkWidget *slider = ido_scale_menu_item_get_scale((IdoScaleMenuItem*)priv->ido_volume_slider);
+  GtkRange *range = (GtkRange*)slider;
+  if(initial_mute == TRUE){
+    initial_level = 0;
+  }
+  gtk_range_set_value(range, initial_level);
+}
+
+static gboolean
+volume_widget_change_value_cb (GtkRange     *range,
+                               GtkScrollType scroll,
+                               gdouble       new_value,
+                               gpointer      user_data)
+{
+  g_return_val_if_fail (IS_VOLUME_WIDGET (user_data), FALSE);
+  VolumeWidget* mitem = VOLUME_WIDGET(user_data);
+
+/*
+  g_debug ("changed value %f", new_value);
+*/
+
+  volume_widget_update(mitem, new_value, "change-value");
+  return FALSE;
+}
+
+void 
+volume_widget_update(VolumeWidget* self, gdouble update, gchar* label)
+{
+  gchar* source = NULL;
+  source = label;
+  if (label == NULL){
+    source = "v widget update";
+  }
+  VolumeWidgetPrivate * priv = VOLUME_WIDGET_GET_PRIVATE(self);
+  gdouble clamped = CLAMP(update, 0, 100);
+  GVariant* new_volume = g_variant_new_double(clamped);
+  dbusmenu_menuitem_handle_event (priv->twin_item, source, new_volume, 0);
+}
+
+static void
+volume_widget_update_from_scale (VolumeWidget *self)
+{
+  g_return_if_fail (IS_VOLUME_WIDGET (self));
+
+  VolumeWidgetPrivate * priv = VOLUME_WIDGET_GET_PRIVATE(self);
+  GtkWidget *slider = ido_scale_menu_item_get_scale((IdoScaleMenuItem*)priv->ido_volume_slider);
+  const gdouble current_value = CLAMP(gtk_range_get_value(GTK_RANGE(slider)), 0, 100);
+  g_debug ("%s - setting value to %.0f", G_STRFUNC, current_value);
+  volume_widget_update (self, current_value, "value-changed");
+}
+
+static void
+volume_widget_primary_clicked (GtkWidget *widget G_GNUC_UNUSED, gpointer user_data)
+{
+  volume_widget_update_from_scale (VOLUME_WIDGET(user_data));
+}
+
+static void
+volume_widget_secondary_clicked(GtkWidget *widget, gpointer user_data)
+{
+  volume_widget_update_from_scale (VOLUME_WIDGET(user_data));
+}
+
+GtkWidget*
+volume_widget_get_ido_slider(VolumeWidget* self)
+{
+  VolumeWidgetPrivate * priv = VOLUME_WIDGET_GET_PRIVATE(self);
+  return priv->ido_volume_slider; 
+}
+
+static void
+volume_widget_parent_changed (GtkWidget *widget,
+                              gpointer   user_data)
+{
+  gtk_widget_set_size_request (widget, 200, -1);
+  //g_debug("volume_widget_parent_changed");
+}
+
+static void
+volume_widget_slider_grabbed(GtkWidget *widget, gpointer user_data)
+{
+  VolumeWidget* mitem = VOLUME_WIDGET(user_data);
+  VolumeWidgetPrivate * priv = VOLUME_WIDGET_GET_PRIVATE(mitem);
+  priv->grabbed = TRUE; 
+}
+
+static void
+volume_widget_slider_released(GtkWidget *widget, gpointer user_data)
+{
+  VolumeWidget* mitem = VOLUME_WIDGET(user_data);
+  VolumeWidgetPrivate * priv = VOLUME_WIDGET_GET_PRIVATE(mitem);
+  priv->grabbed = FALSE;
+}
+
+void
+volume_widget_tidy_up (GtkWidget *widget)
+{
+  VolumeWidget* mitem = VOLUME_WIDGET(widget);
+  VolumeWidgetPrivate * priv = VOLUME_WIDGET_GET_PRIVATE(mitem);
+  gtk_widget_destroy (priv->ido_volume_slider);
+}
+
+gdouble
+volume_widget_get_current_volume ( GtkWidget *widget )
+{
+  VolumeWidget* mitem = VOLUME_WIDGET(widget);
+  VolumeWidgetPrivate * priv = VOLUME_WIDGET_GET_PRIVATE(mitem);
+  gdouble vol = g_variant_get_double(  dbusmenu_menuitem_property_get_variant( priv->twin_item,
+                                                                               DBUSMENU_VOLUME_MENUITEM_LEVEL));  
+  return vol;
+}
+
+/**
+ * volume_widget_new:
+ * @returns: a new #VolumeWidget.
+ **/
+GtkWidget*
+volume_widget_new(DbusmenuMenuitem *item, IndicatorObject* io)
+{
+  GtkWidget* widget = g_object_new(VOLUME_WIDGET_TYPE, NULL);
+  VolumeWidgetPrivate* priv = VOLUME_WIDGET_GET_PRIVATE(VOLUME_WIDGET(widget));
+  priv->indicator = io;
+  volume_widget_set_twin_item((VolumeWidget*)widget, item);
+  return widget;
+}
+
+
diff -Naur indicator-sound-0.8.5.0/.pc/lp_992262.patch/src/music-player-bridge.c indicator-sound-precise/.pc/lp_992262.patch/src/music-player-bridge.c
--- indicator-sound-0.8.5.0/.pc/lp_992262.patch/src/music-player-bridge.c	1969-12-31 16:00:00.000000000 -0800
+++ indicator-sound-precise/.pc/lp_992262.patch/src/music-player-bridge.c	2012-07-26 21:03:55.488143000 -0700
@@ -0,0 +1,1420 @@
+/* music-player-bridge.c generated by valac 0.14.2, the Vala compiler
+ * generated from music-player-bridge.vala, do not modify */
+
+/*
+Copyright 2010 Canonical Ltd.
+
+Authors:
+    Conor Curran <conor.curran@canonical.com>
+
+This program is free software: you can redistribute it and/or modify it 
+under the terms of the GNU General Public License version 3, as published 
+by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but 
+WITHOUT ANY WARRANTY; without even the implied warranties of 
+MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
+PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along 
+with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <glib.h>
+#include <glib-object.h>
+#include <libdbusmenu-glib/client.h>
+#include <libdbusmenu-glib/dbusmenu-glib.h>
+#include <libdbusmenu-glib/enum-types.h>
+#include <libdbusmenu-glib/menuitem-proxy.h>
+#include <libdbusmenu-glib/menuitem.h>
+#include <libdbusmenu-glib/server.h>
+#include <libdbusmenu-glib/types.h>
+#include <gee.h>
+#include <stdlib.h>
+#include <string.h>
+#include <gio/gio.h>
+#include <gio/gdesktopappinfo.h>
+
+
+#define TYPE_MUSIC_PLAYER_BRIDGE (music_player_bridge_get_type ())
+#define MUSIC_PLAYER_BRIDGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MUSIC_PLAYER_BRIDGE, MusicPlayerBridge))
+#define MUSIC_PLAYER_BRIDGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MUSIC_PLAYER_BRIDGE, MusicPlayerBridgeClass))
+#define IS_MUSIC_PLAYER_BRIDGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MUSIC_PLAYER_BRIDGE))
+#define IS_MUSIC_PLAYER_BRIDGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MUSIC_PLAYER_BRIDGE))
+#define MUSIC_PLAYER_BRIDGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MUSIC_PLAYER_BRIDGE, MusicPlayerBridgeClass))
+
+typedef struct _MusicPlayerBridge MusicPlayerBridge;
+typedef struct _MusicPlayerBridgeClass MusicPlayerBridgeClass;
+typedef struct _MusicPlayerBridgePrivate MusicPlayerBridgePrivate;
+
+#define TYPE_SETTINGS_MANAGER (settings_manager_get_type ())
+#define SETTINGS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SETTINGS_MANAGER, SettingsManager))
+#define SETTINGS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SETTINGS_MANAGER, SettingsManagerClass))
+#define IS_SETTINGS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SETTINGS_MANAGER))
+#define IS_SETTINGS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SETTINGS_MANAGER))
+#define SETTINGS_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SETTINGS_MANAGER, SettingsManagerClass))
+
+typedef struct _SettingsManager SettingsManager;
+typedef struct _SettingsManagerClass SettingsManagerClass;
+
+#define TYPE_PLAYER_CONTROLLER (player_controller_get_type ())
+#define PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONTROLLER, PlayerController))
+#define PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
+#define IS_PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONTROLLER))
+#define IS_PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONTROLLER))
+#define PLAYER_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
+
+typedef struct _PlayerController PlayerController;
+typedef struct _PlayerControllerClass PlayerControllerClass;
+
+#define TYPE_MPRIS2_WATCHER (mpris2_watcher_get_type ())
+#define MPRIS2_WATCHER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS2_WATCHER, Mpris2Watcher))
+#define MPRIS2_WATCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS2_WATCHER, Mpris2WatcherClass))
+#define IS_MPRIS2_WATCHER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS2_WATCHER))
+#define IS_MPRIS2_WATCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS2_WATCHER))
+#define MPRIS2_WATCHER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS2_WATCHER, Mpris2WatcherClass))
+
+typedef struct _Mpris2Watcher Mpris2Watcher;
+typedef struct _Mpris2WatcherClass Mpris2WatcherClass;
+#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
+#define _g_free0(var) (var = (g_free (var), NULL))
+
+#define PLAYER_CONTROLLER_TYPE_STATE (player_controller_state_get_type ())
+typedef struct _Block1Data Block1Data;
+#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
+typedef struct _PlayerControllerPrivate PlayerControllerPrivate;
+
+#define TYPE_PLAYER_ITEM (player_item_get_type ())
+#define PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_ITEM, PlayerItem))
+#define PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_ITEM, PlayerItemClass))
+#define IS_PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_ITEM))
+#define IS_PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_ITEM))
+#define PLAYER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_ITEM, PlayerItemClass))
+
+typedef struct _PlayerItem PlayerItem;
+typedef struct _PlayerItemClass PlayerItemClass;
+
+#define TYPE_MPRIS2_CONTROLLER (mpris2_controller_get_type ())
+#define MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2Controller))
+#define MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
+#define IS_MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS2_CONTROLLER))
+#define IS_MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS2_CONTROLLER))
+#define MPRIS2_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
+
+typedef struct _Mpris2Controller Mpris2Controller;
+typedef struct _Mpris2ControllerClass Mpris2ControllerClass;
+#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))
+
+struct _MusicPlayerBridge {
+	GObject parent_instance;
+	MusicPlayerBridgePrivate * priv;
+};
+
+struct _MusicPlayerBridgeClass {
+	GObjectClass parent_class;
+};
+
+struct _MusicPlayerBridgePrivate {
+	SettingsManager* settings_manager;
+	DbusmenuMenuitem* root_menu;
+	GeeHashMap* registered_clients;
+	GeeHashMap* file_monitors;
+	Mpris2Watcher* watcher;
+};
+
+typedef enum  {
+	PLAYER_CONTROLLER_STATE_OFFLINE,
+	PLAYER_CONTROLLER_STATE_INSTANTIATING,
+	PLAYER_CONTROLLER_STATE_READY,
+	PLAYER_CONTROLLER_STATE_CONNECTED,
+	PLAYER_CONTROLLER_STATE_DISCONNECTED
+} PlayerControllerstate;
+
+struct _Block1Data {
+	int _ref_count_;
+	MusicPlayerBridge * self;
+	GFileMonitor* weak_monitor;
+};
+
+struct _PlayerController {
+	GObject parent_instance;
+	PlayerControllerPrivate * priv;
+	gint current_state;
+	DbusmenuMenuitem* root_menu;
+	GeeArrayList* custom_items;
+	Mpris2Controller* mpris_bridge;
+	gboolean* use_playlists;
+};
+
+struct _PlayerControllerClass {
+	GObjectClass parent_class;
+};
+
+
+static gpointer music_player_bridge_parent_class = NULL;
+
+GType music_player_bridge_get_type (void) G_GNUC_CONST;
+GType settings_manager_get_type (void) G_GNUC_CONST;
+GType player_controller_get_type (void) G_GNUC_CONST;
+GType mpris2_watcher_get_type (void) G_GNUC_CONST;
+#define MUSIC_PLAYER_BRIDGE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MUSIC_PLAYER_BRIDGE, MusicPlayerBridgePrivate))
+enum  {
+	MUSIC_PLAYER_BRIDGE_DUMMY_PROPERTY
+};
+#define MUSIC_PLAYER_BRIDGE_DEVICE_ITEMS_COUNT 3
+MusicPlayerBridge* music_player_bridge_new (void);
+MusicPlayerBridge* music_player_bridge_construct (GType object_type);
+static void music_player_bridge_on_blacklist_update (MusicPlayerBridge* self, gchar** blacklist, int blacklist_length1);
+static gchar* music_player_bridge_determine_key (gchar* desktop_or_interface);
+void player_controller_remove_from_menu (PlayerController* self);
+void mpris2_watcher_check_for_active_clients (Mpris2Watcher* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
+void mpris2_watcher_check_for_active_clients_finish (Mpris2Watcher* self, GAsyncResult* _res_);
+static void music_player_bridge_try_to_add_inactive_familiar_clients (MusicPlayerBridge* self);
+GeeArrayList* settings_manager_fetch_interested (SettingsManager* self);
+static GAppInfo* music_player_bridge_create_app_info (const gchar* desktop);
+static gchar* music_player_bridge_fetch_icon_name (const gchar* desktop);
+static gint music_player_bridge_calculate_menu_position (MusicPlayerBridge* self);
+GType player_controller_state_get_type (void) G_GNUC_CONST;
+PlayerController* player_controller_new (DbusmenuMenuitem* root, GAppInfo* app, const gchar* dbus_name, const gchar* icon_name, gint offset, gboolean* use_playlists, PlayerControllerstate initial_state);
+PlayerController* player_controller_construct (GType object_type, DbusmenuMenuitem* root, GAppInfo* app, const gchar* dbus_name, const gchar* icon_name, gint offset, gboolean* use_playlists, PlayerControllerstate initial_state);
+static void music_player_bridge_establish_file_monitoring (MusicPlayerBridge* self, GAppInfo* info, const gchar* mpris_key);
+static Block1Data* block1_data_ref (Block1Data* _data1_);
+static void block1_data_unref (Block1Data* _data1_);
+static void ___lambda2_ (Block1Data* _data1_, GFile* desktop_file, GFile* other_file, GFileMonitorEvent event_type);
+static void music_player_bridge_relevant_desktop_file_changed (MusicPlayerBridge* self, GFile* desktop_file, GFile* other_file, GFileMonitorEvent event_type, GFileMonitor* monitor);
+static void ____lambda2__g_file_monitor_changed (GFileMonitor* _sender, GFile* file, GFile* other_file, GFileMonitorEvent event_type, gpointer self);
+void settings_manager_remove_interested (SettingsManager* self, const gchar* app_desktop_name);
+#define PLAYER_CONTROLLER_WIDGET_QUANTITY 4
+void music_player_bridge_client_has_become_available (MusicPlayerBridge* self, const gchar* desktop, const gchar* dbus_name, gboolean use_playlists);
+gchar** settings_manager_fetch_blacklist (SettingsManager* self, int* result_length1);
+static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle);
+void settings_manager_add_interested (SettingsManager* self, const gchar* app_desktop_name);
+static gboolean* _bool_dup (gboolean* self);
+GType player_item_get_type (void) G_GNUC_CONST;
+GType mpris2_controller_get_type (void) G_GNUC_CONST;
+void player_controller_update_state (PlayerController* self, PlayerControllerstate new_state);
+void player_controller_activate (PlayerController* self, const gchar* dbus_name);
+void music_player_bridge_client_has_vanished (MusicPlayerBridge* self, const gchar* mpris_root_interface);
+void player_controller_hibernate (PlayerController* self);
+void music_player_bridge_set_root_menu_item (MusicPlayerBridge* self, DbusmenuMenuitem* menu);
+Mpris2Watcher* mpris2_watcher_new (void);
+Mpris2Watcher* mpris2_watcher_construct (GType object_type);
+static void _music_player_bridge_client_has_become_available_mpris2_watcher_client_appeared (Mpris2Watcher* _sender, const gchar* desktop_file_name, const gchar* dbus_name, gboolean use_playlists, gpointer self);
+static void _music_player_bridge_client_has_vanished_mpris2_watcher_client_disappeared (Mpris2Watcher* _sender, const gchar* dbus_name, gpointer self);
+void music_player_bridge_enable_player_specific_items_for_client (MusicPlayerBridge* self, const gchar* object_path, const gchar* desktop_id);
+void player_controller_enable_player_specific_items (PlayerController* self, const gchar* object_path);
+void music_player_bridge_enable_track_specific_items_for_client (MusicPlayerBridge* self, const gchar* object_path, const gchar* desktop_id);
+void player_controller_enable_track_specific_items (PlayerController* self, const gchar* object_path);
+static GObject * music_player_bridge_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
+SettingsManager* settings_manager_new (void);
+SettingsManager* settings_manager_construct (GType object_type);
+static void _music_player_bridge_on_blacklist_update_settings_manager_blacklist_updates (SettingsManager* _sender, gchar** new_blacklist, int new_blacklist_length1, gpointer self);
+static void music_player_bridge_finalize (GObject* obj);
+static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
+static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
+static gint _vala_array_length (gpointer array);
+
+
+MusicPlayerBridge* music_player_bridge_construct (GType object_type) {
+	MusicPlayerBridge * self = NULL;
+	self = (MusicPlayerBridge*) g_object_new (object_type, NULL);
+	return self;
+}
+
+
+MusicPlayerBridge* music_player_bridge_new (void) {
+	return music_player_bridge_construct (TYPE_MUSIC_PLAYER_BRIDGE);
+}
+
+
+static void music_player_bridge_on_blacklist_update (MusicPlayerBridge* self, gchar** blacklist, int blacklist_length1) {
+	gchar** _tmp0_;
+	gint _tmp0__length1;
+	Mpris2Watcher* _tmp15_;
+	g_return_if_fail (self != NULL);
+	g_debug ("music-player-bridge.vala:47: some blacklist update");
+	_tmp0_ = blacklist;
+	_tmp0__length1 = blacklist_length1;
+	{
+		gchar** s_collection = NULL;
+		gint s_collection_length1 = 0;
+		gint _s_collection_size_ = 0;
+		gint s_it = 0;
+		s_collection = _tmp0_;
+		s_collection_length1 = _tmp0__length1;
+		for (s_it = 0; s_it < _tmp0__length1; s_it = s_it + 1) {
+			gchar* _tmp1_;
+			gchar* s = NULL;
+			_tmp1_ = g_strdup (s_collection[s_it]);
+			s = _tmp1_;
+			{
+				const gchar* _tmp2_;
+				gchar* _tmp3_;
+				gchar* _tmp4_ = NULL;
+				gchar* key;
+				GeeHashMap* _tmp5_;
+				const gchar* _tmp6_;
+				gboolean _tmp7_ = FALSE;
+				_tmp2_ = s;
+				_tmp3_ = g_strdup (_tmp2_);
+				_tmp4_ = music_player_bridge_determine_key (_tmp3_);
+				key = _tmp4_;
+				_tmp5_ = self->priv->registered_clients;
+				_tmp6_ = key;
+				_tmp7_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp5_, _tmp6_);
+				if (_tmp7_) {
+					const gchar* _tmp8_;
+					GeeHashMap* _tmp9_;
+					const gchar* _tmp10_;
+					gpointer _tmp11_ = NULL;
+					PlayerController* _tmp12_;
+					GeeHashMap* _tmp13_;
+					const gchar* _tmp14_;
+					_tmp8_ = key;
+					g_debug ("music-player-bridge.vala:52: Apparently %s is now blacklisted - remove" \
+" thy self", _tmp8_);
+					_tmp9_ = self->priv->registered_clients;
+					_tmp10_ = key;
+					_tmp11_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp9_, _tmp10_);
+					_tmp12_ = (PlayerController*) _tmp11_;
+					player_controller_remove_from_menu (_tmp12_);
+					_g_object_unref0 (_tmp12_);
+					_tmp13_ = self->priv->registered_clients;
+					_tmp14_ = key;
+					gee_abstract_map_unset ((GeeAbstractMap*) _tmp13_, _tmp14_, NULL);
+				}
+				_g_free0 (key);
+				_g_free0 (s);
+			}
+		}
+	}
+	_tmp15_ = self->priv->watcher;
+	mpris2_watcher_check_for_active_clients (_tmp15_, NULL, NULL);
+}
+
+
+static void music_player_bridge_try_to_add_inactive_familiar_clients (MusicPlayerBridge* self) {
+	g_return_if_fail (self != NULL);
+	{
+		SettingsManager* _tmp0_;
+		GeeArrayList* _tmp1_ = NULL;
+		GeeArrayList* _desktop_list;
+		GeeArrayList* _tmp2_;
+		gint _tmp3_;
+		gint _tmp4_;
+		gint _desktop_size;
+		gint _desktop_index;
+		_tmp0_ = self->priv->settings_manager;
+		_tmp1_ = settings_manager_fetch_interested (_tmp0_);
+		_desktop_list = _tmp1_;
+		_tmp2_ = _desktop_list;
+		_tmp3_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp2_);
+		_tmp4_ = _tmp3_;
+		_desktop_size = _tmp4_;
+		_desktop_index = -1;
+		while (TRUE) {
+			gint _tmp5_;
+			gint _tmp6_;
+			gint _tmp7_;
+			GeeArrayList* _tmp8_;
+			gint _tmp9_;
+			gpointer _tmp10_ = NULL;
+			gchar* desktop;
+			const gchar* _tmp11_;
+			const gchar* _tmp12_;
+			gchar* _tmp13_ = NULL;
+			gchar* _tmp14_;
+			GAppInfo* _tmp15_ = NULL;
+			GAppInfo* _tmp16_;
+			GAppInfo* app_info;
+			GAppInfo* _tmp17_;
+			const gchar* _tmp19_;
+			gchar* _tmp20_;
+			gchar* _tmp21_ = NULL;
+			gchar* mpris_key;
+			DbusmenuMenuitem* _tmp22_;
+			GAppInfo* _tmp23_;
+			const gchar* _tmp24_;
+			gchar* _tmp25_ = NULL;
+			gchar* _tmp26_;
+			gint _tmp27_ = 0;
+			PlayerController* _tmp28_;
+			PlayerController* _tmp29_;
+			PlayerController* ctrl;
+			GeeHashMap* _tmp30_;
+			const gchar* _tmp31_;
+			PlayerController* _tmp32_;
+			GAppInfo* _tmp33_;
+			const gchar* _tmp34_;
+			_tmp5_ = _desktop_index;
+			_desktop_index = _tmp5_ + 1;
+			_tmp6_ = _desktop_index;
+			_tmp7_ = _desktop_size;
+			if (!(_tmp6_ < _tmp7_)) {
+				break;
+			}
+			_tmp8_ = _desktop_list;
+			_tmp9_ = _desktop_index;
+			_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, _tmp9_);
+			desktop = (gchar*) _tmp10_;
+			_tmp11_ = desktop;
+			g_debug ("music-player-bridge.vala:64: interested client found : %s", _tmp11_);
+			_tmp12_ = desktop;
+			_tmp13_ = g_strconcat (_tmp12_, ".desktop", NULL);
+			_tmp14_ = _tmp13_;
+			_tmp15_ = music_player_bridge_create_app_info (_tmp14_);
+			_tmp16_ = _tmp15_;
+			_g_free0 (_tmp14_);
+			app_info = _tmp16_;
+			_tmp17_ = app_info;
+			if (_tmp17_ == NULL) {
+				const gchar* _tmp18_;
+				_tmp18_ = desktop;
+				g_warning ("music-player-bridge.vala:67: Could not create app_info for path %s \n" \
+" Getting out of here ", _tmp18_);
+				_g_object_unref0 (app_info);
+				_g_free0 (desktop);
+				continue;
+			}
+			_tmp19_ = desktop;
+			_tmp20_ = g_strdup (_tmp19_);
+			_tmp21_ = music_player_bridge_determine_key (_tmp20_);
+			mpris_key = _tmp21_;
+			_tmp22_ = self->priv->root_menu;
+			_tmp23_ = app_info;
+			_tmp24_ = desktop;
+			_tmp25_ = music_player_bridge_fetch_icon_name (_tmp24_);
+			_tmp26_ = _tmp25_;
+			_tmp27_ = music_player_bridge_calculate_menu_position (self);
+			_tmp28_ = player_controller_new (_tmp22_, _tmp23_, NULL, _tmp26_, _tmp27_, NULL, PLAYER_CONTROLLER_STATE_OFFLINE);
+			_tmp29_ = _tmp28_;
+			_g_free0 (_tmp26_);
+			ctrl = _tmp29_;
+			_tmp30_ = self->priv->registered_clients;
+			_tmp31_ = mpris_key;
+			_tmp32_ = ctrl;
+			gee_abstract_map_set ((GeeAbstractMap*) _tmp30_, _tmp31_, _tmp32_);
+			_tmp33_ = app_info;
+			_tmp34_ = mpris_key;
+			music_player_bridge_establish_file_monitoring (self, _tmp33_, _tmp34_);
+			_g_object_unref0 (ctrl);
+			_g_free0 (mpris_key);
+			_g_object_unref0 (app_info);
+			_g_free0 (desktop);
+		}
+		_g_object_unref0 (_desktop_list);
+	}
+}
+
+
+static gpointer _g_object_ref0 (gpointer self) {
+	return self ? g_object_ref (self) : NULL;
+}
+
+
+static Block1Data* block1_data_ref (Block1Data* _data1_) {
+	g_atomic_int_inc (&_data1_->_ref_count_);
+	return _data1_;
+}
+
+
+static void block1_data_unref (Block1Data* _data1_) {
+	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
+		_g_object_unref0 (_data1_->self);
+		g_slice_free (Block1Data, _data1_);
+	}
+}
+
+
+static void ___lambda2_ (Block1Data* _data1_, GFile* desktop_file, GFile* other_file, GFileMonitorEvent event_type) {
+	MusicPlayerBridge * self;
+	GFile* _tmp0_;
+	GFile* _tmp1_;
+	GFileMonitorEvent _tmp2_;
+	GFileMonitor* _tmp3_;
+	self = _data1_->self;
+	g_return_if_fail (desktop_file != NULL);
+	_tmp0_ = desktop_file;
+	_tmp1_ = other_file;
+	_tmp2_ = event_type;
+	_tmp3_ = _data1_->weak_monitor;
+	music_player_bridge_relevant_desktop_file_changed (self, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
+}
+
+
+static void ____lambda2__g_file_monitor_changed (GFileMonitor* _sender, GFile* file, GFile* other_file, GFileMonitorEvent event_type, gpointer self) {
+	___lambda2_ (self, file, other_file, event_type);
+}
+
+
+static void music_player_bridge_establish_file_monitoring (MusicPlayerBridge* self, GAppInfo* info, const gchar* mpris_key) {
+	GAppInfo* _tmp0_;
+	GDesktopAppInfo* _tmp1_;
+	GDesktopAppInfo* desktop_info;
+	GDesktopAppInfo* _tmp2_;
+	const gchar* _tmp3_ = NULL;
+	gchar* _tmp4_;
+	gchar* file_path;
+	const gchar* _tmp5_;
+	GFile* _tmp6_ = NULL;
+	GFile* f;
+	GError * _inner_error_ = NULL;
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (info != NULL);
+	g_return_if_fail (mpris_key != NULL);
+	_tmp0_ = info;
+	_tmp1_ = _g_object_ref0 (G_IS_DESKTOP_APP_INFO (_tmp0_) ? ((GDesktopAppInfo*) _tmp0_) : NULL);
+	desktop_info = _tmp1_;
+	_tmp2_ = desktop_info;
+	_tmp3_ = g_desktop_app_info_get_filename (_tmp2_);
+	_tmp4_ = g_strdup (_tmp3_);
+	file_path = _tmp4_;
+	_tmp5_ = file_path;
+	_tmp6_ = g_file_new_for_path (_tmp5_);
+	f = _tmp6_;
+	{
+		Block1Data* _data1_;
+		GFile* _tmp7_;
+		GFileMonitor* _tmp8_ = NULL;
+		GFileMonitor* _tmp9_;
+		GFileMonitor* monitor;
+		GFileMonitor* _tmp10_;
+		GFileMonitor* _tmp11_;
+		GFileMonitor* _tmp12_;
+		const gchar* _tmp13_;
+		GeeHashMap* _tmp14_;
+		const gchar* _tmp15_;
+		const gchar* _tmp16_;
+		_data1_ = g_slice_new0 (Block1Data);
+		_data1_->_ref_count_ = 1;
+		_data1_->self = g_object_ref (self);
+		_tmp7_ = f;
+		_tmp8_ = g_file_monitor (_tmp7_, G_FILE_MONITOR_SEND_MOVED, NULL, &_inner_error_);
+		_tmp9_ = _g_object_ref0 (_tmp8_);
+		monitor = _tmp9_;
+		if (_inner_error_ != NULL) {
+			block1_data_unref (_data1_);
+			_data1_ = NULL;
+			goto __catch0_g_error;
+		}
+		_tmp10_ = monitor;
+		_data1_->weak_monitor = _tmp10_;
+		_tmp11_ = monitor;
+		g_signal_connect_data (_tmp11_, "changed", (GCallback) ____lambda2__g_file_monitor_changed, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
+		_tmp12_ = monitor;
+		g_object_ref ((GObject*) _tmp12_);
+		_tmp13_ = file_path;
+		g_debug ("music-player-bridge.vala:95: monitoring file '%s'", _tmp13_);
+		_tmp14_ = self->priv->file_monitors;
+		_tmp15_ = file_path;
+		_tmp16_ = mpris_key;
+		gee_abstract_map_set ((GeeAbstractMap*) _tmp14_, _tmp15_, _tmp16_);
+		_g_object_unref0 (monitor);
+		block1_data_unref (_data1_);
+		_data1_ = NULL;
+	}
+	goto __finally0;
+	__catch0_g_error:
+	{
+		GError* e = NULL;
+		GAppInfo* _tmp17_;
+		const gchar* _tmp18_ = NULL;
+		e = _inner_error_;
+		_inner_error_ = NULL;
+		_tmp17_ = info;
+		_tmp18_ = g_app_info_get_name (_tmp17_);
+		g_warning ("music-player-bridge.vala:99: Unable to create a file monitor for %s", _tmp18_);
+		_g_error_free0 (e);
+		_g_object_unref0 (f);
+		_g_free0 (file_path);
+		_g_object_unref0 (desktop_info);
+		return;
+	}
+	__finally0:
+	if (_inner_error_ != NULL) {
+		_g_object_unref0 (f);
+		_g_free0 (file_path);
+		_g_object_unref0 (desktop_info);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+		g_clear_error (&_inner_error_);
+		return;
+	}
+	_g_object_unref0 (f);
+	_g_free0 (file_path);
+	_g_object_unref0 (desktop_info);
+}
+
+
+static void music_player_bridge_relevant_desktop_file_changed (MusicPlayerBridge* self, GFile* desktop_file, GFile* other_file, GFileMonitorEvent event_type, GFileMonitor* monitor) {
+	GFileMonitorEvent _tmp0_;
+	GFile* _tmp1_;
+	gchar* _tmp2_ = NULL;
+	gchar* path;
+	const gchar* _tmp3_;
+	GeeHashMap* _tmp4_;
+	const gchar* _tmp5_;
+	gboolean _tmp6_ = FALSE;
+	GeeHashMap* _tmp8_;
+	const gchar* _tmp9_;
+	gpointer _tmp10_ = NULL;
+	gchar* mpris_key;
+	const gchar* _tmp11_;
+	const gchar* _tmp12_;
+	GeeHashMap* _tmp13_;
+	const gchar* _tmp14_;
+	gpointer _tmp15_ = NULL;
+	PlayerController* _tmp16_;
+	SettingsManager* _tmp17_;
+	const gchar* _tmp18_;
+	GeeHashMap* _tmp19_;
+	const gchar* _tmp20_;
+	GFileMonitor* _tmp21_;
+	GFileMonitor* _tmp22_;
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (desktop_file != NULL);
+	g_return_if_fail (monitor != NULL);
+	_tmp0_ = event_type;
+	if (_tmp0_ != G_FILE_MONITOR_EVENT_DELETED) {
+		return;
+	}
+	_tmp1_ = desktop_file;
+	_tmp2_ = g_file_get_path (_tmp1_);
+	path = _tmp2_;
+	_tmp3_ = path;
+	if (_tmp3_ == NULL) {
+		g_warning ("music-player-bridge.vala:114: relevant_desktop_file_changed is returni" \
+"ng a file with no path !");
+		_g_free0 (path);
+		return;
+	}
+	_tmp4_ = self->priv->file_monitors;
+	_tmp5_ = path;
+	_tmp6_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp4_, _tmp5_);
+	if (!_tmp6_) {
+		const gchar* _tmp7_;
+		_tmp7_ = path;
+		g_warning ("music-player-bridge.vala:118: relevant_desktop_file_changed is returni" \
+"ng a file which we know nothing about - %s", _tmp7_);
+		_g_free0 (path);
+		return;
+	}
+	_tmp8_ = self->priv->file_monitors;
+	_tmp9_ = path;
+	_tmp10_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp8_, _tmp9_);
+	mpris_key = (gchar*) _tmp10_;
+	_tmp11_ = path;
+	_tmp12_ = mpris_key;
+	g_debug ("music-player-bridge.vala:124: file \"%s\" was removed; stopping monito" \
+"ring \"%s\"", _tmp11_, _tmp12_);
+	_tmp13_ = self->priv->registered_clients;
+	_tmp14_ = mpris_key;
+	_tmp15_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp13_, _tmp14_);
+	_tmp16_ = (PlayerController*) _tmp15_;
+	player_controller_remove_from_menu (_tmp16_);
+	_g_object_unref0 (_tmp16_);
+	_tmp17_ = self->priv->settings_manager;
+	_tmp18_ = mpris_key;
+	settings_manager_remove_interested (_tmp17_, _tmp18_);
+	_tmp19_ = self->priv->registered_clients;
+	_tmp20_ = mpris_key;
+	gee_abstract_map_unset ((GeeAbstractMap*) _tmp19_, _tmp20_, NULL);
+	_tmp21_ = monitor;
+	g_file_monitor_cancel (_tmp21_);
+	_tmp22_ = monitor;
+	g_object_unref ((GObject*) _tmp22_);
+	_g_free0 (mpris_key);
+	_g_free0 (path);
+}
+
+
+static gint music_player_bridge_calculate_menu_position (MusicPlayerBridge* self) {
+	gint result = 0;
+	GeeHashMap* _tmp0_;
+	gint _tmp1_;
+	gint _tmp2_;
+	g_return_val_if_fail (self != NULL, 0);
+	_tmp0_ = self->priv->registered_clients;
+	_tmp1_ = gee_abstract_map_get_size ((GeeMap*) _tmp0_);
+	_tmp2_ = _tmp1_;
+	if (_tmp2_ == 0) {
+		result = MUSIC_PLAYER_BRIDGE_DEVICE_ITEMS_COUNT;
+		return result;
+	} else {
+		GeeHashMap* _tmp3_;
+		gint _tmp4_;
+		gint _tmp5_;
+		_tmp3_ = self->priv->registered_clients;
+		_tmp4_ = gee_abstract_map_get_size ((GeeMap*) _tmp3_);
+		_tmp5_ = _tmp4_;
+		result = MUSIC_PLAYER_BRIDGE_DEVICE_ITEMS_COUNT + (_tmp5_ * PLAYER_CONTROLLER_WIDGET_QUANTITY);
+		return result;
+	}
+}
+
+
+static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle) {
+	int i;
+	for (i = 0; i < stack_length; i++) {
+		if (g_strcmp0 (stack[i], needle) == 0) {
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+
+static gboolean* _bool_dup (gboolean* self) {
+	gboolean* dup;
+	dup = g_new0 (gboolean, 1);
+	memcpy (dup, self, sizeof (gboolean));
+	return dup;
+}
+
+
+static gpointer __bool_dup0 (gpointer self) {
+	return self ? _bool_dup (self) : NULL;
+}
+
+
+static gchar* bool_to_string (gboolean self) {
+	gchar* result = NULL;
+	if (self) {
+		gchar* _tmp0_;
+		_tmp0_ = g_strdup ("true");
+		result = _tmp0_;
+		return result;
+	} else {
+		gchar* _tmp1_;
+		_tmp1_ = g_strdup ("false");
+		result = _tmp1_;
+		return result;
+	}
+}
+
+
+void music_player_bridge_client_has_become_available (MusicPlayerBridge* self, const gchar* desktop, const gchar* dbus_name, gboolean use_playlists) {
+	gboolean _tmp0_ = FALSE;
+	const gchar* _tmp1_;
+	gboolean _tmp3_;
+	const gchar* _tmp5_;
+	SettingsManager* _tmp6_;
+	gint _tmp7_ = 0;
+	gchar** _tmp8_ = NULL;
+	gchar** _tmp9_;
+	gint _tmp9__length1;
+	gboolean _tmp10_;
+	const gchar* _tmp12_;
+	const gchar* _tmp13_;
+	gchar* _tmp14_ = NULL;
+	gchar* _tmp15_;
+	GAppInfo* _tmp16_ = NULL;
+	GAppInfo* _tmp17_;
+	GAppInfo* app_info;
+	GAppInfo* _tmp18_;
+	const gchar* _tmp20_;
+	gchar* _tmp21_;
+	gchar* _tmp22_ = NULL;
+	gchar* mpris_key;
+	GeeHashMap* _tmp23_;
+	const gchar* _tmp24_;
+	gboolean _tmp25_ = FALSE;
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (desktop != NULL);
+	g_return_if_fail (dbus_name != NULL);
+	_tmp1_ = desktop;
+	if (_tmp1_ == NULL) {
+		_tmp0_ = TRUE;
+	} else {
+		const gchar* _tmp2_;
+		_tmp2_ = desktop;
+		_tmp0_ = g_strcmp0 (_tmp2_, "") == 0;
+	}
+	_tmp3_ = _tmp0_;
+	if (_tmp3_) {
+		const gchar* _tmp4_;
+		_tmp4_ = dbus_name;
+		g_warning ("music-player-bridge.vala:147: Client %s attempting to register without" \
+" desktop entry being set on the mpris root", _tmp4_);
+		return;
+	}
+	_tmp5_ = desktop;
+	_tmp6_ = self->priv->settings_manager;
+	_tmp8_ = settings_manager_fetch_blacklist (_tmp6_, &_tmp7_);
+	_tmp9_ = _tmp8_;
+	_tmp9__length1 = _tmp7_;
+	_tmp10_ = _vala_string_array_contains (_tmp9_, _tmp7_, _tmp5_);
+	_tmp9_ = (_vala_array_free (_tmp9_, _tmp9__length1, (GDestroyNotify) g_free), NULL);
+	if (_tmp10_) {
+		const gchar* _tmp11_;
+		_tmp11_ = desktop;
+		g_debug ("music-player-bridge.vala:152: Client %s attempting to register but I'm" \
+" afraid it is blacklisted", _tmp11_);
+		return;
+	}
+	_tmp12_ = desktop;
+	g_debug ("music-player-bridge.vala:157: client_has_become_available %s", _tmp12_);
+	_tmp13_ = desktop;
+	_tmp14_ = g_strconcat (_tmp13_, ".desktop", NULL);
+	_tmp15_ = _tmp14_;
+	_tmp16_ = music_player_bridge_create_app_info (_tmp15_);
+	_tmp17_ = _tmp16_;
+	_g_free0 (_tmp15_);
+	app_info = _tmp17_;
+	_tmp18_ = app_info;
+	if (_tmp18_ == NULL) {
+		const gchar* _tmp19_;
+		_tmp19_ = desktop;
+		g_warning ("music-player-bridge.vala:160: Could not create app_info for path %s \n" \
+" Getting out of here ", _tmp19_);
+		_g_object_unref0 (app_info);
+		return;
+	}
+	_tmp20_ = desktop;
+	_tmp21_ = g_strdup (_tmp20_);
+	_tmp22_ = music_player_bridge_determine_key (_tmp21_);
+	mpris_key = _tmp22_;
+	_tmp23_ = self->priv->registered_clients;
+	_tmp24_ = mpris_key;
+	_tmp25_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp23_, _tmp24_);
+	if (_tmp25_ == FALSE) {
+		const gchar* _tmp26_;
+		DbusmenuMenuitem* _tmp27_;
+		GAppInfo* _tmp28_;
+		const gchar* _tmp29_;
+		const gchar* _tmp30_;
+		gchar* _tmp31_ = NULL;
+		gchar* _tmp32_;
+		gint _tmp33_ = 0;
+		gboolean _tmp34_;
+		PlayerController* _tmp35_;
+		PlayerController* _tmp36_;
+		PlayerController* ctrl;
+		GeeHashMap* _tmp37_;
+		const gchar* _tmp38_;
+		PlayerController* _tmp39_;
+		const gchar* _tmp40_;
+		SettingsManager* _tmp41_;
+		const gchar* _tmp42_;
+		GAppInfo* _tmp43_;
+		const gchar* _tmp44_;
+		_tmp26_ = dbus_name;
+		g_debug ("music-player-bridge.vala:168: New client has registered that we have n" \
+"ot seen before: %s", _tmp26_);
+		_tmp27_ = self->priv->root_menu;
+		_tmp28_ = app_info;
+		_tmp29_ = dbus_name;
+		_tmp30_ = desktop;
+		_tmp31_ = music_player_bridge_fetch_icon_name (_tmp30_);
+		_tmp32_ = _tmp31_;
+		_tmp33_ = music_player_bridge_calculate_menu_position (self);
+		_tmp34_ = use_playlists;
+		_tmp35_ = player_controller_new (_tmp27_, _tmp28_, _tmp29_, _tmp32_, _tmp33_, &_tmp34_, PLAYER_CONTROLLER_STATE_READY);
+		_tmp36_ = _tmp35_;
+		_g_free0 (_tmp32_);
+		ctrl = _tmp36_;
+		_tmp37_ = self->priv->registered_clients;
+		_tmp38_ = mpris_key;
+		_tmp39_ = ctrl;
+		gee_abstract_map_set ((GeeAbstractMap*) _tmp37_, _tmp38_, _tmp39_);
+		_tmp40_ = desktop;
+		g_debug ("music-player-bridge.vala:177: Have not seen this %s before, new contro" \
+"ller created.", _tmp40_);
+		_tmp41_ = self->priv->settings_manager;
+		_tmp42_ = desktop;
+		settings_manager_add_interested (_tmp41_, _tmp42_);
+		_tmp43_ = app_info;
+		_tmp44_ = mpris_key;
+		music_player_bridge_establish_file_monitoring (self, _tmp43_, _tmp44_);
+		g_debug ("music-player-bridge.vala:180: application added to the interested list");
+		_g_object_unref0 (ctrl);
+	} else {
+		GeeHashMap* _tmp45_;
+		const gchar* _tmp46_;
+		gpointer _tmp47_ = NULL;
+		PlayerController* _tmp48_;
+		gboolean _tmp49_;
+		gboolean* _tmp50_;
+		GeeHashMap* _tmp51_;
+		const gchar* _tmp52_;
+		gpointer _tmp53_ = NULL;
+		PlayerController* _tmp54_;
+		GeeHashMap* _tmp55_;
+		const gchar* _tmp56_;
+		gpointer _tmp57_ = NULL;
+		PlayerController* _tmp58_;
+		const gchar* _tmp59_;
+		const gchar* _tmp60_;
+		gboolean _tmp61_;
+		gchar* _tmp62_ = NULL;
+		gchar* _tmp63_;
+		_tmp45_ = self->priv->registered_clients;
+		_tmp46_ = mpris_key;
+		_tmp47_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp45_, _tmp46_);
+		_tmp48_ = (PlayerController*) _tmp47_;
+		_tmp49_ = use_playlists;
+		_tmp50_ = __bool_dup0 (&_tmp49_);
+		_g_free0 (_tmp48_->use_playlists);
+		_tmp48_->use_playlists = _tmp50_;
+		_g_object_unref0 (_tmp48_);
+		_tmp51_ = self->priv->registered_clients;
+		_tmp52_ = mpris_key;
+		_tmp53_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp51_, _tmp52_);
+		_tmp54_ = (PlayerController*) _tmp53_;
+		player_controller_update_state (_tmp54_, PLAYER_CONTROLLER_STATE_READY);
+		_g_object_unref0 (_tmp54_);
+		_tmp55_ = self->priv->registered_clients;
+		_tmp56_ = mpris_key;
+		_tmp57_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp55_, _tmp56_);
+		_tmp58_ = (PlayerController*) _tmp57_;
+		_tmp59_ = dbus_name;
+		player_controller_activate (_tmp58_, _tmp59_);
+		_g_object_unref0 (_tmp58_);
+		_tmp60_ = dbus_name;
+		_tmp61_ = use_playlists;
+		_tmp62_ = bool_to_string (_tmp61_);
+		_tmp63_ = _tmp62_;
+		g_debug ("music-player-bridge.vala:186: Application has already registered - awa" \
+"ken the hibernation: %s with playlists %s \n", _tmp60_, _tmp63_);
+		_g_free0 (_tmp63_);
+	}
+	_g_free0 (mpris_key);
+	_g_object_unref0 (app_info);
+}
+
+
+void music_player_bridge_client_has_vanished (MusicPlayerBridge* self, const gchar* mpris_root_interface) {
+	const gchar* _tmp0_;
+	DbusmenuMenuitem* _tmp1_;
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (mpris_root_interface != NULL);
+	_tmp0_ = mpris_root_interface;
+	g_debug ("music-player-bridge.vala:192: MusicPlayerBridge -> client with dbus in" \
+"terface %s has vanished", _tmp0_);
+	_tmp1_ = self->priv->root_menu;
+	if (_tmp1_ != NULL) {
+		const gchar* _tmp2_;
+		const gchar* _tmp3_;
+		gchar* _tmp4_;
+		gchar* _tmp5_ = NULL;
+		gchar* mpris_key;
+		gboolean _tmp6_ = FALSE;
+		const gchar* _tmp7_;
+		gboolean _tmp11_;
+		_tmp2_ = mpris_root_interface;
+		g_debug ("music-player-bridge.vala:195: attempt to remove %s", _tmp2_);
+		_tmp3_ = mpris_root_interface;
+		_tmp4_ = g_strdup (_tmp3_);
+		_tmp5_ = music_player_bridge_determine_key (_tmp4_);
+		mpris_key = _tmp5_;
+		_tmp7_ = mpris_key;
+		if (_tmp7_ != NULL) {
+			GeeHashMap* _tmp8_;
+			const gchar* _tmp9_;
+			gboolean _tmp10_ = FALSE;
+			_tmp8_ = self->priv->registered_clients;
+			_tmp9_ = mpris_key;
+			_tmp10_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp8_, _tmp9_);
+			_tmp6_ = _tmp10_;
+		} else {
+			_tmp6_ = FALSE;
+		}
+		_tmp11_ = _tmp6_;
+		if (_tmp11_) {
+			GeeHashMap* _tmp12_;
+			const gchar* _tmp13_;
+			gpointer _tmp14_ = NULL;
+			PlayerController* _tmp15_;
+			const gchar* _tmp16_;
+			_tmp12_ = self->priv->registered_clients;
+			_tmp13_ = mpris_key;
+			_tmp14_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp12_, _tmp13_);
+			_tmp15_ = (PlayerController*) _tmp14_;
+			player_controller_hibernate (_tmp15_);
+			_g_object_unref0 (_tmp15_);
+			_tmp16_ = mpris_key;
+			g_debug ("music-player-bridge.vala:199: Successively offlined client %s", _tmp16_);
+		}
+		_g_free0 (mpris_key);
+	}
+}
+
+
+static void _music_player_bridge_client_has_become_available_mpris2_watcher_client_appeared (Mpris2Watcher* _sender, const gchar* desktop_file_name, const gchar* dbus_name, gboolean use_playlists, gpointer self) {
+	music_player_bridge_client_has_become_available (self, desktop_file_name, dbus_name, use_playlists);
+}
+
+
+static void _music_player_bridge_client_has_vanished_mpris2_watcher_client_disappeared (Mpris2Watcher* _sender, const gchar* dbus_name, gpointer self) {
+	music_player_bridge_client_has_vanished (self, dbus_name);
+}
+
+
+void music_player_bridge_set_root_menu_item (MusicPlayerBridge* self, DbusmenuMenuitem* menu) {
+	DbusmenuMenuitem* _tmp0_;
+	DbusmenuMenuitem* _tmp1_;
+	Mpris2Watcher* _tmp2_;
+	Mpris2Watcher* _tmp3_;
+	Mpris2Watcher* _tmp4_;
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (menu != NULL);
+	_tmp0_ = menu;
+	_tmp1_ = _g_object_ref0 (_tmp0_);
+	_g_object_unref0 (self->priv->root_menu);
+	self->priv->root_menu = _tmp1_;
+	music_player_bridge_try_to_add_inactive_familiar_clients (self);
+	_tmp2_ = mpris2_watcher_new ();
+	_g_object_unref0 (self->priv->watcher);
+	self->priv->watcher = _tmp2_;
+	_tmp3_ = self->priv->watcher;
+	g_signal_connect_object (_tmp3_, "client-appeared", (GCallback) _music_player_bridge_client_has_become_available_mpris2_watcher_client_appeared, self, 0);
+	_tmp4_ = self->priv->watcher;
+	g_signal_connect_object (_tmp4_, "client-disappeared", (GCallback) _music_player_bridge_client_has_vanished_mpris2_watcher_client_disappeared, self, 0);
+}
+
+
+void music_player_bridge_enable_player_specific_items_for_client (MusicPlayerBridge* self, const gchar* object_path, const gchar* desktop_id) {
+	const gchar* _tmp0_;
+	gchar* _tmp1_;
+	gchar* _tmp2_ = NULL;
+	gchar* mpris_key;
+	GeeHashMap* _tmp3_;
+	const gchar* _tmp4_;
+	gboolean _tmp5_ = FALSE;
+	GeeHashMap* _tmp7_;
+	const gchar* _tmp8_;
+	gpointer _tmp9_ = NULL;
+	PlayerController* _tmp10_;
+	const gchar* _tmp11_;
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (object_path != NULL);
+	g_return_if_fail (desktop_id != NULL);
+	_tmp0_ = desktop_id;
+	_tmp1_ = g_strdup (_tmp0_);
+	_tmp2_ = music_player_bridge_determine_key (_tmp1_);
+	mpris_key = _tmp2_;
+	_tmp3_ = self->priv->registered_clients;
+	_tmp4_ = mpris_key;
+	_tmp5_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp3_, _tmp4_);
+	if (_tmp5_ == FALSE) {
+		const gchar* _tmp6_;
+		_tmp6_ = desktop_id;
+		g_warning ("music-player-bridge.vala:218: we don't have a client with desktop id %" \
+"s registered", _tmp6_);
+		_g_free0 (mpris_key);
+		return;
+	}
+	_tmp7_ = self->priv->registered_clients;
+	_tmp8_ = mpris_key;
+	_tmp9_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp7_, _tmp8_);
+	_tmp10_ = (PlayerController*) _tmp9_;
+	_tmp11_ = object_path;
+	player_controller_enable_player_specific_items (_tmp10_, _tmp11_);
+	_g_object_unref0 (_tmp10_);
+	_g_free0 (mpris_key);
+}
+
+
+void music_player_bridge_enable_track_specific_items_for_client (MusicPlayerBridge* self, const gchar* object_path, const gchar* desktop_id) {
+	const gchar* _tmp0_;
+	gchar* _tmp1_;
+	gchar* _tmp2_ = NULL;
+	gchar* mpris_key;
+	GeeHashMap* _tmp3_;
+	const gchar* _tmp4_;
+	gboolean _tmp5_ = FALSE;
+	GeeHashMap* _tmp7_;
+	const gchar* _tmp8_;
+	gpointer _tmp9_ = NULL;
+	PlayerController* _tmp10_;
+	const gchar* _tmp11_;
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (object_path != NULL);
+	g_return_if_fail (desktop_id != NULL);
+	_tmp0_ = desktop_id;
+	_tmp1_ = g_strdup (_tmp0_);
+	_tmp2_ = music_player_bridge_determine_key (_tmp1_);
+	mpris_key = _tmp2_;
+	_tmp3_ = self->priv->registered_clients;
+	_tmp4_ = mpris_key;
+	_tmp5_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp3_, _tmp4_);
+	if (_tmp5_ == FALSE) {
+		const gchar* _tmp6_;
+		_tmp6_ = desktop_id;
+		g_warning ("music-player-bridge.vala:229: we don't have a client with desktop id %" \
+"s registered", _tmp6_);
+		_g_free0 (mpris_key);
+		return;
+	}
+	_tmp7_ = self->priv->registered_clients;
+	_tmp8_ = mpris_key;
+	_tmp9_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp7_, _tmp8_);
+	_tmp10_ = (PlayerController*) _tmp9_;
+	_tmp11_ = object_path;
+	player_controller_enable_track_specific_items (_tmp10_, _tmp11_);
+	_g_object_unref0 (_tmp10_);
+	_g_free0 (mpris_key);
+}
+
+
+static GAppInfo* music_player_bridge_create_app_info (const gchar* desktop) {
+	GAppInfo* result = NULL;
+	const gchar* _tmp0_;
+	GDesktopAppInfo* _tmp1_;
+	GDesktopAppInfo* info;
+	gboolean _tmp2_ = FALSE;
+	const gchar* _tmp3_;
+	gboolean _tmp5_;
+	GDesktopAppInfo* _tmp7_;
+	GAppInfo* _tmp8_;
+	GAppInfo* app_info;
+	g_return_val_if_fail (desktop != NULL, NULL);
+	_tmp0_ = desktop;
+	_tmp1_ = g_desktop_app_info_new (_tmp0_);
+	info = _tmp1_;
+	_tmp3_ = desktop;
+	if (_tmp3_ == NULL) {
+		_tmp2_ = TRUE;
+	} else {
+		GDesktopAppInfo* _tmp4_;
+		_tmp4_ = info;
+		_tmp2_ = _tmp4_ == NULL;
+	}
+	_tmp5_ = _tmp2_;
+	if (_tmp5_) {
+		const gchar* _tmp6_;
+		_tmp6_ = desktop;
+		g_warning ("music-player-bridge.vala:239: Could not create a desktopappinfo instan" \
+"ce from app: %s", _tmp6_);
+		result = NULL;
+		_g_object_unref0 (info);
+		return result;
+	}
+	_tmp7_ = info;
+	_tmp8_ = _g_object_ref0 (G_IS_APP_INFO (_tmp7_) ? ((GAppInfo*) _tmp7_) : NULL);
+	app_info = _tmp8_;
+	result = app_info;
+	_g_object_unref0 (info);
+	return result;
+}
+
+
+static gchar* music_player_bridge_fetch_icon_name (const gchar* desktop) {
+	gchar* result = NULL;
+	const gchar* _tmp0_;
+	gchar* _tmp1_ = NULL;
+	gchar* _tmp2_;
+	GDesktopAppInfo* _tmp3_;
+	GDesktopAppInfo* _tmp4_;
+	GDesktopAppInfo* info;
+	GKeyFile* _tmp5_;
+	GKeyFile* desktop_keyfile;
+	GError * _inner_error_ = NULL;
+	g_return_val_if_fail (desktop != NULL, NULL);
+	_tmp0_ = desktop;
+	_tmp1_ = g_strconcat (_tmp0_, ".desktop", NULL);
+	_tmp2_ = _tmp1_;
+	_tmp3_ = g_desktop_app_info_new (_tmp2_);
+	_tmp4_ = _tmp3_;
+	_g_free0 (_tmp2_);
+	info = _tmp4_;
+	_tmp5_ = g_key_file_new ();
+	desktop_keyfile = _tmp5_;
+	{
+		GKeyFile* _tmp6_;
+		GDesktopAppInfo* _tmp7_;
+		const gchar* _tmp8_ = NULL;
+		_tmp6_ = desktop_keyfile;
+		_tmp7_ = info;
+		_tmp8_ = g_desktop_app_info_get_filename (_tmp7_);
+		g_key_file_load_from_file (_tmp6_, _tmp8_, G_KEY_FILE_NONE, &_inner_error_);
+		if (_inner_error_ != NULL) {
+			if (_inner_error_->domain == G_FILE_ERROR) {
+				goto __catch1_g_file_error;
+			}
+			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
+				goto __catch1_g_key_file_error;
+			}
+			_g_key_file_free0 (desktop_keyfile);
+			_g_object_unref0 (info);
+			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+			g_clear_error (&_inner_error_);
+			return NULL;
+		}
+	}
+	goto __finally1;
+	__catch1_g_file_error:
+	{
+		GError* _error_ = NULL;
+		_error_ = _inner_error_;
+		_inner_error_ = NULL;
+		g_warning ("music-player-bridge.vala:255: Error loading keyfile - FileError");
+		result = NULL;
+		_g_error_free0 (_error_);
+		_g_key_file_free0 (desktop_keyfile);
+		_g_object_unref0 (info);
+		return result;
+	}
+	goto __finally1;
+	__catch1_g_key_file_error:
+	{
+		GError* _error_ = NULL;
+		_error_ = _inner_error_;
+		_inner_error_ = NULL;
+		g_warning ("music-player-bridge.vala:259: Error loading keyfile - KeyFileError");
+		result = NULL;
+		_g_error_free0 (_error_);
+		_g_key_file_free0 (desktop_keyfile);
+		_g_object_unref0 (info);
+		return result;
+	}
+	__finally1:
+	if (_inner_error_ != NULL) {
+		_g_key_file_free0 (desktop_keyfile);
+		_g_object_unref0 (info);
+		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+		g_clear_error (&_inner_error_);
+		return NULL;
+	}
+	{
+		GKeyFile* _tmp9_;
+		gchar* _tmp10_ = NULL;
+		gchar* _tmp11_;
+		_tmp9_ = desktop_keyfile;
+		_tmp10_ = g_key_file_get_string (_tmp9_, G_KEY_FILE_DESKTOP_GROUP, G_KEY_FILE_DESKTOP_KEY_ICON, &_inner_error_);
+		_tmp11_ = _tmp10_;
+		if (_inner_error_ != NULL) {
+			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
+				goto __catch2_g_key_file_error;
+			}
+			_g_key_file_free0 (desktop_keyfile);
+			_g_object_unref0 (info);
+			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+			g_clear_error (&_inner_error_);
+			return NULL;
+		}
+		result = _tmp11_;
+		_g_key_file_free0 (desktop_keyfile);
+		_g_object_unref0 (info);
+		return result;
+	}
+	goto __finally2;
+	__catch2_g_key_file_error:
+	{
+		GError* _error_ = NULL;
+		_error_ = _inner_error_;
+		_inner_error_ = NULL;
+		g_warning ("music-player-bridge.vala:268: Error trying to fetch the icon name from" \
+" the keyfile");
+		result = NULL;
+		_g_error_free0 (_error_);
+		_g_key_file_free0 (desktop_keyfile);
+		_g_object_unref0 (info);
+		return result;
+	}
+	__finally2:
+	_g_key_file_free0 (desktop_keyfile);
+	_g_object_unref0 (info);
+	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
+	g_clear_error (&_inner_error_);
+	return NULL;
+}
+
+
+static gchar* music_player_bridge_determine_key (gchar* desktop_or_interface) {
+	gchar* result = NULL;
+	const gchar* _tmp0_;
+	gchar* _tmp1_;
+	gchar* _result_;
+	const gchar* _tmp2_;
+	gchar** _tmp3_;
+	gchar** _tmp4_ = NULL;
+	gchar** tokens;
+	gint tokens_length1;
+	gint _tokens_size_;
+	gboolean _tmp5_ = FALSE;
+	gchar** _tmp6_;
+	gint _tmp6__length1;
+	gboolean _tmp8_;
+	const gchar* _tmp13_;
+	gchar** _tmp14_;
+	gchar** _tmp15_ = NULL;
+	gchar** temp;
+	gint temp_length1;
+	gint _temp_size_;
+	gboolean _tmp16_ = FALSE;
+	gchar** _tmp17_;
+	gint _tmp17__length1;
+	gboolean _tmp19_;
+	g_return_val_if_fail (desktop_or_interface != NULL, NULL);
+	_tmp0_ = desktop_or_interface;
+	_tmp1_ = g_strdup (_tmp0_);
+	_result_ = _tmp1_;
+	_tmp2_ = desktop_or_interface;
+	_tmp4_ = _tmp3_ = g_strsplit (_tmp2_, ".", 0);
+	tokens = _tmp4_;
+	tokens_length1 = _vala_array_length (_tmp3_);
+	_tokens_size_ = tokens_length1;
+	_tmp6_ = tokens;
+	_tmp6__length1 = tokens_length1;
+	if (_tmp6_ != NULL) {
+		gchar** _tmp7_;
+		gint _tmp7__length1;
+		_tmp7_ = tokens;
+		_tmp7__length1 = tokens_length1;
+		_tmp5_ = _tmp7__length1 > 1;
+	} else {
+		_tmp5_ = FALSE;
+	}
+	_tmp8_ = _tmp5_;
+	if (_tmp8_) {
+		gchar** _tmp9_;
+		gint _tmp9__length1;
+		gchar** _tmp10_;
+		gint _tmp10__length1;
+		const gchar* _tmp11_;
+		gchar* _tmp12_;
+		_tmp9_ = tokens;
+		_tmp9__length1 = tokens_length1;
+		_tmp10_ = tokens;
+		_tmp10__length1 = tokens_length1;
+		_tmp11_ = _tmp9_[_tmp10__length1 - 1];
+		_tmp12_ = g_strdup (_tmp11_);
+		_g_free0 (_result_);
+		_result_ = _tmp12_;
+	}
+	_tmp13_ = _result_;
+	_tmp15_ = _tmp14_ = g_strsplit (_tmp13_, "-", 0);
+	temp = _tmp15_;
+	temp_length1 = _vala_array_length (_tmp14_);
+	_temp_size_ = temp_length1;
+	_tmp17_ = temp;
+	_tmp17__length1 = temp_length1;
+	if (_tmp17_ != NULL) {
+		gchar** _tmp18_;
+		gint _tmp18__length1;
+		_tmp18_ = temp;
+		_tmp18__length1 = temp_length1;
+		_tmp16_ = _tmp18__length1 > 1;
+	} else {
+		_tmp16_ = FALSE;
+	}
+	_tmp19_ = _tmp16_;
+	if (_tmp19_) {
+		gchar** _tmp20_;
+		gint _tmp20__length1;
+		const gchar* _tmp21_;
+		gchar* _tmp22_;
+		_tmp20_ = temp;
+		_tmp20__length1 = temp_length1;
+		_tmp21_ = _tmp20_[0];
+		_tmp22_ = g_strdup (_tmp21_);
+		_g_free0 (_result_);
+		_result_ = _tmp22_;
+	}
+	result = _result_;
+	temp = (_vala_array_free (temp, temp_length1, (GDestroyNotify) g_free), NULL);
+	tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
+	_g_free0 (desktop_or_interface);
+	return result;
+}
+
+
+static void _music_player_bridge_on_blacklist_update_settings_manager_blacklist_updates (SettingsManager* _sender, gchar** new_blacklist, int new_blacklist_length1, gpointer self) {
+	music_player_bridge_on_blacklist_update (self, new_blacklist, new_blacklist_length1);
+}
+
+
+static GObject * music_player_bridge_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
+	GObject * obj;
+	GObjectClass * parent_class;
+	MusicPlayerBridge * self;
+	GeeHashMap* _tmp0_;
+	GeeHashMap* _tmp1_;
+	SettingsManager* _tmp2_;
+	SettingsManager* _tmp3_;
+	parent_class = G_OBJECT_CLASS (music_player_bridge_parent_class);
+	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
+	self = MUSIC_PLAYER_BRIDGE (obj);
+	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, TYPE_PLAYER_CONTROLLER, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
+	_g_object_unref0 (self->priv->registered_clients);
+	self->priv->registered_clients = _tmp0_;
+	_tmp1_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
+	_g_object_unref0 (self->priv->file_monitors);
+	self->priv->file_monitors = _tmp1_;
+	_tmp2_ = settings_manager_new ();
+	_g_object_unref0 (self->priv->settings_manager);
+	self->priv->settings_manager = _tmp2_;
+	_tmp3_ = self->priv->settings_manager;
+	g_signal_connect_object (_tmp3_, "blacklist-updates", (GCallback) _music_player_bridge_on_blacklist_update_settings_manager_blacklist_updates, self, 0);
+	return obj;
+}
+
+
+static void music_player_bridge_class_init (MusicPlayerBridgeClass * klass) {
+	music_player_bridge_parent_class = g_type_class_peek_parent (klass);
+	g_type_class_add_private (klass, sizeof (MusicPlayerBridgePrivate));
+	G_OBJECT_CLASS (klass)->constructor = music_player_bridge_constructor;
+	G_OBJECT_CLASS (klass)->finalize = music_player_bridge_finalize;
+}
+
+
+static void music_player_bridge_instance_init (MusicPlayerBridge * self) {
+	self->priv = MUSIC_PLAYER_BRIDGE_GET_PRIVATE (self);
+}
+
+
+static void music_player_bridge_finalize (GObject* obj) {
+	MusicPlayerBridge * self;
+	self = MUSIC_PLAYER_BRIDGE (obj);
+	_g_object_unref0 (self->priv->settings_manager);
+	_g_object_unref0 (self->priv->root_menu);
+	_g_object_unref0 (self->priv->registered_clients);
+	_g_object_unref0 (self->priv->file_monitors);
+	_g_object_unref0 (self->priv->watcher);
+	G_OBJECT_CLASS (music_player_bridge_parent_class)->finalize (obj);
+}
+
+
+GType music_player_bridge_get_type (void) {
+	static volatile gsize music_player_bridge_type_id__volatile = 0;
+	if (g_once_init_enter (&music_player_bridge_type_id__volatile)) {
+		static const GTypeInfo g_define_type_info = { sizeof (MusicPlayerBridgeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) music_player_bridge_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MusicPlayerBridge), 0, (GInstanceInitFunc) music_player_bridge_instance_init, NULL };
+		GType music_player_bridge_type_id;
+		music_player_bridge_type_id = g_type_register_static (G_TYPE_OBJECT, "MusicPlayerBridge", &g_define_type_info, 0);
+		g_once_init_leave (&music_player_bridge_type_id__volatile, music_player_bridge_type_id);
+	}
+	return music_player_bridge_type_id__volatile;
+}
+
+
+static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
+	if ((array != NULL) && (destroy_func != NULL)) {
+		int i;
+		for (i = 0; i < array_length; i = i + 1) {
+			if (((gpointer*) array)[i] != NULL) {
+				destroy_func (((gpointer*) array)[i]);
+			}
+		}
+	}
+}
+
+
+static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
+	_vala_array_destroy (array, array_length, destroy_func);
+	g_free (array);
+}
+
+
+static gint _vala_array_length (gpointer array) {
+	int length;
+	length = 0;
+	if (array) {
+		while (((gpointer*) array)[length]) {
+			length++;
+		}
+	}
+	return length;
+}
+
+
+
diff -Naur indicator-sound-0.8.5.0/.pc/lp_992262.patch/src/music-player-bridge.vala indicator-sound-precise/.pc/lp_992262.patch/src/music-player-bridge.vala
--- indicator-sound-0.8.5.0/.pc/lp_992262.patch/src/music-player-bridge.vala	1969-12-31 16:00:00.000000000 -0800
+++ indicator-sound-precise/.pc/lp_992262.patch/src/music-player-bridge.vala	2012-07-26 21:03:55.488143000 -0700
@@ -0,0 +1,298 @@
+/*
+Copyright 2010 Canonical Ltd.
+
+Authors:
+    Conor Curran <conor.curran@canonical.com>
+
+This program is free software: you can redistribute it and/or modify it 
+under the terms of the GNU General Public License version 3, as published 
+by the Free Software Foundation.
+
+This program is distributed in the hope that it will be useful, but 
+WITHOUT ANY WARRANTY; without even the implied warranties of 
+MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
+PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along 
+with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+using Dbusmenu;
+using Gee;
+using GLib;
+
+public class MusicPlayerBridge : GLib.Object
+{
+  const int DEVICE_ITEMS_COUNT = 3;
+
+  private SettingsManager settings_manager;
+  private Dbusmenu.Menuitem root_menu;
+  private HashMap<string, PlayerController> registered_clients;
+  private HashMap<string, string> file_monitors;
+  private Mpris2Watcher watcher;
+
+  public MusicPlayerBridge()
+  {
+  }
+  
+  construct{
+    this.registered_clients = new HashMap<string, PlayerController> ();
+    this.file_monitors = new HashMap<string, string> ();
+    this.settings_manager = new SettingsManager();
+    this.settings_manager.blacklist_updates.connect ( this.on_blacklist_update );
+  }
+  
+  private void on_blacklist_update ( string[] blacklist )
+  {
+    debug("some blacklist update");
+
+    foreach(var s in blacklist){
+      string key = this.determine_key (s);
+      if (this.registered_clients.has_key (key)){
+        debug ("Apparently %s is now blacklisted - remove thy self", key);
+        this.registered_clients[key].remove_from_menu();
+        this.registered_clients.unset (key);
+      }
+    }
+    // double check present players to ensure dynamic removal/addition 
+    this.watcher.check_for_active_clients.begin();
+  }
+
+  private void try_to_add_inactive_familiar_clients()
+  {
+    foreach ( string desktop in this.settings_manager.fetch_interested()){
+      debug ( "interested client found : %s", desktop );
+      AppInfo? app_info = create_app_info ( desktop.concat( ".desktop" ) );
+      if ( app_info == null ){
+        warning ( "Could not create app_info for path %s \n Getting out of here ",
+                   desktop );
+        continue;
+      }
+      var mpris_key = determine_key ( desktop );
+      PlayerController ctrl = new PlayerController ( this.root_menu, 
+                                                     app_info,
+                                                     null,
+                                                     this.fetch_icon_name(desktop),
+                                                     calculate_menu_position(),
+                                                     null,
+                                                     PlayerController.state.OFFLINE );
+      this.registered_clients.set(mpris_key, ctrl);  
+      this.establish_file_monitoring (app_info, mpris_key);
+    }
+  }
+  
+  private void establish_file_monitoring (AppInfo info, string mpris_key){
+      DesktopAppInfo desktop_info = info as DesktopAppInfo;
+      var file_path = desktop_info.get_filename ();
+      File f = File.new_for_path (file_path);
+      try {
+        FileMonitor monitor = f.monitor (FileMonitorFlags.SEND_MOVED, null);
+        unowned FileMonitor weak_monitor = monitor;
+        monitor.changed.connect ((desktop_file, other_file, event_type) => {
+          this.relevant_desktop_file_changed (desktop_file, other_file, event_type, weak_monitor);
+        });
+        monitor.ref(); // will be unref()ed by relevant_desktop_file_changed()
+        GLib.debug ("monitoring file '%s'", file_path);
+        this.file_monitors.set (file_path, mpris_key);
+      }
+      catch (Error e){
+        warning ("Unable to create a file monitor for %s", info.get_name());
+        return;
+      }
+  }
+  
+  private void relevant_desktop_file_changed (File desktop_file,
+                                              File? other_file,
+                                              FileMonitorEvent event_type,
+                                              FileMonitor monitor)
+  {
+    if (event_type != FileMonitorEvent.DELETED)
+      return;
+      
+    string? path = desktop_file.get_path ();
+    if (path == null){
+      warning ("relevant_desktop_file_changed is returning a file with no path !");
+      return;
+    }
+    if (!this.file_monitors.has_key (path)){
+      warning ("relevant_desktop_file_changed is returning a file which we know nothing about - %s",
+                path);
+      return;
+    }
+
+    var mpris_key = this.file_monitors[path];
+    GLib.debug ("file \"%s\" was removed; stopping monitoring \"%s\"", path, mpris_key);
+    this.registered_clients[mpris_key].remove_from_menu();
+    this.settings_manager.remove_interested (mpris_key);
+    this.registered_clients.unset (mpris_key);
+    monitor.cancel ();
+    monitor.unref();
+  }                                              
+
+  private int calculate_menu_position()
+  {
+    if(this.registered_clients.size == 0){
+      return DEVICE_ITEMS_COUNT;
+    }
+    else{
+      return (DEVICE_ITEMS_COUNT + (this.registered_clients.size * PlayerController.WIDGET_QUANTITY));
+    }
+  }
+
+  public void client_has_become_available ( string desktop,
+                                            string dbus_name,
+                                            bool use_playlists )
+  {
+    if (desktop == null || desktop == ""){
+      warning("Client %s attempting to register without desktop entry being set on the mpris root",
+               dbus_name);
+      return;
+    }
+    if (desktop in this.settings_manager.fetch_blacklist()) {
+      debug ("Client %s attempting to register but I'm afraid it is blacklisted",
+             desktop);
+      return;
+    }
+    
+    debug ( "client_has_become_available %s", desktop );
+    AppInfo? app_info = create_app_info ( desktop.concat( ".desktop" ) );
+    if ( app_info == null ){
+      warning ( "Could not create app_info for path %s \n Getting out of here ",
+                 desktop );
+      return;
+    }
+    
+    var mpris_key = determine_key ( desktop );
+    // Are we sure clients will appear like this with the new registration method in place. 
+    if ( this.registered_clients.has_key (mpris_key) == false ){
+      debug("New client has registered that we have not seen before: %s", dbus_name );
+      PlayerController ctrl = new PlayerController ( this.root_menu,
+                                                     app_info,
+                                                     dbus_name,
+                                                     this.fetch_icon_name(desktop),                                                    
+                                                     this.calculate_menu_position(),
+                                                     use_playlists,
+                                                     PlayerController.state.READY );
+      this.registered_clients.set ( mpris_key, ctrl );
+      debug ( "Have not seen this %s before, new controller created.", desktop );        
+      this.settings_manager.add_interested ( desktop );
+      this.establish_file_monitoring (app_info, mpris_key);      
+      debug ( "application added to the interested list" );
+    }
+    else{
+      this.registered_clients[mpris_key].use_playlists = use_playlists;
+      this.registered_clients[mpris_key].update_state ( PlayerController.state.READY );
+      this.registered_clients[mpris_key].activate ( dbus_name );
+      debug("Application has already registered - awaken the hibernation: %s with playlists %s \n", dbus_name, use_playlists.to_string() );
+    }
+  }
+  
+  public void client_has_vanished ( string mpris_root_interface )
+  {
+    debug("MusicPlayerBridge -> client with dbus interface %s has vanished",
+           mpris_root_interface );
+    if (root_menu != null){
+      debug("attempt to remove %s", mpris_root_interface);
+      var mpris_key = determine_key ( mpris_root_interface );
+      if ( mpris_key != null && this.registered_clients.has_key(mpris_key)){
+        registered_clients[mpris_key].hibernate();
+        debug("Successively offlined client %s", mpris_key);       
+      }
+    }
+  }
+ 
+  public void set_root_menu_item ( Dbusmenu.Menuitem menu )
+  {
+    this.root_menu = menu;
+    this.try_to_add_inactive_familiar_clients();
+    this.watcher = new Mpris2Watcher ();
+    this.watcher.client_appeared.connect (this.client_has_become_available);
+    this.watcher.client_disappeared.connect (this.client_has_vanished);
+  }
+
+  public void enable_player_specific_items_for_client (string object_path,
+                                                       string desktop_id)
+  {
+    var mpris_key = determine_key ( desktop_id );
+    if (this.registered_clients.has_key (mpris_key) == false){
+      warning ("we don't have a client with desktop id %s registered", desktop_id);
+      return;
+    }
+    this.registered_clients[mpris_key].enable_player_specific_items(object_path);
+  }
+
+  public void enable_track_specific_items_for_client (string object_path,
+                                                      string desktop_id)
+  {
+    var mpris_key = determine_key ( desktop_id );
+    if (this.registered_clients.has_key (mpris_key) == false){
+      warning ("we don't have a client with desktop id %s registered", desktop_id);
+      return;
+    }
+    this.registered_clients[mpris_key].enable_track_specific_items(object_path);
+  }
+
+  private static AppInfo? create_app_info ( string desktop )
+  {
+    DesktopAppInfo info = new DesktopAppInfo ( desktop );
+    if ( desktop == null || info == null ){
+      warning ( "Could not create a desktopappinfo instance from app: %s", desktop );
+      return null;
+    }
+    GLib.AppInfo app_info = info as GLib.AppInfo;
+    return app_info;
+  }
+ 
+  private static string? fetch_icon_name(string desktop)
+  {
+    // We know the appinfo is good because it was loaded in the previous reg step.
+    DesktopAppInfo info = new DesktopAppInfo ( desktop.concat( ".desktop" ) ) ;
+    KeyFile desktop_keyfile = new KeyFile ();
+    try{
+      desktop_keyfile.load_from_file (info.get_filename(), KeyFileFlags.NONE);
+    }
+    catch(GLib.FileError error){
+      warning("Error loading keyfile - FileError");
+      return null;
+    }
+    catch(GLib.KeyFileError error){
+      warning("Error loading keyfile - KeyFileError");      
+      return null;
+    } 
+    
+    try{
+      return desktop_keyfile.get_string (KeyFileDesktop.GROUP,
+                                         KeyFileDesktop.KEY_ICON);              
+    }
+    catch(GLib.KeyFileError error){
+      warning("Error trying to fetch the icon name from the keyfile");      
+      return null;
+    } 
+  }
+
+  /*
+    Messy but necessary method to consolidate desktop filesnames and mpris dbus
+    names into the one single word string (used as the key in the players hash).
+    So this means that we can determine the key for the players_hash from the 
+    dbus interface name or the desktop file name, at startup offline/online and 
+    shutdown.
+   */
+  private static string? determine_key(owned string desktop_or_interface)
+  {
+    var result = desktop_or_interface;
+    var tokens = desktop_or_interface.split( "." );
+    if (tokens != null && tokens.length > 1){
+      result = tokens[tokens.length - 1];  
+    }
+    var temp = result.split("-");
+    if (temp != null && temp.length > 1){
+      result = temp[0];
+    }
+    return result;        
+  }
+  
+}
+
+
+
+
diff -Naur indicator-sound-0.8.5.0/.pc/.quilt_patches indicator-sound-precise/.pc/.quilt_patches
--- indicator-sound-0.8.5.0/.pc/.quilt_patches	1969-12-31 16:00:00.000000000 -0800
+++ indicator-sound-precise/.pc/.quilt_patches	2012-07-26 21:03:55.488143000 -0700
@@ -0,0 +1 @@
+debian/patches
diff -Naur indicator-sound-0.8.5.0/.pc/.quilt_series indicator-sound-precise/.pc/.quilt_series
--- indicator-sound-0.8.5.0/.pc/.quilt_series	1969-12-31 16:00:00.000000000 -0800
+++ indicator-sound-precise/.pc/.quilt_series	2012-07-26 21:03:55.488143000 -0700
@@ -0,0 +1 @@
+series
diff -Naur indicator-sound-0.8.5.0/.pc/sound_nua.patch/src/sound-service-dbus.c indicator-sound-precise/.pc/sound_nua.patch/src/sound-service-dbus.c
--- indicator-sound-0.8.5.0/.pc/sound_nua.patch/src/sound-service-dbus.c	1969-12-31 16:00:00.000000000 -0800
+++ indicator-sound-precise/.pc/sound_nua.patch/src/sound-service-dbus.c	2012-07-26 21:03:55.488143000 -0700
@@ -0,0 +1,489 @@
+/*
+ * Copyright 2010 Canonical Ltd.
+ *
+ * Authors:
+ *     Conor Curran <conor.curran@canonical.com>
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 3, as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranties of
+ * MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
+ * PURPOSE.  See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gio/gio.h>
+#include <unistd.h>
+#include <glib/gi18n.h>
+#include <libindicator/indicator-service.h>
+#include <libdbusmenu-glib/server.h>
+#include <libdbusmenu-glib/client.h>
+
+#include "sound-service-dbus.h"
+#include "device.h"
+#include "gen-sound-service.xml.h"
+#include "dbus-shared-names.h"
+#include "sound-service-marshal.h"
+
+// DBUS methods
+static void bus_method_call (GDBusConnection * connection,
+                             const gchar * sender,
+                             const gchar * path,
+                             const gchar * interface,
+                             const gchar * method,
+                             GVariant * params, 
+                             GDBusMethodInvocation * invocation,
+                             gpointer user_data);
+
+static GDBusInterfaceVTable       interface_table = {
+	method_call:	bus_method_call,
+	get_property:	NULL, /* No properties */
+	set_property:	NULL  /* No properties */
+};
+
+
+typedef struct _SoundServiceDbusPrivate SoundServiceDbusPrivate;
+
+struct _SoundServiceDbusPrivate {
+  GDBusConnection*    connection;
+  DbusmenuMenuitem*   root_menuitem;
+  Device*             device;
+  gboolean            greeter_mode;
+  guint               registration_id;
+};
+
+enum {
+  TRACK_SPECIFIC_ITEM,
+  PLAYER_SPECIFIC_ITEM,  
+  LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = { 0 };
+
+static GDBusNodeInfo *            node_info = NULL;
+static GDBusInterfaceInfo *       interface_info = NULL;
+
+#define SOUND_SERVICE_DBUS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SOUND_SERVICE_DBUS_TYPE, SoundServiceDbusPrivate))
+
+static void sound_service_dbus_class_init (SoundServiceDbusClass *klass);
+static void sound_service_dbus_init       (SoundServiceDbus *self);
+static void sound_service_dbus_dispose    (GObject *object);
+static void sound_service_dbus_finalize   (GObject *object);
+
+static void show_sound_settings_dialog (DbusmenuMenuitem *mi,
+                                        gpointer user_data);
+static gboolean sound_service_dbus_blacklist_player (SoundServiceDbus* self,
+                                                     const gchar* player_name,
+                                                     gboolean blacklist); 
+
+static gboolean sound_service_dbus_is_blacklisted (SoundServiceDbus* self,
+                                                   const gchar* player_name);
+
+G_DEFINE_TYPE (SoundServiceDbus, sound_service_dbus, G_TYPE_OBJECT);
+
+static void
+sound_service_dbus_class_init (SoundServiceDbusClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (object_class, sizeof(SoundServiceDbusPrivate));
+
+  object_class->dispose = sound_service_dbus_dispose;
+  object_class->finalize = sound_service_dbus_finalize;
+
+  g_assert(klass != NULL);
+
+  if (node_info == NULL) {
+    GError * error = NULL;
+
+    node_info = g_dbus_node_info_new_for_xml(_sound_service, &error);
+    if (error != NULL) {
+      g_critical ("Unable to parse Indicator Service Interface description: %s",
+               error->message);
+      g_error_free(error);
+    }
+  }
+
+  if (interface_info == NULL) {
+    interface_info = g_dbus_node_info_lookup_interface (node_info,
+                                                        INDICATOR_SOUND_DBUS_INTERFACE);
+
+    if (interface_info == NULL) {
+      g_critical("Unable to find interface '" INDICATOR_SOUND_DBUS_INTERFACE "'");
+    }
+  }
+  signals[TRACK_SPECIFIC_ITEM] =  g_signal_new("track-specific-item-requested",
+                                                G_TYPE_FROM_CLASS (klass),
+                                                G_SIGNAL_RUN_LAST,
+                                                0,
+                                                NULL, NULL,
+                                                _sound_service_marshal_VOID__STRING_STRING,
+                                                G_TYPE_NONE, 2, G_TYPE_STRING,
+                                                G_TYPE_STRING);  
+  signals[PLAYER_SPECIFIC_ITEM] =  g_signal_new("player-specific-item-requested",
+                                                G_TYPE_FROM_CLASS (klass),
+                                                G_SIGNAL_RUN_LAST,
+                                                0,
+                                                NULL, NULL,
+                                                _sound_service_marshal_VOID__STRING_STRING,
+                                                G_TYPE_NONE, 2, G_TYPE_STRING,
+                                                G_TYPE_STRING);  
+}
+
+static void
+sound_service_dbus_init (SoundServiceDbus *self)
+{
+  GError *error = NULL;
+  SoundServiceDbusPrivate * priv = SOUND_SERVICE_DBUS_GET_PRIVATE(self);
+
+  priv->connection = NULL;
+
+  /* Fetch the session bus */
+  priv->connection = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, &error);
+
+  if (error != NULL) {
+    g_critical ("sound-service-dbus:Unable to connect to the session bus when creating indicator sound service : %s", error->message);
+    g_error_free (error);
+    return;
+  }
+  /* register the service on it */
+  priv->registration_id = g_dbus_connection_register_object (priv->connection,
+                                                             INDICATOR_SOUND_SERVICE_DBUS_OBJECT_PATH,
+                                                             interface_info,
+                                                             &interface_table,
+                                                             self,
+                                                             NULL,
+                                                             &error);
+  if (error != NULL) {
+    g_critical ("Unable to register the sound service on DBus: %s", error->message);
+    g_error_free (error);
+  }
+}
+
+DbusmenuMenuitem*
+sound_service_dbus_create_root_item (SoundServiceDbus* self, gboolean greeter_mode)
+{
+  SoundServiceDbusPrivate * priv = SOUND_SERVICE_DBUS_GET_PRIVATE(self);
+  priv->greeter_mode = greeter_mode;
+  priv->root_menuitem = dbusmenu_menuitem_new();
+  DbusmenuServer *server = dbusmenu_server_new (INDICATOR_SOUND_MENU_DBUS_OBJECT_PATH);
+  dbusmenu_server_set_root (server, priv->root_menuitem);
+  g_object_unref (priv->root_menuitem);
+  priv->device = device_new (self);
+  return priv->root_menuitem;
+}
+
+void
+sound_service_dbus_build_sound_menu ( SoundServiceDbus* self,
+                                      DbusmenuMenuitem* mute_item,
+                                      DbusmenuMenuitem* slider_item,
+                                      DbusmenuMenuitem* voip_input_menu_item)
+{
+  SoundServiceDbusPrivate * priv = SOUND_SERVICE_DBUS_GET_PRIVATE(self);
+
+  // Mute, Volume and Voip widgets
+  dbusmenu_menuitem_child_add_position (priv->root_menuitem, mute_item, 0);
+  dbusmenu_menuitem_child_add_position (priv->root_menuitem, slider_item, 1);
+  dbusmenu_menuitem_child_add_position (priv->root_menuitem, voip_input_menu_item, 2);
+
+  if (!priv->greeter_mode) {
+    // Separator
+    DbusmenuMenuitem* separator = dbusmenu_menuitem_new();
+
+    dbusmenu_menuitem_property_set (separator,
+                                    DBUSMENU_MENUITEM_PROP_TYPE,
+                                    DBUSMENU_CLIENT_TYPES_SEPARATOR);
+    dbusmenu_menuitem_child_add_position (priv->root_menuitem, separator, 3);
+    g_object_unref (separator);
+
+    // Sound preferences dialog
+    DbusmenuMenuitem* settings_mi = dbusmenu_menuitem_new();
+
+    dbusmenu_menuitem_property_set( settings_mi,
+                                    DBUSMENU_MENUITEM_PROP_LABEL,
+                                    _("Sound Settings..."));
+    dbusmenu_menuitem_child_append(priv->root_menuitem, settings_mi);
+    g_object_unref (settings_mi);  
+    g_signal_connect(G_OBJECT(settings_mi), DBUSMENU_MENUITEM_SIGNAL_ITEM_ACTIVATED,
+                     G_CALLBACK(show_sound_settings_dialog), NULL);  
+  }
+}
+
+/**
+show_sound_settings_dialog:
+Bring up the gnome volume preferences dialog
+**/
+static void
+show_sound_settings_dialog (DbusmenuMenuitem *mi,
+                            gpointer user_data)
+{
+  GError * error = NULL;
+  if (!g_spawn_command_line_async("gnome-volume-control --page=applications", &error) &&
+      !g_spawn_command_line_async("gnome-control-center sound", &error) && 
+      !g_spawn_command_line_async("xfce4-mixer", &error))
+  {
+    g_warning("Unable to show dialog: %s", error->message);
+    g_error_free(error);
+  }
+}
+
+static void
+sound_service_dbus_dispose (GObject *object)
+{
+  SoundServiceDbusPrivate *priv = SOUND_SERVICE_DBUS_GET_PRIVATE (object);
+
+  if (priv->connection && priv->registration_id) {
+    g_dbus_connection_unregister_object (priv->connection, priv->registration_id);
+    priv->registration_id = 0;
+  }
+
+  g_clear_object(&priv->connection);
+
+  G_OBJECT_CLASS (sound_service_dbus_parent_class)->dispose (object);
+  //TODO dispose of the active sink instance !
+  return;
+}
+
+static void
+sound_service_dbus_finalize (GObject *object)
+{
+  G_OBJECT_CLASS (sound_service_dbus_parent_class)->finalize (object);
+  return;
+}
+
+
+// EMIT STATE SIGNAL
+void 
+sound_service_dbus_update_sound_state (SoundServiceDbus* self,
+                                       SoundState new_state)
+{
+  SoundServiceDbusPrivate *priv = SOUND_SERVICE_DBUS_GET_PRIVATE (self);
+
+  GVariant* v_output = g_variant_new("(i)", (int)new_state);
+
+  GError * error = NULL;
+
+  if (priv->connection == NULL ||
+      g_dbus_connection_is_closed (priv->connection) == TRUE){
+    g_critical ("sound_service_dbus_update_sound_state - dbus connection is %s !!",
+                priv->connection == NULL? "NULL" : "closed");
+    return;
+  }
+
+  //g_debug ("emitting state signal with value %i", (int)new_state);
+  g_dbus_connection_emit_signal( priv->connection,
+                                 NULL,
+                                 INDICATOR_SOUND_SERVICE_DBUS_OBJECT_PATH,
+                                 INDICATOR_SOUND_DBUS_INTERFACE,
+                                 INDICATOR_SOUND_SIGNAL_STATE_UPDATE,
+                                 v_output,
+                                 &error );
+  if (error != NULL) {
+    g_critical ("Unable to emit signal because : %s", error->message);
+    g_error_free(error);
+  }
+}
+
+//HANDLE DBUS METHOD CALLS
+static void
+bus_method_call (GDBusConnection * connection,
+                 const gchar * sender,
+                 const gchar * path,
+                 const gchar * interface,
+                 const gchar * method,
+                 GVariant * params,
+                 GDBusMethodInvocation * invocation,
+                 gpointer user_data)
+{ 
+  SoundServiceDbus* service = SOUND_SERVICE_DBUS(user_data); 
+  g_return_if_fail ( IS_SOUND_SERVICE_DBUS(service) );
+  GVariant * retval = NULL;
+  SoundServiceDbusPrivate *priv = SOUND_SERVICE_DBUS_GET_PRIVATE (service);
+
+  if (g_strcmp0(method, "GetSoundState") == 0) {
+    g_debug("Get state -  %i", device_get_state (priv->device));
+    retval =  g_variant_new ( "(i)", device_get_state (priv->device));
+  }   
+  else if (g_strcmp0(method, "BlacklistMediaPlayer") == 0) {    
+    gboolean blacklist;
+    const gchar* player_name;
+    g_variant_get (params, "(&sb)", &player_name, &blacklist);
+                   
+    g_debug ("BlacklistMediaPlayer - bool %i", blacklist); 
+    g_debug ("BlacklistMediaPlayer - name %s", player_name); 
+    gboolean result = sound_service_dbus_blacklist_player (service,                                                           
+                                                           player_name,
+                                                           blacklist);
+    retval =  g_variant_new ("(b)", result);
+  }
+  else if (g_strcmp0(method, "IsBlacklisted") == 0) {
+    const gchar* player_name;
+    g_variant_get (params, "(&s)", &player_name);
+
+    g_debug ("IsBlacklisted - name %s", player_name);
+    gboolean result = sound_service_dbus_is_blacklisted (service,
+                                                         player_name);
+    retval =  g_variant_new ("(b)", result);
+  }
+  else if (g_strcmp0(method, "EnableTrackSpecificItems") == 0) {
+    g_debug ("EnableTrackSpecificItems");
+    gchar* player_object_path;
+    gchar* player_id;
+    g_variant_get (params, "(os)", &player_object_path, &player_id);
+    //g_debug ("object path = %s and id = %s", player_object_path, player_id);
+    g_signal_emit (service,
+                   signals[TRACK_SPECIFIC_ITEM],
+                   0,
+                   player_object_path,
+                   player_id);
+    g_free (player_object_path);
+    g_free (player_id);
+    
+  }
+  else if (g_strcmp0(method, "EnablePlayerSpecificItems") == 0) {
+    gchar* player_object_path;
+    gchar* player_id;
+    g_variant_get (params, "(os)", &player_object_path, &player_id);
+    g_debug ("PLayer specific item - object path = %s and id = %s",
+            player_object_path,
+            player_id);
+    g_signal_emit (service,
+                   signals[PLAYER_SPECIFIC_ITEM],
+                   0,
+                   player_object_path,
+                   player_id);
+    g_free (player_object_path);
+    g_free (player_id);
+  }
+  else {
+    g_warning("Calling method '%s' on the sound service but it's unknown", method); 
+  }
+  g_dbus_method_invocation_return_value (invocation, retval);
+}
+
+/**
+ TODO - Works nicely but refactor into at least two different methods
+**/
+static gboolean sound_service_dbus_blacklist_player (SoundServiceDbus* self,
+                                                     const gchar* player_name,
+                                                     gboolean blacklist) 
+{
+  g_return_val_if_fail (player_name != NULL, FALSE);
+  g_return_val_if_fail (IS_SOUND_SERVICE_DBUS (self), FALSE);
+
+  GVariant* the_black_list;
+  gboolean result = FALSE;
+  GSettings* our_settings;
+  GVariantIter iter;
+  gchar *str;
+  GVariantBuilder builder;
+
+  our_settings  = g_settings_new ("com.canonical.indicator.sound");
+  the_black_list = g_settings_get_value (our_settings,
+                                         "blacklisted-media-players");  
+  g_variant_iter_init (&iter, the_black_list);
+  g_variant_builder_init(&builder, G_VARIANT_TYPE_STRING_ARRAY);  
+
+  while (g_variant_iter_loop (&iter, "s", &str)){
+    g_variant_builder_add (&builder, "s", str);
+  }
+  g_variant_iter_init (&iter, the_black_list);
+
+  if (blacklist == TRUE){
+    while (g_variant_iter_loop (&iter, "s", &str)){
+      g_print ("first pass to check if %s is present\n", str);
+      if (g_strcmp0 (player_name, str) == 0){
+        // Return if its already there
+        g_debug ("we have this already blacklisted, no need to do anything");
+        g_variant_builder_clear (&builder);
+        g_object_unref (our_settings);
+        g_variant_unref (the_black_list);
+        return result;
+      }
+    }
+    // Otherwise blacklist it !
+    g_debug ("about to blacklist %s", player_name);
+    g_variant_builder_add (&builder, "s", player_name);
+  }
+  else{
+    gboolean present = FALSE;
+    g_variant_iter_init (&iter, the_black_list);
+    g_debug ("attempting to UN-blacklist %s", player_name);
+        
+    while (g_variant_iter_loop (&iter, "s", &str)){
+      if (g_strcmp0 (player_name, str) == 0){      
+        present = TRUE;
+      }
+    }
+    // It was not there anyway, return false
+    if (present == FALSE){
+      g_debug ("it was not blacklisted ?, no need to do anything");
+      g_variant_builder_clear (&builder);
+      g_object_unref (our_settings);
+      g_variant_unref (the_black_list);
+      return result;
+    }
+    
+    // Otherwise free the builder and reconstruct ensuring no duplicates.
+    g_variant_builder_clear (&builder);  
+    g_variant_builder_init (&builder, G_VARIANT_TYPE_STRING_ARRAY);  
+
+    g_variant_iter_init (&iter, the_black_list);
+    
+    while (g_variant_iter_loop (&iter, "s", &str)){
+      if (g_strcmp0 (player_name, str) != 0){            
+        g_variant_builder_add (&builder, "s", str);
+      }
+    }
+  }
+  GVariant* value = g_variant_builder_end (&builder);
+  result = g_settings_set_value (our_settings,
+                                 "blacklisted-media-players",
+                                 value);
+
+  g_object_unref (our_settings);
+  g_variant_unref (the_black_list);
+  
+  return result;
+}
+
+static gboolean sound_service_dbus_is_blacklisted (SoundServiceDbus *self,
+                                                   const gchar      *player_name)
+{
+  GSettings    *our_settings;
+  GVariant     *the_black_list;
+  GVariantIter  iter;
+  gchar        *str;
+  gboolean      result = FALSE;
+
+  g_return_val_if_fail (player_name != NULL, FALSE);
+  g_return_val_if_fail (IS_SOUND_SERVICE_DBUS (self), FALSE);
+
+  our_settings = g_settings_new ("com.canonical.indicator.sound");
+  the_black_list = g_settings_get_value (our_settings,
+                                         "blacklisted-media-players");
+  g_variant_iter_init (&iter, the_black_list);
+  while (g_variant_iter_next (&iter, "s", &str)){
+    if (g_strcmp0 (player_name, str) == 0) {
+      result = TRUE;
+      g_free (str);
+      break;
+    }
+    g_free (str);
+  }
+
+  g_object_unref (our_settings);
+  g_variant_unref (the_black_list);
+
+  return result;
+}
+
diff -Naur indicator-sound-0.8.5.0/.pc/sound_ubuntustudio.patch/src/sound-service-dbus.c indicator-sound-precise/.pc/sound_ubuntustudio.patch/src/sound-service-dbus.c
--- indicator-sound-0.8.5.0/.pc/sound_ubuntustudio.patch/src/sound-service-dbus.c	1969-12-31 16:00:00.000000000 -0800
+++ indicator-sound-precise/.pc/sound_ubuntustudio.patch/src/sound-service-dbus.c	2012-07-26 21:03:55.488143000 -0700
@@ -0,0 +1,497 @@
+/*
+ * Copyright 2010 Canonical Ltd.
+ *
+ * Authors:
+ *     Conor Curran <conor.curran@canonical.com>
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 3, as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranties of
+ * MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
+ * PURPOSE.  See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gio/gio.h>
+#include <unistd.h>
+#include <glib/gi18n.h>
+#include <libindicator/indicator-service.h>
+#include <libdbusmenu-glib/server.h>
+#include <libdbusmenu-glib/client.h>
+
+#include "sound-service-dbus.h"
+#include "device.h"
+#include "gen-sound-service.xml.h"
+#include "dbus-shared-names.h"
+#include "sound-service-marshal.h"
+
+// DBUS methods
+static void bus_method_call (GDBusConnection * connection,
+                             const gchar * sender,
+                             const gchar * path,
+                             const gchar * interface,
+                             const gchar * method,
+                             GVariant * params, 
+                             GDBusMethodInvocation * invocation,
+                             gpointer user_data);
+
+static GDBusInterfaceVTable       interface_table = {
+	method_call:	bus_method_call,
+	get_property:	NULL, /* No properties */
+	set_property:	NULL  /* No properties */
+};
+
+
+typedef struct _SoundServiceDbusPrivate SoundServiceDbusPrivate;
+
+struct _SoundServiceDbusPrivate {
+  GDBusConnection*    connection;
+  DbusmenuMenuitem*   root_menuitem;
+  Device*             device;
+  gboolean            greeter_mode;
+  guint               registration_id;
+};
+
+enum {
+  TRACK_SPECIFIC_ITEM,
+  PLAYER_SPECIFIC_ITEM,  
+  LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = { 0 };
+
+static GDBusNodeInfo *            node_info = NULL;
+static GDBusInterfaceInfo *       interface_info = NULL;
+
+#define SOUND_SERVICE_DBUS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SOUND_SERVICE_DBUS_TYPE, SoundServiceDbusPrivate))
+
+static void sound_service_dbus_class_init (SoundServiceDbusClass *klass);
+static void sound_service_dbus_init       (SoundServiceDbus *self);
+static void sound_service_dbus_dispose    (GObject *object);
+static void sound_service_dbus_finalize   (GObject *object);
+
+static void show_sound_settings_dialog (DbusmenuMenuitem *mi,
+                                        gpointer user_data);
+static gboolean sound_service_dbus_blacklist_player (SoundServiceDbus* self,
+                                                     const gchar* player_name,
+                                                     gboolean blacklist); 
+
+static gboolean sound_service_dbus_is_blacklisted (SoundServiceDbus* self,
+                                                   const gchar* player_name);
+
+G_DEFINE_TYPE (SoundServiceDbus, sound_service_dbus, G_TYPE_OBJECT);
+
+static void
+sound_service_dbus_class_init (SoundServiceDbusClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (object_class, sizeof(SoundServiceDbusPrivate));
+
+  object_class->dispose = sound_service_dbus_dispose;
+  object_class->finalize = sound_service_dbus_finalize;
+
+  g_assert(klass != NULL);
+
+  if (node_info == NULL) {
+    GError * error = NULL;
+
+    node_info = g_dbus_node_info_new_for_xml(_sound_service, &error);
+    if (error != NULL) {
+      g_critical ("Unable to parse Indicator Service Interface description: %s",
+               error->message);
+      g_error_free(error);
+    }
+  }
+
+  if (interface_info == NULL) {
+    interface_info = g_dbus_node_info_lookup_interface (node_info,
+                                                        INDICATOR_SOUND_DBUS_INTERFACE);
+
+    if (interface_info == NULL) {
+      g_critical("Unable to find interface '" INDICATOR_SOUND_DBUS_INTERFACE "'");
+    }
+  }
+  signals[TRACK_SPECIFIC_ITEM] =  g_signal_new("track-specific-item-requested",
+                                                G_TYPE_FROM_CLASS (klass),
+                                                G_SIGNAL_RUN_LAST,
+                                                0,
+                                                NULL, NULL,
+                                                _sound_service_marshal_VOID__STRING_STRING,
+                                                G_TYPE_NONE, 2, G_TYPE_STRING,
+                                                G_TYPE_STRING);  
+  signals[PLAYER_SPECIFIC_ITEM] =  g_signal_new("player-specific-item-requested",
+                                                G_TYPE_FROM_CLASS (klass),
+                                                G_SIGNAL_RUN_LAST,
+                                                0,
+                                                NULL, NULL,
+                                                _sound_service_marshal_VOID__STRING_STRING,
+                                                G_TYPE_NONE, 2, G_TYPE_STRING,
+                                                G_TYPE_STRING);  
+}
+
+static void
+sound_service_dbus_init (SoundServiceDbus *self)
+{
+  GError *error = NULL;
+  SoundServiceDbusPrivate * priv = SOUND_SERVICE_DBUS_GET_PRIVATE(self);
+
+  priv->connection = NULL;
+
+  /* Fetch the session bus */
+  priv->connection = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, &error);
+
+  if (error != NULL) {
+    g_critical ("sound-service-dbus:Unable to connect to the session bus when creating indicator sound service : %s", error->message);
+    g_error_free (error);
+    return;
+  }
+  /* register the service on it */
+  priv->registration_id = g_dbus_connection_register_object (priv->connection,
+                                                             INDICATOR_SOUND_SERVICE_DBUS_OBJECT_PATH,
+                                                             interface_info,
+                                                             &interface_table,
+                                                             self,
+                                                             NULL,
+                                                             &error);
+  if (error != NULL) {
+    g_critical ("Unable to register the sound service on DBus: %s", error->message);
+    g_error_free (error);
+  }
+}
+
+DbusmenuMenuitem*
+sound_service_dbus_create_root_item (SoundServiceDbus* self, gboolean greeter_mode)
+{
+  SoundServiceDbusPrivate * priv = SOUND_SERVICE_DBUS_GET_PRIVATE(self);
+  priv->greeter_mode = greeter_mode;
+  priv->root_menuitem = dbusmenu_menuitem_new();
+  DbusmenuServer *server = dbusmenu_server_new (INDICATOR_SOUND_MENU_DBUS_OBJECT_PATH);
+  dbusmenu_server_set_root (server, priv->root_menuitem);
+  g_object_unref (priv->root_menuitem);
+  priv->device = device_new (self);
+  return priv->root_menuitem;
+}
+
+void
+sound_service_dbus_build_sound_menu ( SoundServiceDbus* self,
+                                      DbusmenuMenuitem* mute_item,
+                                      DbusmenuMenuitem* slider_item,
+                                      DbusmenuMenuitem* voip_input_menu_item)
+{
+  SoundServiceDbusPrivate * priv = SOUND_SERVICE_DBUS_GET_PRIVATE(self);
+
+  // Mute, Volume and Voip widgets
+  dbusmenu_menuitem_child_add_position (priv->root_menuitem, mute_item, 0);
+  dbusmenu_menuitem_child_add_position (priv->root_menuitem, slider_item, 1);
+  dbusmenu_menuitem_child_add_position (priv->root_menuitem, voip_input_menu_item, 2);
+
+  if (!priv->greeter_mode) {
+    // Separator
+    DbusmenuMenuitem* separator = dbusmenu_menuitem_new();
+
+    dbusmenu_menuitem_property_set (separator,
+                                    DBUSMENU_MENUITEM_PROP_TYPE,
+                                    DBUSMENU_CLIENT_TYPES_SEPARATOR);
+    dbusmenu_menuitem_child_add_position (priv->root_menuitem, separator, 3);
+    g_object_unref (separator);
+
+    // Sound preferences dialog
+    DbusmenuMenuitem* settings_mi = dbusmenu_menuitem_new();
+
+    dbusmenu_menuitem_property_set( settings_mi,
+                                    DBUSMENU_MENUITEM_PROP_LABEL,
+                                    _("Sound Settings..."));
+    dbusmenu_menuitem_child_append(priv->root_menuitem, settings_mi);
+    g_object_unref (settings_mi);  
+    g_signal_connect(G_OBJECT(settings_mi), DBUSMENU_MENUITEM_SIGNAL_ITEM_ACTIVATED,
+                     G_CALLBACK(show_sound_settings_dialog), NULL);  
+  }
+}
+
+/**
+show_sound_settings_dialog:
+Bring up the gnome volume preferences dialog
+**/
+static void
+show_sound_settings_dialog (DbusmenuMenuitem *mi,
+                            gpointer user_data)
+{
+  GError * error = NULL;
+  gchar* cmd;
+  if (!g_strcmp0 (g_getenv ("XDG_CURRENT_DESKTOP"), "Unity"))
+    cmd = "gnome-control-center sound-nua";
+  else if (!g_strcmp0 (g_getenv ("DESKTOP_SESSION"), "xubuntu"))
+    cmd = "pavucontrol";
+  else
+    cmd = "gnome-control-center sound";
+
+  if (!g_spawn_command_line_async("gnome-volume-control --page=applications", &error) &&
+          !g_spawn_command_line_async(cmd, &error) && 
+      !g_spawn_command_line_async("xfce4-mixer", &error))
+  {
+    g_warning("Unable to show dialog: %s", error->message);
+    g_error_free(error);
+  }
+}
+
+static void
+sound_service_dbus_dispose (GObject *object)
+{
+  SoundServiceDbusPrivate *priv = SOUND_SERVICE_DBUS_GET_PRIVATE (object);
+
+  if (priv->connection && priv->registration_id) {
+    g_dbus_connection_unregister_object (priv->connection, priv->registration_id);
+    priv->registration_id = 0;
+  }
+
+  g_clear_object(&priv->connection);
+
+  G_OBJECT_CLASS (sound_service_dbus_parent_class)->dispose (object);
+  //TODO dispose of the active sink instance !
+  return;
+}
+
+static void
+sound_service_dbus_finalize (GObject *object)
+{
+  G_OBJECT_CLASS (sound_service_dbus_parent_class)->finalize (object);
+  return;
+}
+
+
+// EMIT STATE SIGNAL
+void 
+sound_service_dbus_update_sound_state (SoundServiceDbus* self,
+                                       SoundState new_state)
+{
+  SoundServiceDbusPrivate *priv = SOUND_SERVICE_DBUS_GET_PRIVATE (self);
+
+  GVariant* v_output = g_variant_new("(i)", (int)new_state);
+
+  GError * error = NULL;
+
+  if (priv->connection == NULL ||
+      g_dbus_connection_is_closed (priv->connection) == TRUE){
+    g_critical ("sound_service_dbus_update_sound_state - dbus connection is %s !!",
+                priv->connection == NULL? "NULL" : "closed");
+    return;
+  }
+
+  //g_debug ("emitting state signal with value %i", (int)new_state);
+  g_dbus_connection_emit_signal( priv->connection,
+                                 NULL,
+                                 INDICATOR_SOUND_SERVICE_DBUS_OBJECT_PATH,
+                                 INDICATOR_SOUND_DBUS_INTERFACE,
+                                 INDICATOR_SOUND_SIGNAL_STATE_UPDATE,
+                                 v_output,
+                                 &error );
+  if (error != NULL) {
+    g_critical ("Unable to emit signal because : %s", error->message);
+    g_error_free(error);
+  }
+}
+
+//HANDLE DBUS METHOD CALLS
+static void
+bus_method_call (GDBusConnection * connection,
+                 const gchar * sender,
+                 const gchar * path,
+                 const gchar * interface,
+                 const gchar * method,
+                 GVariant * params,
+                 GDBusMethodInvocation * invocation,
+                 gpointer user_data)
+{ 
+  SoundServiceDbus* service = SOUND_SERVICE_DBUS(user_data); 
+  g_return_if_fail ( IS_SOUND_SERVICE_DBUS(service) );
+  GVariant * retval = NULL;
+  SoundServiceDbusPrivate *priv = SOUND_SERVICE_DBUS_GET_PRIVATE (service);
+
+  if (g_strcmp0(method, "GetSoundState") == 0) {
+    g_debug("Get state -  %i", device_get_state (priv->device));
+    retval =  g_variant_new ( "(i)", device_get_state (priv->device));
+  }   
+  else if (g_strcmp0(method, "BlacklistMediaPlayer") == 0) {    
+    gboolean blacklist;
+    const gchar* player_name;
+    g_variant_get (params, "(&sb)", &player_name, &blacklist);
+                   
+    g_debug ("BlacklistMediaPlayer - bool %i", blacklist); 
+    g_debug ("BlacklistMediaPlayer - name %s", player_name); 
+    gboolean result = sound_service_dbus_blacklist_player (service,                                                           
+                                                           player_name,
+                                                           blacklist);
+    retval =  g_variant_new ("(b)", result);
+  }
+  else if (g_strcmp0(method, "IsBlacklisted") == 0) {
+    const gchar* player_name;
+    g_variant_get (params, "(&s)", &player_name);
+
+    g_debug ("IsBlacklisted - name %s", player_name);
+    gboolean result = sound_service_dbus_is_blacklisted (service,
+                                                         player_name);
+    retval =  g_variant_new ("(b)", result);
+  }
+  else if (g_strcmp0(method, "EnableTrackSpecificItems") == 0) {
+    g_debug ("EnableTrackSpecificItems");
+    gchar* player_object_path;
+    gchar* player_id;
+    g_variant_get (params, "(os)", &player_object_path, &player_id);
+    //g_debug ("object path = %s and id = %s", player_object_path, player_id);
+    g_signal_emit (service,
+                   signals[TRACK_SPECIFIC_ITEM],
+                   0,
+                   player_object_path,
+                   player_id);
+    g_free (player_object_path);
+    g_free (player_id);
+    
+  }
+  else if (g_strcmp0(method, "EnablePlayerSpecificItems") == 0) {
+    gchar* player_object_path;
+    gchar* player_id;
+    g_variant_get (params, "(os)", &player_object_path, &player_id);
+    g_debug ("PLayer specific item - object path = %s and id = %s",
+            player_object_path,
+            player_id);
+    g_signal_emit (service,
+                   signals[PLAYER_SPECIFIC_ITEM],
+                   0,
+                   player_object_path,
+                   player_id);
+    g_free (player_object_path);
+    g_free (player_id);
+  }
+  else {
+    g_warning("Calling method '%s' on the sound service but it's unknown", method); 
+  }
+  g_dbus_method_invocation_return_value (invocation, retval);
+}
+
+/**
+ TODO - Works nicely but refactor into at least two different methods
+**/
+static gboolean sound_service_dbus_blacklist_player (SoundServiceDbus* self,
+                                                     const gchar* player_name,
+                                                     gboolean blacklist) 
+{
+  g_return_val_if_fail (player_name != NULL, FALSE);
+  g_return_val_if_fail (IS_SOUND_SERVICE_DBUS (self), FALSE);
+
+  GVariant* the_black_list;
+  gboolean result = FALSE;
+  GSettings* our_settings;
+  GVariantIter iter;
+  gchar *str;
+  GVariantBuilder builder;
+
+  our_settings  = g_settings_new ("com.canonical.indicator.sound");
+  the_black_list = g_settings_get_value (our_settings,
+                                         "blacklisted-media-players");  
+  g_variant_iter_init (&iter, the_black_list);
+  g_variant_builder_init(&builder, G_VARIANT_TYPE_STRING_ARRAY);  
+
+  while (g_variant_iter_loop (&iter, "s", &str)){
+    g_variant_builder_add (&builder, "s", str);
+  }
+  g_variant_iter_init (&iter, the_black_list);
+
+  if (blacklist == TRUE){
+    while (g_variant_iter_loop (&iter, "s", &str)){
+      g_print ("first pass to check if %s is present\n", str);
+      if (g_strcmp0 (player_name, str) == 0){
+        // Return if its already there
+        g_debug ("we have this already blacklisted, no need to do anything");
+        g_variant_builder_clear (&builder);
+        g_object_unref (our_settings);
+        g_variant_unref (the_black_list);
+        return result;
+      }
+    }
+    // Otherwise blacklist it !
+    g_debug ("about to blacklist %s", player_name);
+    g_variant_builder_add (&builder, "s", player_name);
+  }
+  else{
+    gboolean present = FALSE;
+    g_variant_iter_init (&iter, the_black_list);
+    g_debug ("attempting to UN-blacklist %s", player_name);
+        
+    while (g_variant_iter_loop (&iter, "s", &str)){
+      if (g_strcmp0 (player_name, str) == 0){      
+        present = TRUE;
+      }
+    }
+    // It was not there anyway, return false
+    if (present == FALSE){
+      g_debug ("it was not blacklisted ?, no need to do anything");
+      g_variant_builder_clear (&builder);
+      g_object_unref (our_settings);
+      g_variant_unref (the_black_list);
+      return result;
+    }
+    
+    // Otherwise free the builder and reconstruct ensuring no duplicates.
+    g_variant_builder_clear (&builder);  
+    g_variant_builder_init (&builder, G_VARIANT_TYPE_STRING_ARRAY);  
+
+    g_variant_iter_init (&iter, the_black_list);
+    
+    while (g_variant_iter_loop (&iter, "s", &str)){
+      if (g_strcmp0 (player_name, str) != 0){            
+        g_variant_builder_add (&builder, "s", str);
+      }
+    }
+  }
+  GVariant* value = g_variant_builder_end (&builder);
+  result = g_settings_set_value (our_settings,
+                                 "blacklisted-media-players",
+                                 value);
+
+  g_object_unref (our_settings);
+  g_variant_unref (the_black_list);
+  
+  return result;
+}
+
+static gboolean sound_service_dbus_is_blacklisted (SoundServiceDbus *self,
+                                                   const gchar      *player_name)
+{
+  GSettings    *our_settings;
+  GVariant     *the_black_list;
+  GVariantIter  iter;
+  gchar        *str;
+  gboolean      result = FALSE;
+
+  g_return_val_if_fail (player_name != NULL, FALSE);
+  g_return_val_if_fail (IS_SOUND_SERVICE_DBUS (self), FALSE);
+
+  our_settings = g_settings_new ("com.canonical.indicator.sound");
+  the_black_list = g_settings_get_value (our_settings,
+                                         "blacklisted-media-players");
+  g_variant_iter_init (&iter, the_black_list);
+  while (g_variant_iter_next (&iter, "s", &str)){
+    if (g_strcmp0 (player_name, str) == 0) {
+      result = TRUE;
+      g_free (str);
+      break;
+    }
+    g_free (str);
+  }
+
+  g_object_unref (our_settings);
+  g_variant_unref (the_black_list);
+
+  return result;
+}
+
diff -Naur indicator-sound-0.8.5.0/.pc/sound_xubuntu.patch/src/sound-service-dbus.c indicator-sound-precise/.pc/sound_xubuntu.patch/src/sound-service-dbus.c
--- indicator-sound-0.8.5.0/.pc/sound_xubuntu.patch/src/sound-service-dbus.c	1969-12-31 16:00:00.000000000 -0800
+++ indicator-sound-precise/.pc/sound_xubuntu.patch/src/sound-service-dbus.c	2012-07-26 21:03:55.488143000 -0700
@@ -0,0 +1,495 @@
+/*
+ * Copyright 2010 Canonical Ltd.
+ *
+ * Authors:
+ *     Conor Curran <conor.curran@canonical.com>
+ *
+ * This program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 3, as published
+ * by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranties of
+ * MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
+ * PURPOSE.  See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gio/gio.h>
+#include <unistd.h>
+#include <glib/gi18n.h>
+#include <libindicator/indicator-service.h>
+#include <libdbusmenu-glib/server.h>
+#include <libdbusmenu-glib/client.h>
+
+#include "sound-service-dbus.h"
+#include "device.h"
+#include "gen-sound-service.xml.h"
+#include "dbus-shared-names.h"
+#include "sound-service-marshal.h"
+
+// DBUS methods
+static void bus_method_call (GDBusConnection * connection,
+                             const gchar * sender,
+                             const gchar * path,
+                             const gchar * interface,
+                             const gchar * method,
+                             GVariant * params, 
+                             GDBusMethodInvocation * invocation,
+                             gpointer user_data);
+
+static GDBusInterfaceVTable       interface_table = {
+	method_call:	bus_method_call,
+	get_property:	NULL, /* No properties */
+	set_property:	NULL  /* No properties */
+};
+
+
+typedef struct _SoundServiceDbusPrivate SoundServiceDbusPrivate;
+
+struct _SoundServiceDbusPrivate {
+  GDBusConnection*    connection;
+  DbusmenuMenuitem*   root_menuitem;
+  Device*             device;
+  gboolean            greeter_mode;
+  guint               registration_id;
+};
+
+enum {
+  TRACK_SPECIFIC_ITEM,
+  PLAYER_SPECIFIC_ITEM,  
+  LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = { 0 };
+
+static GDBusNodeInfo *            node_info = NULL;
+static GDBusInterfaceInfo *       interface_info = NULL;
+
+#define SOUND_SERVICE_DBUS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SOUND_SERVICE_DBUS_TYPE, SoundServiceDbusPrivate))
+
+static void sound_service_dbus_class_init (SoundServiceDbusClass *klass);
+static void sound_service_dbus_init       (SoundServiceDbus *self);
+static void sound_service_dbus_dispose    (GObject *object);
+static void sound_service_dbus_finalize   (GObject *object);
+
+static void show_sound_settings_dialog (DbusmenuMenuitem *mi,
+                                        gpointer user_data);
+static gboolean sound_service_dbus_blacklist_player (SoundServiceDbus* self,
+                                                     const gchar* player_name,
+                                                     gboolean blacklist); 
+
+static gboolean sound_service_dbus_is_blacklisted (SoundServiceDbus* self,
+                                                   const gchar* player_name);
+
+G_DEFINE_TYPE (SoundServiceDbus, sound_service_dbus, G_TYPE_OBJECT);
+
+static void
+sound_service_dbus_class_init (SoundServiceDbusClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (object_class, sizeof(SoundServiceDbusPrivate));
+
+  object_class->dispose = sound_service_dbus_dispose;
+  object_class->finalize = sound_service_dbus_finalize;
+
+  g_assert(klass != NULL);
+
+  if (node_info == NULL) {
+    GError * error = NULL;
+
+    node_info = g_dbus_node_info_new_for_xml(_sound_service, &error);
+    if (error != NULL) {
+      g_critical ("Unable to parse Indicator Service Interface description: %s",
+               error->message);
+      g_error_free(error);
+    }
+  }
+
+  if (interface_info == NULL) {
+    interface_info = g_dbus_node_info_lookup_interface (node_info,
+                                                        INDICATOR_SOUND_DBUS_INTERFACE);
+
+    if (interface_info == NULL) {
+      g_critical("Unable to find interface '" INDICATOR_SOUND_DBUS_INTERFACE "'");
+    }
+  }
+  signals[TRACK_SPECIFIC_ITEM] =  g_signal_new("track-specific-item-requested",
+                                                G_TYPE_FROM_CLASS (klass),
+                                                G_SIGNAL_RUN_LAST,
+                                                0,
+                                                NULL, NULL,
+                                                _sound_service_marshal_VOID__STRING_STRING,
+                                                G_TYPE_NONE, 2, G_TYPE_STRING,
+                                                G_TYPE_STRING);  
+  signals[PLAYER_SPECIFIC_ITEM] =  g_signal_new("player-specific-item-requested",
+                                                G_TYPE_FROM_CLASS (klass),
+                                                G_SIGNAL_RUN_LAST,
+                                                0,
+                                                NULL, NULL,
+                                                _sound_service_marshal_VOID__STRING_STRING,
+                                                G_TYPE_NONE, 2, G_TYPE_STRING,
+                                                G_TYPE_STRING);  
+}
+
+static void
+sound_service_dbus_init (SoundServiceDbus *self)
+{
+  GError *error = NULL;
+  SoundServiceDbusPrivate * priv = SOUND_SERVICE_DBUS_GET_PRIVATE(self);
+
+  priv->connection = NULL;
+
+  /* Fetch the session bus */
+  priv->connection = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, &error);
+
+  if (error != NULL) {
+    g_critical ("sound-service-dbus:Unable to connect to the session bus when creating indicator sound service : %s", error->message);
+    g_error_free (error);
+    return;
+  }
+  /* register the service on it */
+  priv->registration_id = g_dbus_connection_register_object (priv->connection,
+                                                             INDICATOR_SOUND_SERVICE_DBUS_OBJECT_PATH,
+                                                             interface_info,
+                                                             &interface_table,
+                                                             self,
+                                                             NULL,
+                                                             &error);
+  if (error != NULL) {
+    g_critical ("Unable to register the sound service on DBus: %s", error->message);
+    g_error_free (error);
+  }
+}
+
+DbusmenuMenuitem*
+sound_service_dbus_create_root_item (SoundServiceDbus* self, gboolean greeter_mode)
+{
+  SoundServiceDbusPrivate * priv = SOUND_SERVICE_DBUS_GET_PRIVATE(self);
+  priv->greeter_mode = greeter_mode;
+  priv->root_menuitem = dbusmenu_menuitem_new();
+  DbusmenuServer *server = dbusmenu_server_new (INDICATOR_SOUND_MENU_DBUS_OBJECT_PATH);
+  dbusmenu_server_set_root (server, priv->root_menuitem);
+  g_object_unref (priv->root_menuitem);
+  priv->device = device_new (self);
+  return priv->root_menuitem;
+}
+
+void
+sound_service_dbus_build_sound_menu ( SoundServiceDbus* self,
+                                      DbusmenuMenuitem* mute_item,
+                                      DbusmenuMenuitem* slider_item,
+                                      DbusmenuMenuitem* voip_input_menu_item)
+{
+  SoundServiceDbusPrivate * priv = SOUND_SERVICE_DBUS_GET_PRIVATE(self);
+
+  // Mute, Volume and Voip widgets
+  dbusmenu_menuitem_child_add_position (priv->root_menuitem, mute_item, 0);
+  dbusmenu_menuitem_child_add_position (priv->root_menuitem, slider_item, 1);
+  dbusmenu_menuitem_child_add_position (priv->root_menuitem, voip_input_menu_item, 2);
+
+  if (!priv->greeter_mode) {
+    // Separator
+    DbusmenuMenuitem* separator = dbusmenu_menuitem_new();
+
+    dbusmenu_menuitem_property_set (separator,
+                                    DBUSMENU_MENUITEM_PROP_TYPE,
+                                    DBUSMENU_CLIENT_TYPES_SEPARATOR);
+    dbusmenu_menuitem_child_add_position (priv->root_menuitem, separator, 3);
+    g_object_unref (separator);
+
+    // Sound preferences dialog
+    DbusmenuMenuitem* settings_mi = dbusmenu_menuitem_new();
+
+    dbusmenu_menuitem_property_set( settings_mi,
+                                    DBUSMENU_MENUITEM_PROP_LABEL,
+                                    _("Sound Settings..."));
+    dbusmenu_menuitem_child_append(priv->root_menuitem, settings_mi);
+    g_object_unref (settings_mi);  
+    g_signal_connect(G_OBJECT(settings_mi), DBUSMENU_MENUITEM_SIGNAL_ITEM_ACTIVATED,
+                     G_CALLBACK(show_sound_settings_dialog), NULL);  
+  }
+}
+
+/**
+show_sound_settings_dialog:
+Bring up the gnome volume preferences dialog
+**/
+static void
+show_sound_settings_dialog (DbusmenuMenuitem *mi,
+                            gpointer user_data)
+{
+  GError * error = NULL;
+  gchar* cmd;
+  if (!g_strcmp0 (g_getenv ("XDG_CURRENT_DESKTOP"), "Unity"))
+    cmd = "gnome-control-center sound-nua";
+  else
+    cmd = "gnome-control-center sound";
+
+  if (!g_spawn_command_line_async("gnome-volume-control --page=applications", &error) &&
+          !g_spawn_command_line_async(cmd, &error) && 
+      !g_spawn_command_line_async("xfce4-mixer", &error))
+  {
+    g_warning("Unable to show dialog: %s", error->message);
+    g_error_free(error);
+  }
+}
+
+static void
+sound_service_dbus_dispose (GObject *object)
+{
+  SoundServiceDbusPrivate *priv = SOUND_SERVICE_DBUS_GET_PRIVATE (object);
+
+  if (priv->connection && priv->registration_id) {
+    g_dbus_connection_unregister_object (priv->connection, priv->registration_id);
+    priv->registration_id = 0;
+  }
+
+  g_clear_object(&priv->connection);
+
+  G_OBJECT_CLASS (sound_service_dbus_parent_class)->dispose (object);
+  //TODO dispose of the active sink instance !
+  return;
+}
+
+static void
+sound_service_dbus_finalize (GObject *object)
+{
+  G_OBJECT_CLASS (sound_service_dbus_parent_class)->finalize (object);
+  return;
+}
+
+
+// EMIT STATE SIGNAL
+void 
+sound_service_dbus_update_sound_state (SoundServiceDbus* self,
+                                       SoundState new_state)
+{
+  SoundServiceDbusPrivate *priv = SOUND_SERVICE_DBUS_GET_PRIVATE (self);
+
+  GVariant* v_output = g_variant_new("(i)", (int)new_state);
+
+  GError * error = NULL;
+
+  if (priv->connection == NULL ||
+      g_dbus_connection_is_closed (priv->connection) == TRUE){
+    g_critical ("sound_service_dbus_update_sound_state - dbus connection is %s !!",
+                priv->connection == NULL? "NULL" : "closed");
+    return;
+  }
+
+  //g_debug ("emitting state signal with value %i", (int)new_state);
+  g_dbus_connection_emit_signal( priv->connection,
+                                 NULL,
+                                 INDICATOR_SOUND_SERVICE_DBUS_OBJECT_PATH,
+                                 INDICATOR_SOUND_DBUS_INTERFACE,
+                                 INDICATOR_SOUND_SIGNAL_STATE_UPDATE,
+                                 v_output,
+                                 &error );
+  if (error != NULL) {
+    g_critical ("Unable to emit signal because : %s", error->message);
+    g_error_free(error);
+  }
+}
+
+//HANDLE DBUS METHOD CALLS
+static void
+bus_method_call (GDBusConnection * connection,
+                 const gchar * sender,
+                 const gchar * path,
+                 const gchar * interface,
+                 const gchar * method,
+                 GVariant * params,
+                 GDBusMethodInvocation * invocation,
+                 gpointer user_data)
+{ 
+  SoundServiceDbus* service = SOUND_SERVICE_DBUS(user_data); 
+  g_return_if_fail ( IS_SOUND_SERVICE_DBUS(service) );
+  GVariant * retval = NULL;
+  SoundServiceDbusPrivate *priv = SOUND_SERVICE_DBUS_GET_PRIVATE (service);
+
+  if (g_strcmp0(method, "GetSoundState") == 0) {
+    g_debug("Get state -  %i", device_get_state (priv->device));
+    retval =  g_variant_new ( "(i)", device_get_state (priv->device));
+  }   
+  else if (g_strcmp0(method, "BlacklistMediaPlayer") == 0) {    
+    gboolean blacklist;
+    const gchar* player_name;
+    g_variant_get (params, "(&sb)", &player_name, &blacklist);
+                   
+    g_debug ("BlacklistMediaPlayer - bool %i", blacklist); 
+    g_debug ("BlacklistMediaPlayer - name %s", player_name); 
+    gboolean result = sound_service_dbus_blacklist_player (service,                                                           
+                                                           player_name,
+                                                           blacklist);
+    retval =  g_variant_new ("(b)", result);
+  }
+  else if (g_strcmp0(method, "IsBlacklisted") == 0) {
+    const gchar* player_name;
+    g_variant_get (params, "(&s)", &player_name);
+
+    g_debug ("IsBlacklisted - name %s", player_name);
+    gboolean result = sound_service_dbus_is_blacklisted (service,
+                                                         player_name);
+    retval =  g_variant_new ("(b)", result);
+  }
+  else if (g_strcmp0(method, "EnableTrackSpecificItems") == 0) {
+    g_debug ("EnableTrackSpecificItems");
+    gchar* player_object_path;
+    gchar* player_id;
+    g_variant_get (params, "(os)", &player_object_path, &player_id);
+    //g_debug ("object path = %s and id = %s", player_object_path, player_id);
+    g_signal_emit (service,
+                   signals[TRACK_SPECIFIC_ITEM],
+                   0,
+                   player_object_path,
+                   player_id);
+    g_free (player_object_path);
+    g_free (player_id);
+    
+  }
+  else if (g_strcmp0(method, "EnablePlayerSpecificItems") == 0) {
+    gchar* player_object_path;
+    gchar* player_id;
+    g_variant_get (params, "(os)", &player_object_path, &player_id);
+    g_debug ("PLayer specific item - object path = %s and id = %s",
+            player_object_path,
+            player_id);
+    g_signal_emit (service,
+                   signals[PLAYER_SPECIFIC_ITEM],
+                   0,
+                   player_object_path,
+                   player_id);
+    g_free (player_object_path);
+    g_free (player_id);
+  }
+  else {
+    g_warning("Calling method '%s' on the sound service but it's unknown", method); 
+  }
+  g_dbus_method_invocation_return_value (invocation, retval);
+}
+
+/**
+ TODO - Works nicely but refactor into at least two different methods
+**/
+static gboolean sound_service_dbus_blacklist_player (SoundServiceDbus* self,
+                                                     const gchar* player_name,
+                                                     gboolean blacklist) 
+{
+  g_return_val_if_fail (player_name != NULL, FALSE);
+  g_return_val_if_fail (IS_SOUND_SERVICE_DBUS (self), FALSE);
+
+  GVariant* the_black_list;
+  gboolean result = FALSE;
+  GSettings* our_settings;
+  GVariantIter iter;
+  gchar *str;
+  GVariantBuilder builder;
+
+  our_settings  = g_settings_new ("com.canonical.indicator.sound");
+  the_black_list = g_settings_get_value (our_settings,
+                                         "blacklisted-media-players");  
+  g_variant_iter_init (&iter, the_black_list);
+  g_variant_builder_init(&builder, G_VARIANT_TYPE_STRING_ARRAY);  
+
+  while (g_variant_iter_loop (&iter, "s", &str)){
+    g_variant_builder_add (&builder, "s", str);
+  }
+  g_variant_iter_init (&iter, the_black_list);
+
+  if (blacklist == TRUE){
+    while (g_variant_iter_loop (&iter, "s", &str)){
+      g_print ("first pass to check if %s is present\n", str);
+      if (g_strcmp0 (player_name, str) == 0){
+        // Return if its already there
+        g_debug ("we have this already blacklisted, no need to do anything");
+        g_variant_builder_clear (&builder);
+        g_object_unref (our_settings);
+        g_variant_unref (the_black_list);
+        return result;
+      }
+    }
+    // Otherwise blacklist it !
+    g_debug ("about to blacklist %s", player_name);
+    g_variant_builder_add (&builder, "s", player_name);
+  }
+  else{
+    gboolean present = FALSE;
+    g_variant_iter_init (&iter, the_black_list);
+    g_debug ("attempting to UN-blacklist %s", player_name);
+        
+    while (g_variant_iter_loop (&iter, "s", &str)){
+      if (g_strcmp0 (player_name, str) == 0){      
+        present = TRUE;
+      }
+    }
+    // It was not there anyway, return false
+    if (present == FALSE){
+      g_debug ("it was not blacklisted ?, no need to do anything");
+      g_variant_builder_clear (&builder);
+      g_object_unref (our_settings);
+      g_variant_unref (the_black_list);
+      return result;
+    }
+    
+    // Otherwise free the builder and reconstruct ensuring no duplicates.
+    g_variant_builder_clear (&builder);  
+    g_variant_builder_init (&builder, G_VARIANT_TYPE_STRING_ARRAY);  
+
+    g_variant_iter_init (&iter, the_black_list);
+    
+    while (g_variant_iter_loop (&iter, "s", &str)){
+      if (g_strcmp0 (player_name, str) != 0){            
+        g_variant_builder_add (&builder, "s", str);
+      }
+    }
+  }
+  GVariant* value = g_variant_builder_end (&builder);
+  result = g_settings_set_value (our_settings,
+                                 "blacklisted-media-players",
+                                 value);
+
+  g_object_unref (our_settings);
+  g_variant_unref (the_black_list);
+  
+  return result;
+}
+
+static gboolean sound_service_dbus_is_blacklisted (SoundServiceDbus *self,
+                                                   const gchar      *player_name)
+{
+  GSettings    *our_settings;
+  GVariant     *the_black_list;
+  GVariantIter  iter;
+  gchar        *str;
+  gboolean      result = FALSE;
+
+  g_return_val_if_fail (player_name != NULL, FALSE);
+  g_return_val_if_fail (IS_SOUND_SERVICE_DBUS (self), FALSE);
+
+  our_settings = g_settings_new ("com.canonical.indicator.sound");
+  the_black_list = g_settings_get_value (our_settings,
+                                         "blacklisted-media-players");
+  g_variant_iter_init (&iter, the_black_list);
+  while (g_variant_iter_next (&iter, "s", &str)){
+    if (g_strcmp0 (player_name, str) == 0) {
+      result = TRUE;
+      g_free (str);
+      break;
+    }
+    g_free (str);
+  }
+
+  g_object_unref (our_settings);
+  g_variant_unref (the_black_list);
+
+  return result;
+}
+
diff -Naur indicator-sound-0.8.5.0/.pc/.version indicator-sound-precise/.pc/.version
--- indicator-sound-0.8.5.0/.pc/.version	1969-12-31 16:00:00.000000000 -0800
+++ indicator-sound-precise/.pc/.version	2012-07-26 21:03:55.488143000 -0700
@@ -0,0 +1 @@
+2
diff -Naur indicator-sound-0.8.5.0/src/fetch-file.c indicator-sound-precise/src/fetch-file.c
--- indicator-sound-0.8.5.0/src/fetch-file.c	2012-03-30 10:32:34.000000000 -0700
+++ indicator-sound-precise/src/fetch-file.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,561 +0,0 @@
-/* fetch-file.c generated by valac 0.14.2, the Vala compiler
- * generated from fetch-file.vala, do not modify */
-
-/*
- * Copyright (C) 2010 Canonical, Ltd.
- *
- * This library is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License
- * version 3.0 as published by the Free Software Foundation.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License version 3.0 for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library. If not, see
- * <http://www.gnu.org/licenses/>.
- *
- * Authors
- *      Gordon Allott <gord.allott@canonical.com>
- *      Conor Curran <conor.curran@canonical.com>
- */
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gio/gio.h>
-
-
-#define TYPE_FETCH_FILE (fetch_file_get_type ())
-#define FETCH_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FETCH_FILE, FetchFile))
-#define FETCH_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FETCH_FILE, FetchFileClass))
-#define IS_FETCH_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FETCH_FILE))
-#define IS_FETCH_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FETCH_FILE))
-#define FETCH_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FETCH_FILE, FetchFileClass))
-
-typedef struct _FetchFile FetchFile;
-typedef struct _FetchFileClass FetchFileClass;
-typedef struct _FetchFilePrivate FetchFilePrivate;
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_byte_array_free0(var) ((var == NULL) ? NULL : (var = (g_byte_array_free (var, TRUE), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-typedef struct _FetchFileFetchDataData FetchFileFetchDataData;
-typedef struct _FetchFileReadSomethingAsyncData FetchFileReadSomethingAsyncData;
-
-struct _FetchFile {
-	GObject parent_instance;
-	FetchFilePrivate * priv;
-};
-
-struct _FetchFileClass {
-	GObjectClass parent_class;
-};
-
-struct _FetchFilePrivate {
-	gchar* _uri;
-	gchar* _intended_property;
-	GDataInputStream* stream;
-	GFile* file;
-	GByteArray* data;
-};
-
-struct _FetchFileFetchDataData {
-	int _state_;
-	GObject* _source_object_;
-	GAsyncResult* _res_;
-	GSimpleAsyncResult* _async_result;
-	FetchFile* self;
-	GFile* _tmp0_;
-	GFileInputStream* _tmp1_;
-	GFileInputStream* _tmp2_;
-	GFileInputStream* _tmp3_;
-	GDataInputStream* _tmp4_;
-	GDataInputStream* _tmp5_;
-	GError* e;
-	GError * _inner_error_;
-};
-
-struct _FetchFileReadSomethingAsyncData {
-	int _state_;
-	GObject* _source_object_;
-	GAsyncResult* _res_;
-	GSimpleAsyncResult* _async_result;
-	FetchFile* self;
-	gssize size;
-	gssize _tmp0_;
-	guint8* _tmp1_;
-	guint8* buffer;
-	gint buffer_length1;
-	gint _buffer_size_;
-	gssize bufsize;
-	gboolean _tmp2_;
-	gboolean _tmp3_;
-	gssize _tmp4_;
-	GDataInputStream* _tmp5_;
-	guint8* _tmp6_;
-	gint _tmp6__length1;
-	gssize _tmp7_;
-	gssize _tmp8_;
-	gssize _tmp9_;
-	gssize _tmp10_;
-	gssize _tmp11_;
-	gssize _tmp12_;
-	guint8* _tmp13_;
-	guint8* cpybuf;
-	gint cpybuf_length1;
-	gint _cpybuf_size_;
-	guint8* _tmp14_;
-	gint _tmp14__length1;
-	guint8* _tmp15_;
-	gint _tmp15__length1;
-	gssize _tmp16_;
-	GByteArray* _tmp17_;
-	guint8* _tmp18_;
-	gint _tmp18__length1;
-	GByteArray* _tmp19_;
-	guint8* _tmp20_;
-	gint _tmp20__length1;
-	GError* e;
-	GByteArray* _tmp21_;
-	const gchar* _tmp22_;
-	GError * _inner_error_;
-};
-
-
-static gpointer fetch_file_parent_class = NULL;
-
-GType fetch_file_get_type (void) G_GNUC_CONST;
-#define FETCH_FILE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_FETCH_FILE, FetchFilePrivate))
-enum  {
-	FETCH_FILE_DUMMY_PROPERTY,
-	FETCH_FILE_URI,
-	FETCH_FILE_INTENDED_PROPERTY
-};
-FetchFile* fetch_file_new (const gchar* uri, const gchar* prop);
-FetchFile* fetch_file_construct (GType object_type, const gchar* uri, const gchar* prop);
-static void fetch_file_fetch_data_data_free (gpointer _data);
-void fetch_file_fetch_data (FetchFile* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void fetch_file_fetch_data_finish (FetchFile* self, GAsyncResult* _res_);
-static gboolean fetch_file_fetch_data_co (FetchFileFetchDataData* _data_);
-static void fetch_file_read_something_async (FetchFile* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-static void fetch_file_read_something_finish (FetchFile* self, GAsyncResult* _res_);
-static void fetch_file_read_something_async_data_free (gpointer _data);
-static gboolean fetch_file_read_something_async_co (FetchFileReadSomethingAsyncData* _data_);
-static void fetch_file_read_something_async_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
-const gchar* fetch_file_get_intended_property (FetchFile* self);
-const gchar* fetch_file_get_uri (FetchFile* self);
-static void fetch_file_set_uri (FetchFile* self, const gchar* value);
-static void fetch_file_set_intended_property (FetchFile* self, const gchar* value);
-static void g_cclosure_user_marshal_VOID__POINTER_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
-static GObject * fetch_file_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
-static void fetch_file_finalize (GObject* obj);
-static void _vala_fetch_file_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
-static void _vala_fetch_file_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
-
-
-FetchFile* fetch_file_construct (GType object_type, const gchar* uri, const gchar* prop) {
-	FetchFile * self = NULL;
-	const gchar* _tmp0_;
-	const gchar* _tmp1_;
-	g_return_val_if_fail (uri != NULL, NULL);
-	g_return_val_if_fail (prop != NULL, NULL);
-	_tmp0_ = uri;
-	_tmp1_ = prop;
-	self = (FetchFile*) g_object_new (object_type, "uri", _tmp0_, "intended-property", _tmp1_, NULL);
-	return self;
-}
-
-
-FetchFile* fetch_file_new (const gchar* uri, const gchar* prop) {
-	return fetch_file_construct (TYPE_FETCH_FILE, uri, prop);
-}
-
-
-static void fetch_file_fetch_data_data_free (gpointer _data) {
-	FetchFileFetchDataData* _data_;
-	_data_ = _data;
-	_g_object_unref0 (_data_->self);
-	g_slice_free (FetchFileFetchDataData, _data_);
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-void fetch_file_fetch_data (FetchFile* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	FetchFileFetchDataData* _data_;
-	FetchFile* _tmp0_;
-	_data_ = g_slice_new0 (FetchFileFetchDataData);
-	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, fetch_file_fetch_data);
-	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, fetch_file_fetch_data_data_free);
-	_tmp0_ = _g_object_ref0 (self);
-	_data_->self = _tmp0_;
-	fetch_file_fetch_data_co (_data_);
-}
-
-
-void fetch_file_fetch_data_finish (FetchFile* self, GAsyncResult* _res_) {
-	FetchFileFetchDataData* _data_;
-	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
-}
-
-
-static gboolean fetch_file_fetch_data_co (FetchFileFetchDataData* _data_) {
-	switch (_data_->_state_) {
-		case 0:
-		goto _state_0;
-		default:
-		g_assert_not_reached ();
-	}
-	_state_0:
-	{
-		_data_->_tmp0_ = _data_->self->priv->file;
-		_data_->_tmp1_ = NULL;
-		_data_->_tmp1_ = g_file_read (_data_->_tmp0_, NULL, &_data_->_inner_error_);
-		_data_->_tmp2_ = _data_->_tmp1_;
-		if (_data_->_inner_error_ != NULL) {
-			goto __catch15_g_error;
-		}
-		_data_->_tmp3_ = _data_->_tmp2_;
-		_data_->_tmp4_ = g_data_input_stream_new ((GInputStream*) _data_->_tmp3_);
-		_g_object_unref0 (_data_->self->priv->stream);
-		_data_->self->priv->stream = _data_->_tmp4_;
-		_g_object_unref0 (_data_->_tmp3_);
-		_data_->_tmp5_ = _data_->self->priv->stream;
-		g_data_input_stream_set_byte_order (_data_->_tmp5_, G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN);
-	}
-	goto __finally15;
-	__catch15_g_error:
-	{
-		_data_->e = _data_->_inner_error_;
-		_data_->_inner_error_ = NULL;
-		g_signal_emit_by_name (_data_->self, "failed");
-		_g_error_free0 (_data_->e);
-	}
-	__finally15:
-	if (_data_->_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
-		g_clear_error (&_data_->_inner_error_);
-		return FALSE;
-	}
-	fetch_file_read_something_async (_data_->self, NULL, NULL);
-	if (_data_->_state_ == 0) {
-		g_simple_async_result_complete_in_idle (_data_->_async_result);
-	} else {
-		g_simple_async_result_complete (_data_->_async_result);
-	}
-	g_object_unref (_data_->_async_result);
-	return FALSE;
-}
-
-
-static void fetch_file_read_something_async_data_free (gpointer _data) {
-	FetchFileReadSomethingAsyncData* _data_;
-	_data_ = _data;
-	_g_object_unref0 (_data_->self);
-	g_slice_free (FetchFileReadSomethingAsyncData, _data_);
-}
-
-
-static void fetch_file_read_something_async (FetchFile* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	FetchFileReadSomethingAsyncData* _data_;
-	FetchFile* _tmp0_;
-	_data_ = g_slice_new0 (FetchFileReadSomethingAsyncData);
-	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, fetch_file_read_something_async);
-	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, fetch_file_read_something_async_data_free);
-	_tmp0_ = _g_object_ref0 (self);
-	_data_->self = _tmp0_;
-	fetch_file_read_something_async_co (_data_);
-}
-
-
-static void fetch_file_read_something_finish (FetchFile* self, GAsyncResult* _res_) {
-	FetchFileReadSomethingAsyncData* _data_;
-	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
-}
-
-
-static void fetch_file_read_something_async_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
-	FetchFileReadSomethingAsyncData* _data_;
-	_data_ = _user_data_;
-	_data_->_source_object_ = source_object;
-	_data_->_res_ = _res_;
-	fetch_file_read_something_async_co (_data_);
-}
-
-
-static gboolean fetch_file_read_something_async_co (FetchFileReadSomethingAsyncData* _data_) {
-	switch (_data_->_state_) {
-		case 0:
-		goto _state_0;
-		case 1:
-		goto _state_1;
-		default:
-		g_assert_not_reached ();
-	}
-	_state_0:
-	_data_->size = (gssize) 1024;
-	_data_->_tmp0_ = _data_->size;
-	_data_->_tmp1_ = NULL;
-	_data_->_tmp1_ = g_new0 (guint8, _data_->_tmp0_);
-	_data_->buffer = _data_->_tmp1_;
-	_data_->buffer_length1 = _data_->_tmp0_;
-	_data_->_buffer_size_ = _data_->buffer_length1;
-	_data_->bufsize = (gssize) 1;
-	{
-		_data_->_tmp2_ = TRUE;
-		while (TRUE) {
-			_data_->_tmp3_ = _data_->_tmp2_;
-			if (!_data_->_tmp3_) {
-				_data_->_tmp4_ = _data_->bufsize;
-				if (!(_data_->_tmp4_ > ((gssize) 0))) {
-					break;
-				}
-			}
-			_data_->_tmp2_ = FALSE;
-			{
-				_data_->_tmp5_ = _data_->self->priv->stream;
-				_data_->_tmp6_ = _data_->buffer;
-				_data_->_tmp6__length1 = _data_->buffer_length1;
-				_data_->_state_ = 1;
-				g_input_stream_read_async ((GInputStream*) _data_->_tmp5_, _data_->_tmp6_, (gsize) _data_->_tmp6__length1, G_PRIORITY_DEFAULT, NULL, fetch_file_read_something_async_ready, _data_);
-				return FALSE;
-				_state_1:
-				_data_->_tmp7_ = 0L;
-				_data_->_tmp7_ = g_input_stream_read_finish ((GInputStream*) _data_->_tmp5_, _data_->_res_, &_data_->_inner_error_);
-				_data_->_tmp8_ = _data_->_tmp7_;
-				if (_data_->_inner_error_ != NULL) {
-					goto __catch16_g_error;
-				}
-				_data_->bufsize = _data_->_tmp8_;
-				_data_->_tmp9_ = _data_->bufsize;
-				if (_data_->_tmp9_ < ((gssize) 1)) {
-					break;
-				}
-				_data_->_tmp10_ = _data_->bufsize;
-				_data_->_tmp11_ = _data_->size;
-				if (_data_->_tmp10_ != _data_->_tmp11_) {
-					_data_->_tmp12_ = _data_->bufsize;
-					_data_->_tmp13_ = NULL;
-					_data_->_tmp13_ = g_new0 (guint8, _data_->_tmp12_);
-					_data_->cpybuf = _data_->_tmp13_;
-					_data_->cpybuf_length1 = _data_->_tmp12_;
-					_data_->_cpybuf_size_ = _data_->cpybuf_length1;
-					_data_->_tmp14_ = _data_->cpybuf;
-					_data_->_tmp14__length1 = _data_->cpybuf_length1;
-					_data_->_tmp15_ = _data_->buffer;
-					_data_->_tmp15__length1 = _data_->buffer_length1;
-					_data_->_tmp16_ = _data_->bufsize;
-					memcpy (_data_->_tmp14_, _data_->_tmp15_, (gsize) _data_->_tmp16_);
-					_data_->_tmp17_ = _data_->self->priv->data;
-					_data_->_tmp18_ = _data_->cpybuf;
-					_data_->_tmp18__length1 = _data_->cpybuf_length1;
-					g_byte_array_append (_data_->_tmp17_, _data_->_tmp18_, _data_->_tmp18__length1);
-					_data_->cpybuf = (g_free (_data_->cpybuf), NULL);
-				} else {
-					_data_->_tmp19_ = _data_->self->priv->data;
-					_data_->_tmp20_ = _data_->buffer;
-					_data_->_tmp20__length1 = _data_->buffer_length1;
-					g_byte_array_append (_data_->_tmp19_, _data_->_tmp20_, _data_->_tmp20__length1);
-				}
-			}
-			goto __finally16;
-			__catch16_g_error:
-			{
-				_data_->e = _data_->_inner_error_;
-				_data_->_inner_error_ = NULL;
-				g_signal_emit_by_name (_data_->self, "failed");
-				_g_error_free0 (_data_->e);
-			}
-			__finally16:
-			if (_data_->_inner_error_ != NULL) {
-				_data_->buffer = (g_free (_data_->buffer), NULL);
-				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
-				g_clear_error (&_data_->_inner_error_);
-				return FALSE;
-			}
-		}
-	}
-	_data_->_tmp21_ = _data_->self->priv->data;
-	_data_->_tmp22_ = _data_->self->priv->_intended_property;
-	g_signal_emit_by_name (_data_->self, "completed", _data_->_tmp21_, _data_->_tmp22_);
-	_data_->buffer = (g_free (_data_->buffer), NULL);
-	if (_data_->_state_ == 0) {
-		g_simple_async_result_complete_in_idle (_data_->_async_result);
-	} else {
-		g_simple_async_result_complete (_data_->_async_result);
-	}
-	g_object_unref (_data_->_async_result);
-	return FALSE;
-}
-
-
-const gchar* fetch_file_get_uri (FetchFile* self) {
-	const gchar* result;
-	const gchar* _tmp0_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = self->priv->_uri;
-	result = _tmp0_;
-	return result;
-}
-
-
-static void fetch_file_set_uri (FetchFile* self, const gchar* value) {
-	const gchar* _tmp0_;
-	gchar* _tmp1_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = value;
-	_tmp1_ = g_strdup (_tmp0_);
-	_g_free0 (self->priv->_uri);
-	self->priv->_uri = _tmp1_;
-	g_object_notify ((GObject *) self, "uri");
-}
-
-
-const gchar* fetch_file_get_intended_property (FetchFile* self) {
-	const gchar* result;
-	const gchar* _tmp0_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = self->priv->_intended_property;
-	result = _tmp0_;
-	return result;
-}
-
-
-static void fetch_file_set_intended_property (FetchFile* self, const gchar* value) {
-	const gchar* _tmp0_;
-	gchar* _tmp1_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = value;
-	_tmp1_ = g_strdup (_tmp0_);
-	_g_free0 (self->priv->_intended_property);
-	self->priv->_intended_property = _tmp1_;
-	g_object_notify ((GObject *) self, "intended-property");
-}
-
-
-static void g_cclosure_user_marshal_VOID__POINTER_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
-	typedef void (*GMarshalFunc_VOID__POINTER_STRING) (gpointer data1, gpointer arg_1, const char* arg_2, gpointer data2);
-	register GMarshalFunc_VOID__POINTER_STRING callback;
-	register GCClosure * cc;
-	register gpointer data1;
-	register gpointer data2;
-	cc = (GCClosure *) closure;
-	g_return_if_fail (n_param_values == 3);
-	if (G_CCLOSURE_SWAP_DATA (closure)) {
-		data1 = closure->data;
-		data2 = param_values->data[0].v_pointer;
-	} else {
-		data1 = param_values->data[0].v_pointer;
-		data2 = closure->data;
-	}
-	callback = (GMarshalFunc_VOID__POINTER_STRING) (marshal_data ? marshal_data : cc->callback);
-	callback (data1, g_value_get_pointer (param_values + 1), g_value_get_string (param_values + 2), data2);
-}
-
-
-static GObject * fetch_file_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
-	GObject * obj;
-	GObjectClass * parent_class;
-	FetchFile * self;
-	const gchar* _tmp0_;
-	GFile* _tmp1_ = NULL;
-	GByteArray* _tmp2_;
-	parent_class = G_OBJECT_CLASS (fetch_file_parent_class);
-	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
-	self = FETCH_FILE (obj);
-	_tmp0_ = self->priv->_uri;
-	_tmp1_ = g_file_new_for_uri (_tmp0_);
-	_g_object_unref0 (self->priv->file);
-	self->priv->file = _tmp1_;
-	_tmp2_ = g_byte_array_new ();
-	_g_byte_array_free0 (self->priv->data);
-	self->priv->data = _tmp2_;
-	return obj;
-}
-
-
-static void fetch_file_class_init (FetchFileClass * klass) {
-	fetch_file_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (FetchFilePrivate));
-	G_OBJECT_CLASS (klass)->get_property = _vala_fetch_file_get_property;
-	G_OBJECT_CLASS (klass)->set_property = _vala_fetch_file_set_property;
-	G_OBJECT_CLASS (klass)->constructor = fetch_file_constructor;
-	G_OBJECT_CLASS (klass)->finalize = fetch_file_finalize;
-	g_object_class_install_property (G_OBJECT_CLASS (klass), FETCH_FILE_URI, g_param_spec_string ("uri", "uri", "uri", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), FETCH_FILE_INTENDED_PROPERTY, g_param_spec_string ("intended-property", "intended-property", "intended-property", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
-	g_signal_new ("failed", TYPE_FETCH_FILE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
-	g_signal_new ("completed", TYPE_FETCH_FILE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__POINTER_STRING, G_TYPE_NONE, 2, G_TYPE_POINTER, G_TYPE_STRING);
-}
-
-
-static void fetch_file_instance_init (FetchFile * self) {
-	self->priv = FETCH_FILE_GET_PRIVATE (self);
-}
-
-
-static void fetch_file_finalize (GObject* obj) {
-	FetchFile * self;
-	self = FETCH_FILE (obj);
-	_g_free0 (self->priv->_uri);
-	_g_free0 (self->priv->_intended_property);
-	_g_object_unref0 (self->priv->stream);
-	_g_object_unref0 (self->priv->file);
-	_g_byte_array_free0 (self->priv->data);
-	G_OBJECT_CLASS (fetch_file_parent_class)->finalize (obj);
-}
-
-
-GType fetch_file_get_type (void) {
-	static volatile gsize fetch_file_type_id__volatile = 0;
-	if (g_once_init_enter (&fetch_file_type_id__volatile)) {
-		static const GTypeInfo g_define_type_info = { sizeof (FetchFileClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) fetch_file_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FetchFile), 0, (GInstanceInitFunc) fetch_file_instance_init, NULL };
-		GType fetch_file_type_id;
-		fetch_file_type_id = g_type_register_static (G_TYPE_OBJECT, "FetchFile", &g_define_type_info, 0);
-		g_once_init_leave (&fetch_file_type_id__volatile, fetch_file_type_id);
-	}
-	return fetch_file_type_id__volatile;
-}
-
-
-static void _vala_fetch_file_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
-	FetchFile * self;
-	self = FETCH_FILE (object);
-	switch (property_id) {
-		case FETCH_FILE_URI:
-		g_value_set_string (value, fetch_file_get_uri (self));
-		break;
-		case FETCH_FILE_INTENDED_PROPERTY:
-		g_value_set_string (value, fetch_file_get_intended_property (self));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void _vala_fetch_file_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
-	FetchFile * self;
-	self = FETCH_FILE (object);
-	switch (property_id) {
-		case FETCH_FILE_URI:
-		fetch_file_set_uri (self, g_value_get_string (value));
-		break;
-		case FETCH_FILE_INTENDED_PROPERTY:
-		fetch_file_set_intended_property (self, g_value_get_string (value));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-
diff -Naur indicator-sound-0.8.5.0/src/freedesktop-interfaces.c indicator-sound-precise/src/freedesktop-interfaces.c
--- indicator-sound-0.8.5.0/src/freedesktop-interfaces.c	2012-03-30 10:32:34.000000000 -0700
+++ indicator-sound-precise/src/freedesktop-interfaces.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,862 +0,0 @@
-/* freedesktop-interfaces.c generated by valac 0.14.2, the Vala compiler
- * generated from freedesktop-interfaces.vala, do not modify */
-
-/*
-Copyright 2010 Canonical Ltd.
-
-Authors:
-    Conor Curran <conor.curran@canonical.com>
-
-This program is free software: you can redistribute it and/or modify it 
-under the terms of the GNU General Public License version 3, as published 
-by the Free Software Foundation.
-
-This program is distributed in the hope that it will be useful, but 
-WITHOUT ANY WARRANTY; without even the implied warranties of 
-MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
-PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along 
-with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gio/gio.h>
-#include <stdlib.h>
-#include <string.h>
-
-
-#define TYPE_FREE_DESKTOP_OBJECT (free_desktop_object_get_type ())
-#define FREE_DESKTOP_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FREE_DESKTOP_OBJECT, FreeDesktopObject))
-#define IS_FREE_DESKTOP_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FREE_DESKTOP_OBJECT))
-#define FREE_DESKTOP_OBJECT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_FREE_DESKTOP_OBJECT, FreeDesktopObjectIface))
-
-typedef struct _FreeDesktopObject FreeDesktopObject;
-typedef struct _FreeDesktopObjectIface FreeDesktopObjectIface;
-
-#define TYPE_FREE_DESKTOP_OBJECT_PROXY (free_desktop_object_proxy_get_type ())
-typedef GDBusProxy FreeDesktopObjectProxy;
-typedef GDBusProxyClass FreeDesktopObjectProxyClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-#define TYPE_FREE_DESKTOP_INTROSPECTABLE (free_desktop_introspectable_get_type ())
-#define FREE_DESKTOP_INTROSPECTABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FREE_DESKTOP_INTROSPECTABLE, FreeDesktopIntrospectable))
-#define IS_FREE_DESKTOP_INTROSPECTABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FREE_DESKTOP_INTROSPECTABLE))
-#define FREE_DESKTOP_INTROSPECTABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_FREE_DESKTOP_INTROSPECTABLE, FreeDesktopIntrospectableIface))
-
-typedef struct _FreeDesktopIntrospectable FreeDesktopIntrospectable;
-typedef struct _FreeDesktopIntrospectableIface FreeDesktopIntrospectableIface;
-
-#define TYPE_FREE_DESKTOP_INTROSPECTABLE_PROXY (free_desktop_introspectable_proxy_get_type ())
-typedef GDBusProxy FreeDesktopIntrospectableProxy;
-typedef GDBusProxyClass FreeDesktopIntrospectableProxyClass;
-
-#define TYPE_FREE_DESKTOP_PROPERTIES (free_desktop_properties_get_type ())
-#define FREE_DESKTOP_PROPERTIES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FREE_DESKTOP_PROPERTIES, FreeDesktopProperties))
-#define IS_FREE_DESKTOP_PROPERTIES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FREE_DESKTOP_PROPERTIES))
-#define FREE_DESKTOP_PROPERTIES_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_FREE_DESKTOP_PROPERTIES, FreeDesktopPropertiesIface))
-
-typedef struct _FreeDesktopProperties FreeDesktopProperties;
-typedef struct _FreeDesktopPropertiesIface FreeDesktopPropertiesIface;
-
-#define TYPE_FREE_DESKTOP_PROPERTIES_PROXY (free_desktop_properties_proxy_get_type ())
-typedef GDBusProxy FreeDesktopPropertiesProxy;
-typedef GDBusProxyClass FreeDesktopPropertiesProxyClass;
-#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
-
-struct _FreeDesktopObjectIface {
-	GTypeInterface parent_iface;
-	void (*list_names) (FreeDesktopObject* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	gchar** (*list_names_finish) (FreeDesktopObject* self, GAsyncResult* _res_, int* result_length1, GError** error);
-};
-
-struct _FreeDesktopIntrospectableIface {
-	GTypeInterface parent_iface;
-	gchar* (*Introspect) (FreeDesktopIntrospectable* self, GError** error);
-};
-
-struct _FreeDesktopPropertiesIface {
-	GTypeInterface parent_iface;
-};
-
-typedef enum  {
-	XML_ERROR_FILE_NOT_FOUND,
-	XML_ERROR_XML_DOCUMENT_EMPTY
-} XmlError;
-#define XML_ERROR xml_error_quark ()
-
-
-GType free_desktop_object_proxy_get_type (void) G_GNUC_CONST;
-guint free_desktop_object_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-GType free_desktop_object_get_type (void) G_GNUC_CONST;
-void free_desktop_object_list_names (FreeDesktopObject* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-gchar** free_desktop_object_list_names_finish (FreeDesktopObject* self, GAsyncResult* _res_, int* result_length1, GError** error);
-static void g_cclosure_user_marshal_VOID__STRING_STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
-static void free_desktop_object_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters);
-static void _dbus_handle_free_desktop_object_name_owner_changed (FreeDesktopObject* self, GVariant* parameters);
-static void _vala_g_async_ready_callback (GObject *source_object, GAsyncResult *res, void *user_data);
-static void free_desktop_object_proxy_list_names_async (FreeDesktopObject* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-static gchar** free_desktop_object_proxy_list_names_finish (FreeDesktopObject* self, GAsyncResult* _res_, int* result_length1, GError** error);
-static void free_desktop_object_proxy_free_desktop_object_interface_init (FreeDesktopObjectIface* iface);
-static void _dbus_free_desktop_object_list_names (FreeDesktopObject* self, GVariant* parameters, GDBusMethodInvocation* invocation);
-static void _dbus_free_desktop_object_list_names_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
-static void free_desktop_object_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
-static GVariant* free_desktop_object_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
-static gboolean free_desktop_object_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
-static void _dbus_free_desktop_object_name_owner_changed (GObject* _sender, const gchar* name, const gchar* old_owner, const gchar* new_owner, gpointer* _data);
-static void _free_desktop_object_unregister_object (gpointer user_data);
-GType free_desktop_introspectable_proxy_get_type (void) G_GNUC_CONST;
-guint free_desktop_introspectable_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-GType free_desktop_introspectable_get_type (void) G_GNUC_CONST;
-gchar* free_desktop_introspectable_Introspect (FreeDesktopIntrospectable* self, GError** error);
-static void free_desktop_introspectable_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters);
-static gchar* free_desktop_introspectable_proxy_Introspect (FreeDesktopIntrospectable* self, GError** error);
-static void free_desktop_introspectable_proxy_free_desktop_introspectable_interface_init (FreeDesktopIntrospectableIface* iface);
-static void _dbus_free_desktop_introspectable_Introspect (FreeDesktopIntrospectable* self, GVariant* parameters, GDBusMethodInvocation* invocation);
-static void free_desktop_introspectable_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
-static GVariant* free_desktop_introspectable_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
-static gboolean free_desktop_introspectable_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
-static void _free_desktop_introspectable_unregister_object (gpointer user_data);
-GType free_desktop_properties_get_type (void) G_GNUC_CONST;
-GType free_desktop_properties_proxy_get_type (void) G_GNUC_CONST;
-guint free_desktop_properties_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-static void g_cclosure_user_marshal_VOID__STRING_BOXED_BOXED_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
-static void free_desktop_properties_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters);
-static void _dbus_handle_free_desktop_properties_properties_changed (FreeDesktopProperties* self, GVariant* parameters);
-static void free_desktop_properties_proxy_free_desktop_properties_interface_init (FreeDesktopPropertiesIface* iface);
-static void free_desktop_properties_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
-static GVariant* free_desktop_properties_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
-static gboolean free_desktop_properties_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
-static void _dbus_free_desktop_properties_properties_changed (GObject* _sender, const gchar* source, GHashTable* changed_properties, gchar** invalid, int invalid_length1, gpointer* _data);
-static void _free_desktop_properties_unregister_object (gpointer user_data);
-GQuark xml_error_quark (void);
-#define FREEDESKTOP_SERVICE "org.freedesktop.DBus"
-#define FREEDESKTOP_OBJECT "/org/freedesktop/DBus"
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-
-static const GDBusArgInfo _free_desktop_object_dbus_arg_info_list_names_result = {-1, "result", "as"};
-static const GDBusArgInfo * const _free_desktop_object_dbus_arg_info_list_names_in[] = {NULL};
-static const GDBusArgInfo * const _free_desktop_object_dbus_arg_info_list_names_out[] = {&_free_desktop_object_dbus_arg_info_list_names_result, NULL};
-static const GDBusMethodInfo _free_desktop_object_dbus_method_info_list_names = {-1, "ListNames", (GDBusArgInfo **) (&_free_desktop_object_dbus_arg_info_list_names_in), (GDBusArgInfo **) (&_free_desktop_object_dbus_arg_info_list_names_out)};
-static const GDBusMethodInfo * const _free_desktop_object_dbus_method_info[] = {&_free_desktop_object_dbus_method_info_list_names, NULL};
-static const GDBusArgInfo _free_desktop_object_dbus_arg_info_name_owner_changed_name = {-1, "name", "s"};
-static const GDBusArgInfo _free_desktop_object_dbus_arg_info_name_owner_changed_old_owner = {-1, "old_owner", "s"};
-static const GDBusArgInfo _free_desktop_object_dbus_arg_info_name_owner_changed_new_owner = {-1, "new_owner", "s"};
-static const GDBusArgInfo * const _free_desktop_object_dbus_arg_info_name_owner_changed[] = {&_free_desktop_object_dbus_arg_info_name_owner_changed_name, &_free_desktop_object_dbus_arg_info_name_owner_changed_old_owner, &_free_desktop_object_dbus_arg_info_name_owner_changed_new_owner, NULL};
-static const GDBusSignalInfo _free_desktop_object_dbus_signal_info_name_owner_changed = {-1, "NameOwnerChanged", (GDBusArgInfo **) (&_free_desktop_object_dbus_arg_info_name_owner_changed)};
-static const GDBusSignalInfo * const _free_desktop_object_dbus_signal_info[] = {&_free_desktop_object_dbus_signal_info_name_owner_changed, NULL};
-static const GDBusPropertyInfo * const _free_desktop_object_dbus_property_info[] = {NULL};
-static const GDBusInterfaceInfo _free_desktop_object_dbus_interface_info = {-1, "org.freedesktop.DBus", (GDBusMethodInfo **) (&_free_desktop_object_dbus_method_info), (GDBusSignalInfo **) (&_free_desktop_object_dbus_signal_info), (GDBusPropertyInfo **) (&_free_desktop_object_dbus_property_info)};
-static const GDBusInterfaceVTable _free_desktop_object_dbus_interface_vtable = {free_desktop_object_dbus_interface_method_call, free_desktop_object_dbus_interface_get_property, free_desktop_object_dbus_interface_set_property};
-static const GDBusArgInfo _free_desktop_introspectable_dbus_arg_info_Introspect_result = {-1, "result", "s"};
-static const GDBusArgInfo * const _free_desktop_introspectable_dbus_arg_info_Introspect_in[] = {NULL};
-static const GDBusArgInfo * const _free_desktop_introspectable_dbus_arg_info_Introspect_out[] = {&_free_desktop_introspectable_dbus_arg_info_Introspect_result, NULL};
-static const GDBusMethodInfo _free_desktop_introspectable_dbus_method_info_Introspect = {-1, "Introspect", (GDBusArgInfo **) (&_free_desktop_introspectable_dbus_arg_info_Introspect_in), (GDBusArgInfo **) (&_free_desktop_introspectable_dbus_arg_info_Introspect_out)};
-static const GDBusMethodInfo * const _free_desktop_introspectable_dbus_method_info[] = {&_free_desktop_introspectable_dbus_method_info_Introspect, NULL};
-static const GDBusSignalInfo * const _free_desktop_introspectable_dbus_signal_info[] = {NULL};
-static const GDBusPropertyInfo * const _free_desktop_introspectable_dbus_property_info[] = {NULL};
-static const GDBusInterfaceInfo _free_desktop_introspectable_dbus_interface_info = {-1, "org.freedesktop.DBus.Introspectable", (GDBusMethodInfo **) (&_free_desktop_introspectable_dbus_method_info), (GDBusSignalInfo **) (&_free_desktop_introspectable_dbus_signal_info), (GDBusPropertyInfo **) (&_free_desktop_introspectable_dbus_property_info)};
-static const GDBusInterfaceVTable _free_desktop_introspectable_dbus_interface_vtable = {free_desktop_introspectable_dbus_interface_method_call, free_desktop_introspectable_dbus_interface_get_property, free_desktop_introspectable_dbus_interface_set_property};
-static const GDBusMethodInfo * const _free_desktop_properties_dbus_method_info[] = {NULL};
-static const GDBusArgInfo _free_desktop_properties_dbus_arg_info_properties_changed_source = {-1, "source", "s"};
-static const GDBusArgInfo _free_desktop_properties_dbus_arg_info_properties_changed_changed_properties = {-1, "changed_properties", "a{sv}"};
-static const GDBusArgInfo _free_desktop_properties_dbus_arg_info_properties_changed_invalid = {-1, "invalid", "as"};
-static const GDBusArgInfo * const _free_desktop_properties_dbus_arg_info_properties_changed[] = {&_free_desktop_properties_dbus_arg_info_properties_changed_source, &_free_desktop_properties_dbus_arg_info_properties_changed_changed_properties, &_free_desktop_properties_dbus_arg_info_properties_changed_invalid, NULL};
-static const GDBusSignalInfo _free_desktop_properties_dbus_signal_info_properties_changed = {-1, "PropertiesChanged", (GDBusArgInfo **) (&_free_desktop_properties_dbus_arg_info_properties_changed)};
-static const GDBusSignalInfo * const _free_desktop_properties_dbus_signal_info[] = {&_free_desktop_properties_dbus_signal_info_properties_changed, NULL};
-static const GDBusPropertyInfo * const _free_desktop_properties_dbus_property_info[] = {NULL};
-static const GDBusInterfaceInfo _free_desktop_properties_dbus_interface_info = {-1, "org.freedesktop.DBus.Properties", (GDBusMethodInfo **) (&_free_desktop_properties_dbus_method_info), (GDBusSignalInfo **) (&_free_desktop_properties_dbus_signal_info), (GDBusPropertyInfo **) (&_free_desktop_properties_dbus_property_info)};
-static const GDBusInterfaceVTable _free_desktop_properties_dbus_interface_vtable = {free_desktop_properties_dbus_interface_method_call, free_desktop_properties_dbus_interface_get_property, free_desktop_properties_dbus_interface_set_property};
-
-void free_desktop_object_list_names (FreeDesktopObject* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	FREE_DESKTOP_OBJECT_GET_INTERFACE (self)->list_names (self, _callback_, _user_data_);
-}
-
-
-gchar** free_desktop_object_list_names_finish (FreeDesktopObject* self, GAsyncResult* _res_, int* result_length1, GError** error) {
-	return FREE_DESKTOP_OBJECT_GET_INTERFACE (self)->list_names_finish (self, _res_, result_length1, error);
-}
-
-
-static void g_cclosure_user_marshal_VOID__STRING_STRING_STRING (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
-	typedef void (*GMarshalFunc_VOID__STRING_STRING_STRING) (gpointer data1, const char* arg_1, const char* arg_2, const char* arg_3, gpointer data2);
-	register GMarshalFunc_VOID__STRING_STRING_STRING callback;
-	register GCClosure * cc;
-	register gpointer data1;
-	register gpointer data2;
-	cc = (GCClosure *) closure;
-	g_return_if_fail (n_param_values == 4);
-	if (G_CCLOSURE_SWAP_DATA (closure)) {
-		data1 = closure->data;
-		data2 = param_values->data[0].v_pointer;
-	} else {
-		data1 = param_values->data[0].v_pointer;
-		data2 = closure->data;
-	}
-	callback = (GMarshalFunc_VOID__STRING_STRING_STRING) (marshal_data ? marshal_data : cc->callback);
-	callback (data1, g_value_get_string (param_values + 1), g_value_get_string (param_values + 2), g_value_get_string (param_values + 3), data2);
-}
-
-
-static void free_desktop_object_base_init (FreeDesktopObjectIface * iface) {
-	static gboolean initialized = FALSE;
-	if (!initialized) {
-		initialized = TRUE;
-		g_signal_new ("name_owner_changed", TYPE_FREE_DESKTOP_OBJECT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_STRING_STRING, G_TYPE_NONE, 3, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
-	}
-}
-
-
-GType free_desktop_object_get_type (void) {
-	static volatile gsize free_desktop_object_type_id__volatile = 0;
-	if (g_once_init_enter (&free_desktop_object_type_id__volatile)) {
-		static const GTypeInfo g_define_type_info = { sizeof (FreeDesktopObjectIface), (GBaseInitFunc) free_desktop_object_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
-		GType free_desktop_object_type_id;
-		free_desktop_object_type_id = g_type_register_static (G_TYPE_INTERFACE, "FreeDesktopObject", &g_define_type_info, 0);
-		g_type_interface_add_prerequisite (free_desktop_object_type_id, G_TYPE_OBJECT);
-		g_type_set_qdata (free_desktop_object_type_id, g_quark_from_static_string ("vala-dbus-proxy-type"), (void*) free_desktop_object_proxy_get_type);
-		g_type_set_qdata (free_desktop_object_type_id, g_quark_from_static_string ("vala-dbus-interface-name"), "org.freedesktop.DBus");
-		g_type_set_qdata (free_desktop_object_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) free_desktop_object_register_object);
-		g_once_init_leave (&free_desktop_object_type_id__volatile, free_desktop_object_type_id);
-	}
-	return free_desktop_object_type_id__volatile;
-}
-
-
-G_DEFINE_TYPE_EXTENDED (FreeDesktopObjectProxy, free_desktop_object_proxy, G_TYPE_DBUS_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_FREE_DESKTOP_OBJECT, free_desktop_object_proxy_free_desktop_object_interface_init) )
-static void free_desktop_object_proxy_class_init (FreeDesktopObjectProxyClass* klass) {
-	G_DBUS_PROXY_CLASS (klass)->g_signal = free_desktop_object_proxy_g_signal;
-}
-
-
-static void _dbus_handle_free_desktop_object_name_owner_changed (FreeDesktopObject* self, GVariant* parameters) {
-	GVariantIter _arguments_iter;
-	gchar* name = NULL;
-	GVariant* _tmp77_;
-	gchar* old_owner = NULL;
-	GVariant* _tmp78_;
-	gchar* new_owner = NULL;
-	GVariant* _tmp79_;
-	g_variant_iter_init (&_arguments_iter, parameters);
-	_tmp77_ = g_variant_iter_next_value (&_arguments_iter);
-	name = g_variant_dup_string (_tmp77_, NULL);
-	g_variant_unref (_tmp77_);
-	_tmp78_ = g_variant_iter_next_value (&_arguments_iter);
-	old_owner = g_variant_dup_string (_tmp78_, NULL);
-	g_variant_unref (_tmp78_);
-	_tmp79_ = g_variant_iter_next_value (&_arguments_iter);
-	new_owner = g_variant_dup_string (_tmp79_, NULL);
-	g_variant_unref (_tmp79_);
-	g_signal_emit_by_name (self, "name-owner-changed", name, old_owner, new_owner);
-	_g_free0 (name);
-	_g_free0 (old_owner);
-	_g_free0 (new_owner);
-}
-
-
-static void free_desktop_object_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters) {
-	if (strcmp (signal_name, "NameOwnerChanged") == 0) {
-		_dbus_handle_free_desktop_object_name_owner_changed ((FreeDesktopObject*) proxy, parameters);
-	}
-}
-
-
-static void free_desktop_object_proxy_init (FreeDesktopObjectProxy* self) {
-}
-
-
-static void _vala_g_async_ready_callback (GObject *source_object, GAsyncResult *res, void *user_data) {
-	g_simple_async_result_set_op_res_gpointer (user_data, g_object_ref (res), g_object_unref);
-	g_simple_async_result_complete (user_data);
-	g_object_unref (user_data);
-}
-
-
-static void free_desktop_object_proxy_list_names_async (FreeDesktopObject* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	GDBusMessage *_message;
-	GVariant *_arguments;
-	GVariantBuilder _arguments_builder;
-	G_IO_ERROR;
-	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.freedesktop.DBus", "ListNames");
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	g_dbus_message_set_body (_message, _arguments);
-	g_dbus_connection_send_message_with_reply (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, _vala_g_async_ready_callback, g_simple_async_result_new ((GObject *) self, _callback_, _user_data_, NULL));
-	g_object_unref (_message);
-}
-
-
-static gchar** free_desktop_object_proxy_list_names_finish (FreeDesktopObject* self, GAsyncResult* _res_, int* result_length1, GError** error) {
-	GDBusMessage *_reply_message;
-	GVariant *_reply;
-	GVariantIter _reply_iter;
-	gchar** _result;
-	int _result_length1;
-	GVariant* _tmp80_;
-	gchar** _tmp81_;
-	int _tmp81__length;
-	int _tmp81__size;
-	int _tmp81__length1;
-	GVariantIter _tmp82_;
-	GVariant* _tmp83_;
-	_reply_message = g_dbus_connection_send_message_with_reply_finish (g_dbus_proxy_get_connection ((GDBusProxy *) self), g_simple_async_result_get_op_res_gpointer ((GSimpleAsyncResult *) _res_), error);
-	if (!_reply_message) {
-		return NULL;
-	}
-	if (g_dbus_message_to_gerror (_reply_message, error)) {
-		g_object_unref (_reply_message);
-		return NULL;
-	}
-	_reply = g_dbus_message_get_body (_reply_message);
-	g_variant_iter_init (&_reply_iter, _reply);
-	_result_length1 = 0;
-	_tmp80_ = g_variant_iter_next_value (&_reply_iter);
-	_tmp81_ = g_new (gchar*, 5);
-	_tmp81__length = 0;
-	_tmp81__size = 4;
-	_tmp81__length1 = 0;
-	g_variant_iter_init (&_tmp82_, _tmp80_);
-	for (; (_tmp83_ = g_variant_iter_next_value (&_tmp82_)) != NULL; _tmp81__length1++) {
-		if (_tmp81__size == _tmp81__length) {
-			_tmp81__size = 2 * _tmp81__size;
-			_tmp81_ = g_renew (gchar*, _tmp81_, _tmp81__size + 1);
-		}
-		_tmp81_[_tmp81__length++] = g_variant_dup_string (_tmp83_, NULL);
-		g_variant_unref (_tmp83_);
-	}
-	_result_length1 = _tmp81__length1;
-	_tmp81_[_tmp81__length] = NULL;
-	_result = _tmp81_;
-	g_variant_unref (_tmp80_);
-	*result_length1 = _result_length1;
-	g_object_unref (_reply_message);
-	return _result;
-}
-
-
-static void free_desktop_object_proxy_free_desktop_object_interface_init (FreeDesktopObjectIface* iface) {
-	iface->list_names = free_desktop_object_proxy_list_names_async;
-	iface->list_names_finish = free_desktop_object_proxy_list_names_finish;
-}
-
-
-static void _dbus_free_desktop_object_list_names (FreeDesktopObject* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
-	GVariantIter _arguments_iter;
-	g_variant_iter_init (&_arguments_iter, parameters);
-	free_desktop_object_list_names (self, (GAsyncReadyCallback) _dbus_free_desktop_object_list_names_ready, invocation);
-}
-
-
-static void _dbus_free_desktop_object_list_names_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
-	GDBusMethodInvocation * invocation;
-	GError* error = NULL;
-	GDBusMessage* _reply_message;
-	GVariant* _reply;
-	GVariantBuilder _reply_builder;
-	gchar** result;
-	int result_length1 = 0;
-	gchar** _tmp84_;
-	GVariantBuilder _tmp85_;
-	int _tmp86_;
-	invocation = _user_data_;
-	result = free_desktop_object_list_names_finish ((FreeDesktopObject*) source_object, _res_, &result_length1, &error);
-	if (error) {
-		g_dbus_method_invocation_return_gerror (invocation, error);
-		return;
-	}
-	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
-	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
-	_tmp84_ = result;
-	g_variant_builder_init (&_tmp85_, G_VARIANT_TYPE ("as"));
-	for (_tmp86_ = 0; _tmp86_ < result_length1; _tmp86_++) {
-		g_variant_builder_add_value (&_tmp85_, g_variant_new_string (*_tmp84_));
-		_tmp84_++;
-	}
-	g_variant_builder_add_value (&_reply_builder, g_variant_builder_end (&_tmp85_));
-	result = (_vala_array_free (result, result_length1, (GDestroyNotify) g_free), NULL);
-	_reply = g_variant_builder_end (&_reply_builder);
-	g_dbus_message_set_body (_reply_message, _reply);
-	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
-	g_object_unref (invocation);
-	g_object_unref (_reply_message);
-}
-
-
-static void free_desktop_object_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	if (strcmp (method_name, "ListNames") == 0) {
-		_dbus_free_desktop_object_list_names (object, parameters, invocation);
-	} else {
-		g_object_unref (invocation);
-	}
-}
-
-
-static GVariant* free_desktop_object_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	return NULL;
-}
-
-
-static gboolean free_desktop_object_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	return FALSE;
-}
-
-
-static void _dbus_free_desktop_object_name_owner_changed (GObject* _sender, const gchar* name, const gchar* old_owner, const gchar* new_owner, gpointer* _data) {
-	GDBusConnection * _connection;
-	const gchar * _path;
-	GVariant *_arguments;
-	GVariantBuilder _arguments_builder;
-	_connection = _data[1];
-	_path = _data[2];
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (name));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (old_owner));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (new_owner));
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.freedesktop.DBus", "NameOwnerChanged", _arguments, NULL);
-}
-
-
-guint free_desktop_object_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
-	guint result;
-	gpointer *data;
-	data = g_new (gpointer, 3);
-	data[0] = g_object_ref (object);
-	data[1] = g_object_ref (connection);
-	data[2] = g_strdup (path);
-	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_free_desktop_object_dbus_interface_info), &_free_desktop_object_dbus_interface_vtable, data, _free_desktop_object_unregister_object, error);
-	if (!result) {
-		return 0;
-	}
-	g_signal_connect (object, "name-owner-changed", (GCallback) _dbus_free_desktop_object_name_owner_changed, data);
-	return result;
-}
-
-
-static void _free_desktop_object_unregister_object (gpointer user_data) {
-	gpointer* data;
-	data = user_data;
-	g_signal_handlers_disconnect_by_func (data[0], _dbus_free_desktop_object_name_owner_changed, data);
-	g_object_unref (data[0]);
-	g_object_unref (data[1]);
-	g_free (data[2]);
-	g_free (data);
-}
-
-
-gchar* free_desktop_introspectable_Introspect (FreeDesktopIntrospectable* self, GError** error) {
-	g_return_val_if_fail (self != NULL, NULL);
-	return FREE_DESKTOP_INTROSPECTABLE_GET_INTERFACE (self)->Introspect (self, error);
-}
-
-
-static void free_desktop_introspectable_base_init (FreeDesktopIntrospectableIface * iface) {
-	static gboolean initialized = FALSE;
-	if (!initialized) {
-		initialized = TRUE;
-	}
-}
-
-
-GType free_desktop_introspectable_get_type (void) {
-	static volatile gsize free_desktop_introspectable_type_id__volatile = 0;
-	if (g_once_init_enter (&free_desktop_introspectable_type_id__volatile)) {
-		static const GTypeInfo g_define_type_info = { sizeof (FreeDesktopIntrospectableIface), (GBaseInitFunc) free_desktop_introspectable_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
-		GType free_desktop_introspectable_type_id;
-		free_desktop_introspectable_type_id = g_type_register_static (G_TYPE_INTERFACE, "FreeDesktopIntrospectable", &g_define_type_info, 0);
-		g_type_interface_add_prerequisite (free_desktop_introspectable_type_id, G_TYPE_OBJECT);
-		g_type_set_qdata (free_desktop_introspectable_type_id, g_quark_from_static_string ("vala-dbus-proxy-type"), (void*) free_desktop_introspectable_proxy_get_type);
-		g_type_set_qdata (free_desktop_introspectable_type_id, g_quark_from_static_string ("vala-dbus-interface-name"), "org.freedesktop.DBus.Introspectable");
-		g_type_set_qdata (free_desktop_introspectable_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) free_desktop_introspectable_register_object);
-		g_once_init_leave (&free_desktop_introspectable_type_id__volatile, free_desktop_introspectable_type_id);
-	}
-	return free_desktop_introspectable_type_id__volatile;
-}
-
-
-G_DEFINE_TYPE_EXTENDED (FreeDesktopIntrospectableProxy, free_desktop_introspectable_proxy, G_TYPE_DBUS_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_FREE_DESKTOP_INTROSPECTABLE, free_desktop_introspectable_proxy_free_desktop_introspectable_interface_init) )
-static void free_desktop_introspectable_proxy_class_init (FreeDesktopIntrospectableProxyClass* klass) {
-	G_DBUS_PROXY_CLASS (klass)->g_signal = free_desktop_introspectable_proxy_g_signal;
-}
-
-
-static void free_desktop_introspectable_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters) {
-}
-
-
-static void free_desktop_introspectable_proxy_init (FreeDesktopIntrospectableProxy* self) {
-}
-
-
-static gchar* free_desktop_introspectable_proxy_Introspect (FreeDesktopIntrospectable* self, GError** error) {
-	GDBusMessage *_message;
-	GVariant *_arguments;
-	GVariantBuilder _arguments_builder;
-	GDBusMessage *_reply_message;
-	GVariant *_reply;
-	GVariantIter _reply_iter;
-	gchar* _result;
-	GVariant* _tmp87_;
-	G_IO_ERROR;
-	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.freedesktop.DBus.Introspectable", "Introspect");
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	g_dbus_message_set_body (_message, _arguments);
-	_reply_message = g_dbus_connection_send_message_with_reply_sync (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, error);
-	g_object_unref (_message);
-	if (!_reply_message) {
-		return NULL;
-	}
-	if (g_dbus_message_to_gerror (_reply_message, error)) {
-		g_object_unref (_reply_message);
-		return NULL;
-	}
-	_reply = g_dbus_message_get_body (_reply_message);
-	g_variant_iter_init (&_reply_iter, _reply);
-	_tmp87_ = g_variant_iter_next_value (&_reply_iter);
-	_result = g_variant_dup_string (_tmp87_, NULL);
-	g_variant_unref (_tmp87_);
-	g_object_unref (_reply_message);
-	return _result;
-}
-
-
-static void free_desktop_introspectable_proxy_free_desktop_introspectable_interface_init (FreeDesktopIntrospectableIface* iface) {
-	iface->Introspect = free_desktop_introspectable_proxy_Introspect;
-}
-
-
-static void _dbus_free_desktop_introspectable_Introspect (FreeDesktopIntrospectable* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
-	GError* error = NULL;
-	GVariantIter _arguments_iter;
-	GDBusMessage* _reply_message;
-	GVariant* _reply;
-	GVariantBuilder _reply_builder;
-	gchar* result;
-	g_variant_iter_init (&_arguments_iter, parameters);
-	result = free_desktop_introspectable_Introspect (self, &error);
-	if (error) {
-		g_dbus_method_invocation_return_gerror (invocation, error);
-		return;
-	}
-	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
-	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_reply_builder, g_variant_new_string (result));
-	_g_free0 (result);
-	_reply = g_variant_builder_end (&_reply_builder);
-	g_dbus_message_set_body (_reply_message, _reply);
-	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
-	g_object_unref (invocation);
-	g_object_unref (_reply_message);
-}
-
-
-static void free_desktop_introspectable_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	if (strcmp (method_name, "Introspect") == 0) {
-		_dbus_free_desktop_introspectable_Introspect (object, parameters, invocation);
-	} else {
-		g_object_unref (invocation);
-	}
-}
-
-
-static GVariant* free_desktop_introspectable_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	return NULL;
-}
-
-
-static gboolean free_desktop_introspectable_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	return FALSE;
-}
-
-
-guint free_desktop_introspectable_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
-	guint result;
-	gpointer *data;
-	data = g_new (gpointer, 3);
-	data[0] = g_object_ref (object);
-	data[1] = g_object_ref (connection);
-	data[2] = g_strdup (path);
-	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_free_desktop_introspectable_dbus_interface_info), &_free_desktop_introspectable_dbus_interface_vtable, data, _free_desktop_introspectable_unregister_object, error);
-	if (!result) {
-		return 0;
-	}
-	return result;
-}
-
-
-static void _free_desktop_introspectable_unregister_object (gpointer user_data) {
-	gpointer* data;
-	data = user_data;
-	g_object_unref (data[0]);
-	g_object_unref (data[1]);
-	g_free (data[2]);
-	g_free (data);
-}
-
-
-static void g_cclosure_user_marshal_VOID__STRING_BOXED_BOXED_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
-	typedef void (*GMarshalFunc_VOID__STRING_BOXED_BOXED_INT) (gpointer data1, const char* arg_1, gpointer arg_2, gpointer arg_3, gint arg_4, gpointer data2);
-	register GMarshalFunc_VOID__STRING_BOXED_BOXED_INT callback;
-	register GCClosure * cc;
-	register gpointer data1;
-	register gpointer data2;
-	cc = (GCClosure *) closure;
-	g_return_if_fail (n_param_values == 5);
-	if (G_CCLOSURE_SWAP_DATA (closure)) {
-		data1 = closure->data;
-		data2 = param_values->data[0].v_pointer;
-	} else {
-		data1 = param_values->data[0].v_pointer;
-		data2 = closure->data;
-	}
-	callback = (GMarshalFunc_VOID__STRING_BOXED_BOXED_INT) (marshal_data ? marshal_data : cc->callback);
-	callback (data1, g_value_get_string (param_values + 1), g_value_get_boxed (param_values + 2), g_value_get_boxed (param_values + 3), g_value_get_int (param_values + 4), data2);
-}
-
-
-static void free_desktop_properties_base_init (FreeDesktopPropertiesIface * iface) {
-	static gboolean initialized = FALSE;
-	if (!initialized) {
-		initialized = TRUE;
-		g_signal_new ("properties_changed", TYPE_FREE_DESKTOP_PROPERTIES, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_BOXED_BOXED_INT, G_TYPE_NONE, 4, G_TYPE_STRING, G_TYPE_HASH_TABLE, G_TYPE_STRV, G_TYPE_INT);
-	}
-}
-
-
-GType free_desktop_properties_get_type (void) {
-	static volatile gsize free_desktop_properties_type_id__volatile = 0;
-	if (g_once_init_enter (&free_desktop_properties_type_id__volatile)) {
-		static const GTypeInfo g_define_type_info = { sizeof (FreeDesktopPropertiesIface), (GBaseInitFunc) free_desktop_properties_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
-		GType free_desktop_properties_type_id;
-		free_desktop_properties_type_id = g_type_register_static (G_TYPE_INTERFACE, "FreeDesktopProperties", &g_define_type_info, 0);
-		g_type_interface_add_prerequisite (free_desktop_properties_type_id, G_TYPE_OBJECT);
-		g_type_set_qdata (free_desktop_properties_type_id, g_quark_from_static_string ("vala-dbus-proxy-type"), (void*) free_desktop_properties_proxy_get_type);
-		g_type_set_qdata (free_desktop_properties_type_id, g_quark_from_static_string ("vala-dbus-interface-name"), "org.freedesktop.DBus.Properties");
-		g_type_set_qdata (free_desktop_properties_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) free_desktop_properties_register_object);
-		g_once_init_leave (&free_desktop_properties_type_id__volatile, free_desktop_properties_type_id);
-	}
-	return free_desktop_properties_type_id__volatile;
-}
-
-
-G_DEFINE_TYPE_EXTENDED (FreeDesktopPropertiesProxy, free_desktop_properties_proxy, G_TYPE_DBUS_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_FREE_DESKTOP_PROPERTIES, free_desktop_properties_proxy_free_desktop_properties_interface_init) )
-static void free_desktop_properties_proxy_class_init (FreeDesktopPropertiesProxyClass* klass) {
-	G_DBUS_PROXY_CLASS (klass)->g_signal = free_desktop_properties_proxy_g_signal;
-}
-
-
-static void _dbus_handle_free_desktop_properties_properties_changed (FreeDesktopProperties* self, GVariant* parameters) {
-	GVariantIter _arguments_iter;
-	gchar* source = NULL;
-	GVariant* _tmp88_;
-	GHashTable* changed_properties = NULL;
-	GVariant* _tmp89_;
-	GHashTable* _tmp90_;
-	GVariantIter _tmp91_;
-	GVariant* _tmp92_;
-	GVariant* _tmp93_;
-	gchar** invalid = NULL;
-	int invalid_length1;
-	GVariant* _tmp94_;
-	gchar** _tmp95_;
-	int _tmp95__length;
-	int _tmp95__size;
-	int _tmp95__length1;
-	GVariantIter _tmp96_;
-	GVariant* _tmp97_;
-	g_variant_iter_init (&_arguments_iter, parameters);
-	_tmp88_ = g_variant_iter_next_value (&_arguments_iter);
-	source = g_variant_dup_string (_tmp88_, NULL);
-	g_variant_unref (_tmp88_);
-	_tmp89_ = g_variant_iter_next_value (&_arguments_iter);
-	_tmp90_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
-	g_variant_iter_init (&_tmp91_, _tmp89_);
-	while (g_variant_iter_loop (&_tmp91_, "{?*}", &_tmp92_, &_tmp93_)) {
-		g_hash_table_insert (_tmp90_, g_variant_dup_string (_tmp92_, NULL), g_variant_get_variant (_tmp93_));
-	}
-	changed_properties = _tmp90_;
-	g_variant_unref (_tmp89_);
-	invalid_length1 = 0;
-	_tmp94_ = g_variant_iter_next_value (&_arguments_iter);
-	_tmp95_ = g_new (gchar*, 5);
-	_tmp95__length = 0;
-	_tmp95__size = 4;
-	_tmp95__length1 = 0;
-	g_variant_iter_init (&_tmp96_, _tmp94_);
-	for (; (_tmp97_ = g_variant_iter_next_value (&_tmp96_)) != NULL; _tmp95__length1++) {
-		if (_tmp95__size == _tmp95__length) {
-			_tmp95__size = 2 * _tmp95__size;
-			_tmp95_ = g_renew (gchar*, _tmp95_, _tmp95__size + 1);
-		}
-		_tmp95_[_tmp95__length++] = g_variant_dup_string (_tmp97_, NULL);
-		g_variant_unref (_tmp97_);
-	}
-	invalid_length1 = _tmp95__length1;
-	_tmp95_[_tmp95__length] = NULL;
-	invalid = _tmp95_;
-	g_variant_unref (_tmp94_);
-	g_signal_emit_by_name (self, "properties-changed", source, changed_properties, invalid, invalid_length1);
-	_g_free0 (source);
-	_g_hash_table_unref0 (changed_properties);
-	invalid = (_vala_array_free (invalid, invalid_length1, (GDestroyNotify) g_free), NULL);
-}
-
-
-static void free_desktop_properties_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters) {
-	if (strcmp (signal_name, "PropertiesChanged") == 0) {
-		_dbus_handle_free_desktop_properties_properties_changed ((FreeDesktopProperties*) proxy, parameters);
-	}
-}
-
-
-static void free_desktop_properties_proxy_init (FreeDesktopPropertiesProxy* self) {
-}
-
-
-static void free_desktop_properties_proxy_free_desktop_properties_interface_init (FreeDesktopPropertiesIface* iface) {
-}
-
-
-static void free_desktop_properties_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	g_object_unref (invocation);
-}
-
-
-static GVariant* free_desktop_properties_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	return NULL;
-}
-
-
-static gboolean free_desktop_properties_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	return FALSE;
-}
-
-
-static void _dbus_free_desktop_properties_properties_changed (GObject* _sender, const gchar* source, GHashTable* changed_properties, gchar** invalid, int invalid_length1, gpointer* _data) {
-	GDBusConnection * _connection;
-	const gchar * _path;
-	GVariant *_arguments;
-	GVariantBuilder _arguments_builder;
-	GVariantBuilder _tmp98_;
-	GHashTableIter _tmp99_;
-	gpointer _tmp100_;
-	gpointer _tmp101_;
-	gchar** _tmp102_;
-	GVariantBuilder _tmp103_;
-	int _tmp104_;
-	_connection = _data[1];
-	_path = _data[2];
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (source));
-	g_hash_table_iter_init (&_tmp99_, changed_properties);
-	g_variant_builder_init (&_tmp98_, G_VARIANT_TYPE ("a{sv}"));
-	while (g_hash_table_iter_next (&_tmp99_, &_tmp100_, &_tmp101_)) {
-		gchar* _key;
-		GVariant* _value;
-		_key = (gchar*) _tmp100_;
-		_value = (GVariant*) _tmp101_;
-		g_variant_builder_add (&_tmp98_, "{?*}", g_variant_new_string (_key), g_variant_new_variant (_value));
-	}
-	g_variant_builder_add_value (&_arguments_builder, g_variant_builder_end (&_tmp98_));
-	_tmp102_ = invalid;
-	g_variant_builder_init (&_tmp103_, G_VARIANT_TYPE ("as"));
-	for (_tmp104_ = 0; _tmp104_ < invalid_length1; _tmp104_++) {
-		g_variant_builder_add_value (&_tmp103_, g_variant_new_string (*_tmp102_));
-		_tmp102_++;
-	}
-	g_variant_builder_add_value (&_arguments_builder, g_variant_builder_end (&_tmp103_));
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.freedesktop.DBus.Properties", "PropertiesChanged", _arguments, NULL);
-}
-
-
-guint free_desktop_properties_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
-	guint result;
-	gpointer *data;
-	data = g_new (gpointer, 3);
-	data[0] = g_object_ref (object);
-	data[1] = g_object_ref (connection);
-	data[2] = g_strdup (path);
-	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_free_desktop_properties_dbus_interface_info), &_free_desktop_properties_dbus_interface_vtable, data, _free_desktop_properties_unregister_object, error);
-	if (!result) {
-		return 0;
-	}
-	g_signal_connect (object, "properties-changed", (GCallback) _dbus_free_desktop_properties_properties_changed, data);
-	return result;
-}
-
-
-static void _free_desktop_properties_unregister_object (gpointer user_data) {
-	gpointer* data;
-	data = user_data;
-	g_signal_handlers_disconnect_by_func (data[0], _dbus_free_desktop_properties_properties_changed, data);
-	g_object_unref (data[0]);
-	g_object_unref (data[1]);
-	g_free (data[2]);
-	g_free (data);
-}
-
-
-GQuark xml_error_quark (void) {
-	return g_quark_from_static_string ("xml_error-quark");
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-
diff -Naur indicator-sound-0.8.5.0/src/indicator-sound.c indicator-sound-precise/src/indicator-sound.c
--- indicator-sound-0.8.5.0/src/indicator-sound.c	2012-03-30 10:26:53.000000000 -0700
+++ indicator-sound-precise/src/indicator-sound.c	2012-07-26 21:03:55.488143000 -0700
@@ -454,7 +454,7 @@
 }
 /**
  * new_voip_slider_widget
- * Create the voip menu item widget, must of the time this widget will be hidden.
+ * Create the voip menu item widget, most of the time this widget will be hidden.
  * @param newitem
  * @param parent
  * @param client
diff -Naur indicator-sound-0.8.5.0/src/metadata-menu-item.c indicator-sound-precise/src/metadata-menu-item.c
--- indicator-sound-0.8.5.0/src/metadata-menu-item.c	2012-03-30 10:32:34.000000000 -0700
+++ indicator-sound-precise/src/metadata-menu-item.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,863 +0,0 @@
-/* metadata-menu-item.c generated by valac 0.14.2, the Vala compiler
- * generated from metadata-menu-item.vala, do not modify */
-
-/*
-Copyright 2010 Canonical Ltd.
-
-Authors:
-    Conor Curran <conor.curran@canonical.com>
-
-This program is free software: you can redistribute it and/or modify it 
-under the terms of the GNU General Public License version 3, as published 
-by the Free Software Foundation.
-
-This program is distributed in the hope that it will be useful, but 
-WITHOUT ANY WARRANTY; without even the implied warranties of 
-MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
-PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along 
-with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libdbusmenu-glib/client.h>
-#include <libdbusmenu-glib/dbusmenu-glib.h>
-#include <libdbusmenu-glib/enum-types.h>
-#include <libdbusmenu-glib/menuitem-proxy.h>
-#include <libdbusmenu-glib/menuitem.h>
-#include <libdbusmenu-glib/server.h>
-#include <libdbusmenu-glib/types.h>
-#include <stdlib.h>
-#include <string.h>
-#include <common-defs.h>
-#include <gio/gio.h>
-#include <gdk-pixbuf/gdk-pixdata.h>
-#include <glib/gstdio.h>
-#include <gee.h>
-
-
-#define TYPE_PLAYER_ITEM (player_item_get_type ())
-#define PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_ITEM, PlayerItem))
-#define PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_ITEM, PlayerItemClass))
-#define IS_PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_ITEM))
-#define IS_PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_ITEM))
-#define PLAYER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_ITEM, PlayerItemClass))
-
-typedef struct _PlayerItem PlayerItem;
-typedef struct _PlayerItemClass PlayerItemClass;
-typedef struct _PlayerItemPrivate PlayerItemPrivate;
-
-#define TYPE_METADATA_MENUITEM (metadata_menuitem_get_type ())
-#define METADATA_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_METADATA_MENUITEM, MetadataMenuitem))
-#define METADATA_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_METADATA_MENUITEM, MetadataMenuitemClass))
-#define IS_METADATA_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_METADATA_MENUITEM))
-#define IS_METADATA_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_METADATA_MENUITEM))
-#define METADATA_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_METADATA_MENUITEM, MetadataMenuitemClass))
-
-typedef struct _MetadataMenuitem MetadataMenuitem;
-typedef struct _MetadataMenuitemClass MetadataMenuitemClass;
-typedef struct _MetadataMenuitemPrivate MetadataMenuitemPrivate;
-
-#define TYPE_FETCH_FILE (fetch_file_get_type ())
-#define FETCH_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FETCH_FILE, FetchFile))
-#define FETCH_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FETCH_FILE, FetchFileClass))
-#define IS_FETCH_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FETCH_FILE))
-#define IS_FETCH_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FETCH_FILE))
-#define FETCH_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FETCH_FILE, FetchFileClass))
-
-typedef struct _FetchFile FetchFile;
-typedef struct _FetchFileClass FetchFileClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-#define TYPE_PLAYER_CONTROLLER (player_controller_get_type ())
-#define PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONTROLLER, PlayerController))
-#define PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-#define IS_PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONTROLLER))
-#define IS_PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONTROLLER))
-#define PLAYER_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-
-typedef struct _PlayerController PlayerController;
-typedef struct _PlayerControllerClass PlayerControllerClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-typedef struct _PlayerControllerPrivate PlayerControllerPrivate;
-
-#define TYPE_MPRIS2_CONTROLLER (mpris2_controller_get_type ())
-#define MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2Controller))
-#define MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
-#define IS_MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS2_CONTROLLER))
-#define IS_MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS2_CONTROLLER))
-#define MPRIS2_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
-
-typedef struct _Mpris2Controller Mpris2Controller;
-typedef struct _Mpris2ControllerClass Mpris2ControllerClass;
-
-#define PLAYER_CONTROLLER_TYPE_STATE (player_controller_state_get_type ())
-
-struct _PlayerItem {
-	DbusmenuMenuitem parent_instance;
-	PlayerItemPrivate * priv;
-};
-
-struct _PlayerItemClass {
-	DbusmenuMenuitemClass parent_class;
-};
-
-struct _MetadataMenuitem {
-	PlayerItem parent_instance;
-	MetadataMenuitemPrivate * priv;
-};
-
-struct _MetadataMenuitemClass {
-	PlayerItemClass parent_class;
-};
-
-struct _MetadataMenuitemPrivate {
-	gchar* previous_temp_album_art_path;
-};
-
-struct _PlayerController {
-	GObject parent_instance;
-	PlayerControllerPrivate * priv;
-	gint current_state;
-	DbusmenuMenuitem* root_menu;
-	GeeArrayList* custom_items;
-	Mpris2Controller* mpris_bridge;
-	gboolean* use_playlists;
-};
-
-struct _PlayerControllerClass {
-	GObjectClass parent_class;
-};
-
-typedef enum  {
-	PLAYER_CONTROLLER_STATE_OFFLINE,
-	PLAYER_CONTROLLER_STATE_INSTANTIATING,
-	PLAYER_CONTROLLER_STATE_READY,
-	PLAYER_CONTROLLER_STATE_CONNECTED,
-	PLAYER_CONTROLLER_STATE_DISCONNECTED
-} PlayerControllerstate;
-
-
-static gpointer metadata_menuitem_parent_class = NULL;
-extern gchar* metadata_menuitem_album_art_cache_dir;
-gchar* metadata_menuitem_album_art_cache_dir = NULL;
-static FetchFile* metadata_menuitem_fetcher;
-static FetchFile* metadata_menuitem_fetcher = NULL;
-
-GType player_item_get_type (void) G_GNUC_CONST;
-GType metadata_menuitem_get_type (void) G_GNUC_CONST;
-#define METADATA_MENUITEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_METADATA_MENUITEM, MetadataMenuitemPrivate))
-enum  {
-	METADATA_MENUITEM_DUMMY_PROPERTY
-};
-GType fetch_file_get_type (void) G_GNUC_CONST;
-#define METADATA_MENUITEM_ALBUM_ART_DIR_SUFFIX "indicator/sound/album-art-cache"
-GType player_controller_get_type (void) G_GNUC_CONST;
-MetadataMenuitem* metadata_menuitem_new (PlayerController* parent);
-MetadataMenuitem* metadata_menuitem_construct (GType object_type, PlayerController* parent);
-static void metadata_menuitem_clean_album_art_temp_dir (void);
-static gboolean metadata_menuitem_delete_album_art_contents (GFile* dir);
-static gchar* metadata_menuitem_create_album_art_temp_dir (void);
-void metadata_menuitem_fetch_art (MetadataMenuitem* self, const gchar* uri, const gchar* prop);
-#define PLAYER_ITEM_EMPTY (-1)
-FetchFile* fetch_file_new (const gchar* uri, const gchar* prop);
-FetchFile* fetch_file_construct (GType object_type, const gchar* uri, const gchar* prop);
-static void __lambda0_ (MetadataMenuitem* self);
-static void metadata_menuitem_on_fetcher_failed (MetadataMenuitem* self);
-static void ___lambda0__fetch_file_failed (FetchFile* _sender, gpointer self);
-static void metadata_menuitem_on_fetcher_completed (MetadataMenuitem* self, GByteArray* update, const gchar* property);
-static void _metadata_menuitem_on_fetcher_completed_fetch_file_completed (FetchFile* _sender, GByteArray* data, const gchar* property, gpointer self);
-void fetch_file_fetch_data (FetchFile* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void fetch_file_fetch_data_finish (FetchFile* self, GAsyncResult* _res_);
-static void metadata_menuitem_real_handle_event (DbusmenuMenuitem* base, const gchar* name, GVariant* input_value, guint timestamp);
-PlayerController* player_item_get_owner (PlayerItem* self);
-GType mpris2_controller_get_type (void) G_GNUC_CONST;
-GType player_controller_state_get_type (void) G_GNUC_CONST;
-void player_controller_instantiate (PlayerController* self);
-void mpris2_controller_expose (Mpris2Controller* self);
-void metadata_menuitem_alter_label (MetadataMenuitem* self, const gchar* new_title);
-void metadata_menuitem_toggle_active_triangle (MetadataMenuitem* self, gboolean update);
-void metadata_menuitem_should_collapse (MetadataMenuitem* self, gboolean collapse);
-GeeHashSet* metadata_menuitem_attributes_format (void);
-GeeHashSet* metadata_menuitem_relevant_attributes_for_ui (void);
-static GObject * metadata_menuitem_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
-GAppInfo* player_controller_get_app_info (PlayerController* self);
-const gchar* player_controller_get_icon_name (PlayerController* self);
-void player_item_reset (PlayerItem* self, GeeHashSet* attrs);
-static void metadata_menuitem_finalize (GObject* obj);
-
-
-MetadataMenuitem* metadata_menuitem_construct (GType object_type, PlayerController* parent) {
-	MetadataMenuitem * self = NULL;
-	PlayerController* _tmp0_;
-	g_return_val_if_fail (parent != NULL, NULL);
-	_tmp0_ = parent;
-	self = (MetadataMenuitem*) g_object_new (object_type, "item-type", DBUSMENU_METADATA_MENUITEM_TYPE, "owner", _tmp0_, NULL);
-	return self;
-}
-
-
-MetadataMenuitem* metadata_menuitem_new (PlayerController* parent) {
-	return metadata_menuitem_construct (TYPE_METADATA_MENUITEM, parent);
-}
-
-
-static void metadata_menuitem_clean_album_art_temp_dir (void) {
-	const gchar* _tmp0_ = NULL;
-	gchar* _tmp1_ = NULL;
-	gchar* path;
-	const gchar* _tmp2_;
-	GFile* _tmp3_ = NULL;
-	GFile* album_art_dir;
-	GFile* _tmp4_;
-	gboolean _tmp5_ = FALSE;
-	_tmp0_ = g_get_user_cache_dir ();
-	_tmp1_ = g_build_filename (_tmp0_, METADATA_MENUITEM_ALBUM_ART_DIR_SUFFIX, NULL);
-	path = _tmp1_;
-	_tmp2_ = path;
-	_tmp3_ = g_file_new_for_path (_tmp2_);
-	album_art_dir = _tmp3_;
-	_tmp4_ = album_art_dir;
-	_tmp5_ = metadata_menuitem_delete_album_art_contents (_tmp4_);
-	if (_tmp5_ == FALSE) {
-		const gchar* _tmp6_;
-		_tmp6_ = path;
-		g_warning ("metadata-menu-item.vala:58: could not remove the temp album art files " \
-"%s", _tmp6_);
-	}
-	_g_object_unref0 (album_art_dir);
-	_g_free0 (path);
-}
-
-
-static gchar* metadata_menuitem_create_album_art_temp_dir (void) {
-	gchar* result = NULL;
-	const gchar* _tmp0_ = NULL;
-	gchar* _tmp1_ = NULL;
-	gchar* path;
-	const gchar* _tmp2_;
-	gint _tmp3_ = 0;
-	_tmp0_ = g_get_user_cache_dir ();
-	_tmp1_ = g_build_filename (_tmp0_, METADATA_MENUITEM_ALBUM_ART_DIR_SUFFIX, NULL);
-	path = _tmp1_;
-	_tmp2_ = path;
-	_tmp3_ = g_mkdir_with_parents (_tmp2_, 0700);
-	if (_tmp3_ == (-1)) {
-		const gchar* _tmp4_;
-		_tmp4_ = path;
-		g_warning ("metadata-menu-item.vala:66: could not create temp dir %s for remote al" \
-"bum art, it must have been created already", _tmp4_);
-	}
-	result = path;
-	return result;
-}
-
-
-static const gchar* string_to_string (const gchar* self) {
-	const gchar* result = NULL;
-	g_return_val_if_fail (self != NULL, NULL);
-	result = self;
-	return result;
-}
-
-
-static gboolean metadata_menuitem_delete_album_art_contents (GFile* dir) {
-	gboolean result = FALSE;
-	gboolean _result_;
-	GError * _inner_error_ = NULL;
-	g_return_val_if_fail (dir != NULL, FALSE);
-	_result_ = TRUE;
-	{
-		GFile* _tmp0_;
-		GFileEnumerator* _tmp1_ = NULL;
-		GFileEnumerator* e;
-		_tmp0_ = dir;
-		_tmp1_ = g_file_enumerate_children (_tmp0_, G_FILE_ATTRIBUTE_STANDARD_NAME, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, NULL, &_inner_error_);
-		e = _tmp1_;
-		if (_inner_error_ != NULL) {
-			goto __catch3_g_error;
-		}
-		while (TRUE) {
-			GFileEnumerator* _tmp2_;
-			GFileInfo* _tmp3_ = NULL;
-			GFileInfo* file;
-			GFileInfo* _tmp4_;
-			GFileInfo* _tmp5_;
-			const gchar* _tmp6_ = NULL;
-			GFile* _tmp7_;
-			GFileInfo* _tmp8_;
-			const gchar* _tmp9_ = NULL;
-			GFile* _tmp10_ = NULL;
-			GFile* child;
-			_tmp2_ = e;
-			_tmp3_ = g_file_enumerator_next_file (_tmp2_, NULL, &_inner_error_);
-			file = _tmp3_;
-			if (_inner_error_ != NULL) {
-				_g_object_unref0 (e);
-				goto __catch3_g_error;
-			}
-			_tmp4_ = file;
-			if (_tmp4_ == NULL) {
-				_g_object_unref0 (file);
-				break;
-			}
-			_tmp5_ = file;
-			_tmp6_ = g_file_info_get_name (_tmp5_);
-			g_debug ("metadata-menu-item.vala:85: file name = %s", _tmp6_);
-			_tmp7_ = dir;
-			_tmp8_ = file;
-			_tmp9_ = g_file_info_get_name (_tmp8_);
-			_tmp10_ = g_file_get_child (_tmp7_, _tmp9_);
-			child = _tmp10_;
-			{
-				GFile* _tmp11_;
-				_tmp11_ = child;
-				g_file_delete (_tmp11_, NULL, &_inner_error_);
-				if (_inner_error_ != NULL) {
-					goto __catch4_g_error;
-				}
-			}
-			goto __finally4;
-			__catch4_g_error:
-			{
-				GError* error_ = NULL;
-				GFile* _tmp12_;
-				gchar* _tmp13_ = NULL;
-				gchar* _tmp14_;
-				const gchar* _tmp15_ = NULL;
-				GError* _tmp16_;
-				const gchar* _tmp17_;
-				const gchar* _tmp18_ = NULL;
-				gchar* _tmp19_ = NULL;
-				gchar* _tmp20_;
-				error_ = _inner_error_;
-				_inner_error_ = NULL;
-				_tmp12_ = child;
-				_tmp13_ = g_file_get_basename (_tmp12_);
-				_tmp14_ = _tmp13_;
-				_tmp15_ = string_to_string (_tmp14_);
-				_tmp16_ = error_;
-				_tmp17_ = _tmp16_->message;
-				_tmp18_ = string_to_string (_tmp17_);
-				_tmp19_ = g_strconcat ("Unable to delete file '", _tmp15_, ": ", _tmp18_, NULL);
-				_tmp20_ = _tmp19_;
-				g_warning ("metadata-menu-item.vala:92: %s", _tmp20_);
-				_g_free0 (_tmp20_);
-				_g_free0 (_tmp14_);
-				_result_ = FALSE;
-				_g_error_free0 (error_);
-			}
-			__finally4:
-			if (_inner_error_ != NULL) {
-				_g_object_unref0 (child);
-				_g_object_unref0 (file);
-				_g_object_unref0 (e);
-				goto __catch3_g_error;
-			}
-			_g_object_unref0 (child);
-			_g_object_unref0 (file);
-		}
-		_g_object_unref0 (e);
-	}
-	goto __finally3;
-	__catch3_g_error:
-	{
-		GError* _error_ = NULL;
-		GFile* _tmp21_;
-		gchar* _tmp22_ = NULL;
-		gchar* _tmp23_;
-		const gchar* _tmp24_ = NULL;
-		gchar* _tmp25_ = NULL;
-		gchar* _tmp26_;
-		GError* _tmp27_;
-		const gchar* _tmp28_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		_tmp21_ = dir;
-		_tmp22_ = g_file_get_basename (_tmp21_);
-		_tmp23_ = _tmp22_;
-		_tmp24_ = string_to_string (_tmp23_);
-		_tmp25_ = g_strconcat ("Unable to read files from directory '", _tmp24_, "': %s", NULL);
-		_tmp26_ = _tmp25_;
-		_tmp27_ = _error_;
-		_tmp28_ = _tmp27_->message;
-		g_warning (_tmp26_, _tmp28_);
-		_g_free0 (_tmp26_);
-		_g_free0 (_tmp23_);
-		_result_ = FALSE;
-		_g_error_free0 (_error_);
-	}
-	__finally3:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-		g_clear_error (&_inner_error_);
-		return FALSE;
-	}
-	result = _result_;
-	return result;
-}
-
-
-static gchar* string_strip (const gchar* self) {
-	gchar* result = NULL;
-	gchar* _tmp0_ = NULL;
-	gchar* _result_;
-	const gchar* _tmp1_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = g_strdup (self);
-	_result_ = _tmp0_;
-	_tmp1_ = _result_;
-	g_strstrip (_tmp1_);
-	result = _result_;
-	return result;
-}
-
-
-static void __lambda0_ (MetadataMenuitem* self) {
-	metadata_menuitem_on_fetcher_failed (self);
-}
-
-
-static void ___lambda0__fetch_file_failed (FetchFile* _sender, gpointer self) {
-	__lambda0_ (self);
-}
-
-
-static void _metadata_menuitem_on_fetcher_completed_fetch_file_completed (FetchFile* _sender, GByteArray* data, const gchar* property, gpointer self) {
-	metadata_menuitem_on_fetcher_completed (self, data, property);
-}
-
-
-void metadata_menuitem_fetch_art (MetadataMenuitem* self, const gchar* uri, const gchar* prop) {
-	const gchar* _tmp0_;
-	GFile* _tmp1_ = NULL;
-	GFile* art_file;
-	GFile* _tmp2_;
-	gboolean _tmp3_ = FALSE;
-	const gchar* _tmp19_;
-	const gchar* _tmp20_;
-	const gchar* _tmp21_;
-	const gchar* _tmp22_;
-	FetchFile* _tmp23_;
-	FetchFile* _tmp24_;
-	FetchFile* _tmp25_;
-	FetchFile* _tmp26_;
-	GError * _inner_error_ = NULL;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (uri != NULL);
-	g_return_if_fail (prop != NULL);
-	_tmp0_ = uri;
-	_tmp1_ = g_file_new_for_uri (_tmp0_);
-	art_file = _tmp1_;
-	_tmp2_ = art_file;
-	_tmp3_ = g_file_is_native (_tmp2_);
-	if (_tmp3_ == TRUE) {
-		GFile* _tmp4_;
-		gboolean _tmp5_ = FALSE;
-		gchar* path = NULL;
-		_tmp4_ = art_file;
-		_tmp5_ = g_file_query_exists (_tmp4_, NULL);
-		if (_tmp5_ == FALSE) {
-			const gchar* _tmp6_;
-			_tmp6_ = prop;
-			dbusmenu_menuitem_property_set_int ((DbusmenuMenuitem*) self, _tmp6_, PLAYER_ITEM_EMPTY);
-			_g_object_unref0 (art_file);
-			return;
-		}
-		{
-			const gchar* _tmp7_;
-			gchar* _tmp8_ = NULL;
-			gchar* _tmp9_;
-			gchar* _tmp10_ = NULL;
-			gchar* _tmp11_;
-			gchar* _tmp12_;
-			const gchar* _tmp13_;
-			gchar* _tmp14_ = NULL;
-			gchar* _tmp15_;
-			const gchar* _tmp16_;
-			const gchar* _tmp17_;
-			_tmp7_ = uri;
-			_tmp8_ = string_strip (_tmp7_);
-			_tmp9_ = _tmp8_;
-			_tmp10_ = g_filename_from_uri (_tmp9_, NULL, &_inner_error_);
-			_tmp11_ = _tmp10_;
-			_g_free0 (_tmp9_);
-			_tmp12_ = _tmp11_;
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == G_CONVERT_ERROR) {
-					goto __catch5_g_convert_error;
-				}
-				_g_free0 (path);
-				_g_object_unref0 (art_file);
-				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-				g_clear_error (&_inner_error_);
-				return;
-			}
-			_g_free0 (path);
-			path = _tmp12_;
-			_tmp13_ = uri;
-			_tmp14_ = string_strip (_tmp13_);
-			_tmp15_ = _tmp14_;
-			g_debug ("metadata-menu-item.vala:116: Populating the artwork field with %s", _tmp15_);
-			_g_free0 (_tmp15_);
-			_tmp16_ = prop;
-			_tmp17_ = path;
-			dbusmenu_menuitem_property_set ((DbusmenuMenuitem*) self, _tmp16_, _tmp17_);
-		}
-		goto __finally5;
-		__catch5_g_convert_error:
-		{
-			GError* e = NULL;
-			const gchar* _tmp18_;
-			e = _inner_error_;
-			_inner_error_ = NULL;
-			_tmp18_ = uri;
-			g_warning ("metadata-menu-item.vala:120: Problem converting URI %s to file path", _tmp18_);
-			_g_error_free0 (e);
-		}
-		__finally5:
-		if (_inner_error_ != NULL) {
-			_g_free0 (path);
-			_g_object_unref0 (art_file);
-			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-			g_clear_error (&_inner_error_);
-			return;
-		}
-		_g_free0 (path);
-		_g_object_unref0 (art_file);
-		return;
-	}
-	_tmp19_ = metadata_menuitem_album_art_cache_dir;
-	g_debug ("metadata-menu-item.vala:126: fetch_art -remotely %s", _tmp19_);
-	_tmp20_ = metadata_menuitem_album_art_cache_dir;
-	if (_tmp20_ == NULL) {
-		_g_object_unref0 (art_file);
-		return;
-	}
-	_tmp21_ = uri;
-	_tmp22_ = prop;
-	_tmp23_ = fetch_file_new (_tmp21_, _tmp22_);
-	_g_object_unref0 (metadata_menuitem_fetcher);
-	metadata_menuitem_fetcher = _tmp23_;
-	_tmp24_ = metadata_menuitem_fetcher;
-	g_signal_connect_object (_tmp24_, "failed", (GCallback) ___lambda0__fetch_file_failed, self, 0);
-	_tmp25_ = metadata_menuitem_fetcher;
-	g_signal_connect_object (_tmp25_, "completed", (GCallback) _metadata_menuitem_on_fetcher_completed_fetch_file_completed, self, 0);
-	_tmp26_ = metadata_menuitem_fetcher;
-	fetch_file_fetch_data (_tmp26_, NULL, NULL);
-	_g_object_unref0 (art_file);
-}
-
-
-static void metadata_menuitem_on_fetcher_failed (MetadataMenuitem* self) {
-	g_return_if_fail (self != NULL);
-	g_warning ("metadata-menu-item.vala:141: on_fetcher_failed -> could not fetch artw" \
-"ork");
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static void metadata_menuitem_on_fetcher_completed (MetadataMenuitem* self, GByteArray* update, const gchar* property) {
-	GError * _inner_error_ = NULL;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (update != NULL);
-	g_return_if_fail (property != NULL);
-	{
-		GdkPixbufLoader* _tmp0_;
-		GdkPixbufLoader* loader;
-		GdkPixbufLoader* _tmp1_;
-		GByteArray* _tmp2_;
-		guint8* _tmp3_;
-		gint _tmp3__length1;
-		GdkPixbufLoader* _tmp4_;
-		GdkPixbufLoader* _tmp5_;
-		GdkPixbuf* _tmp6_ = NULL;
-		GdkPixbuf* _tmp7_;
-		GdkPixbuf* icon;
-		const gchar* _tmp8_;
-		gchar* _tmp9_ = NULL;
-		gchar* path;
-		const gchar* _tmp10_;
-		gint _tmp11_ = 0;
-		gint r;
-		gint _tmp12_;
-		_tmp0_ = gdk_pixbuf_loader_new ();
-		loader = _tmp0_;
-		_tmp1_ = loader;
-		_tmp2_ = update;
-		_tmp3_ = _tmp2_->data;
-		_tmp3__length1 = (gint) _tmp2_->len;
-		gdk_pixbuf_loader_write (_tmp1_, _tmp3_, (gsize) _tmp3__length1, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			_g_object_unref0 (loader);
-			goto __catch6_g_error;
-		}
-		_tmp4_ = loader;
-		gdk_pixbuf_loader_close (_tmp4_, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			_g_object_unref0 (loader);
-			goto __catch6_g_error;
-		}
-		_tmp5_ = loader;
-		_tmp6_ = gdk_pixbuf_loader_get_pixbuf (_tmp5_);
-		_tmp7_ = _g_object_ref0 (_tmp6_);
-		icon = _tmp7_;
-		_tmp8_ = metadata_menuitem_album_art_cache_dir;
-		_tmp9_ = g_strconcat (_tmp8_, "/downloaded-coverart-XXXXXX", NULL);
-		path = _tmp9_;
-		_tmp10_ = path;
-		_tmp11_ = g_mkstemp (_tmp10_);
-		r = _tmp11_;
-		_tmp12_ = r;
-		if (_tmp12_ != (-1)) {
-			GdkPixbuf* _tmp13_;
-			const gchar* _tmp14_;
-			GdkPixbufLoader* _tmp15_;
-			GdkPixbufFormat* _tmp16_ = NULL;
-			const gchar* _tmp17_ = NULL;
-			const gchar* _tmp18_;
-			const gchar* _tmp19_;
-			const gchar* _tmp20_;
-			const gchar* _tmp22_;
-			gchar* _tmp23_;
-			_tmp13_ = icon;
-			_tmp14_ = path;
-			_tmp15_ = loader;
-			_tmp16_ = gdk_pixbuf_loader_get_format (_tmp15_);
-			_tmp17_ = gdk_pixbuf_format_get_name (_tmp16_);
-			gdk_pixbuf_save (_tmp13_, _tmp14_, _tmp17_, &_inner_error_, NULL);
-			if (_inner_error_ != NULL) {
-				_g_free0 (path);
-				_g_object_unref0 (icon);
-				_g_object_unref0 (loader);
-				goto __catch6_g_error;
-			}
-			_tmp18_ = property;
-			_tmp19_ = path;
-			dbusmenu_menuitem_property_set ((DbusmenuMenuitem*) self, _tmp18_, _tmp19_);
-			_tmp20_ = self->priv->previous_temp_album_art_path;
-			if (_tmp20_ != NULL) {
-				const gchar* _tmp21_;
-				_tmp21_ = self->priv->previous_temp_album_art_path;
-				g_remove (_tmp21_);
-			}
-			_tmp22_ = path;
-			_tmp23_ = g_strdup (_tmp22_);
-			_g_free0 (self->priv->previous_temp_album_art_path);
-			self->priv->previous_temp_album_art_path = _tmp23_;
-		}
-		_g_free0 (path);
-		_g_object_unref0 (icon);
-		_g_object_unref0 (loader);
-	}
-	goto __finally6;
-	__catch6_g_error:
-	{
-		GError* e = NULL;
-		GError* _tmp24_;
-		const gchar* _tmp25_;
-		e = _inner_error_;
-		_inner_error_ = NULL;
-		_tmp24_ = e;
-		_tmp25_ = _tmp24_->message;
-		g_warning ("metadata-menu-item.vala:163: Problem creating file from bytearray fetc" \
-"hed from the interweb - error: %s", _tmp25_);
-		_g_error_free0 (e);
-	}
-	__finally6:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-}
-
-
-static void metadata_menuitem_real_handle_event (DbusmenuMenuitem* base, const gchar* name, GVariant* input_value, guint timestamp) {
-	MetadataMenuitem * self;
-	PlayerController* _tmp0_;
-	PlayerController* _tmp1_;
-	gint _tmp2_;
-	self = (MetadataMenuitem*) base;
-	g_return_if_fail (name != NULL);
-	g_return_if_fail (input_value != NULL);
-	_tmp0_ = player_item_get_owner ((PlayerItem*) self);
-	_tmp1_ = _tmp0_;
-	_tmp2_ = _tmp1_->current_state;
-	if (_tmp2_ == ((gint) PLAYER_CONTROLLER_STATE_OFFLINE)) {
-		PlayerController* _tmp3_;
-		PlayerController* _tmp4_;
-		_tmp3_ = player_item_get_owner ((PlayerItem*) self);
-		_tmp4_ = _tmp3_;
-		player_controller_instantiate (_tmp4_);
-	} else {
-		PlayerController* _tmp5_;
-		PlayerController* _tmp6_;
-		gint _tmp7_;
-		_tmp5_ = player_item_get_owner ((PlayerItem*) self);
-		_tmp6_ = _tmp5_;
-		_tmp7_ = _tmp6_->current_state;
-		if (_tmp7_ == ((gint) PLAYER_CONTROLLER_STATE_CONNECTED)) {
-			PlayerController* _tmp8_;
-			PlayerController* _tmp9_;
-			Mpris2Controller* _tmp10_;
-			_tmp8_ = player_item_get_owner ((PlayerItem*) self);
-			_tmp9_ = _tmp8_;
-			_tmp10_ = _tmp9_->mpris_bridge;
-			mpris2_controller_expose (_tmp10_);
-		}
-	}
-}
-
-
-void metadata_menuitem_alter_label (MetadataMenuitem* self, const gchar* new_title) {
-	const gchar* _tmp0_;
-	const gchar* _tmp1_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = new_title;
-	if (_tmp0_ == NULL) {
-		return;
-	}
-	_tmp1_ = new_title;
-	dbusmenu_menuitem_property_set ((DbusmenuMenuitem*) self, DBUSMENU_METADATA_MENUITEM_PLAYER_NAME, _tmp1_);
-}
-
-
-void metadata_menuitem_toggle_active_triangle (MetadataMenuitem* self, gboolean update) {
-	gboolean _tmp0_;
-	g_return_if_fail (self != NULL);
-	g_debug ("metadata-menu-item.vala:189: toggle active triangle");
-	_tmp0_ = update;
-	dbusmenu_menuitem_property_set_bool ((DbusmenuMenuitem*) self, DBUSMENU_METADATA_MENUITEM_PLAYER_RUNNING, _tmp0_);
-}
-
-
-void metadata_menuitem_should_collapse (MetadataMenuitem* self, gboolean collapse) {
-	gboolean _tmp0_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = collapse;
-	dbusmenu_menuitem_property_set_bool ((DbusmenuMenuitem*) self, DBUSMENU_METADATA_MENUITEM_HIDE_TRACK_DETAILS, _tmp0_);
-}
-
-
-GeeHashSet* metadata_menuitem_attributes_format (void) {
-	GeeHashSet* result = NULL;
-	GeeHashSet* _tmp0_;
-	GeeHashSet* attrs;
-	_tmp0_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL);
-	attrs = _tmp0_;
-	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_METADATA_MENUITEM_TITLE);
-	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_METADATA_MENUITEM_ARTIST);
-	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_METADATA_MENUITEM_ALBUM);
-	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_METADATA_MENUITEM_ARTURL);
-	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_METADATA_MENUITEM_PLAYER_NAME);
-	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_METADATA_MENUITEM_PLAYER_ICON);
-	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_METADATA_MENUITEM_PLAYER_RUNNING);
-	result = attrs;
-	return result;
-}
-
-
-GeeHashSet* metadata_menuitem_relevant_attributes_for_ui (void) {
-	GeeHashSet* result = NULL;
-	GeeHashSet* _tmp0_;
-	GeeHashSet* attrs;
-	_tmp0_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL);
-	attrs = _tmp0_;
-	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_METADATA_MENUITEM_TITLE);
-	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_METADATA_MENUITEM_ARTIST);
-	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_METADATA_MENUITEM_ALBUM);
-	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_METADATA_MENUITEM_ARTURL);
-	result = attrs;
-	return result;
-}
-
-
-static GObject * metadata_menuitem_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
-	GObject * obj;
-	GObjectClass * parent_class;
-	MetadataMenuitem * self;
-	gchar* _tmp0_ = NULL;
-	PlayerController* _tmp1_;
-	PlayerController* _tmp2_;
-	GAppInfo* _tmp3_;
-	GAppInfo* _tmp4_;
-	const gchar* _tmp5_ = NULL;
-	PlayerController* _tmp6_;
-	PlayerController* _tmp7_;
-	const gchar* _tmp8_;
-	const gchar* _tmp9_;
-	GeeHashSet* _tmp10_ = NULL;
-	GeeHashSet* _tmp11_;
-	parent_class = G_OBJECT_CLASS (metadata_menuitem_parent_class);
-	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
-	self = METADATA_MENUITEM (obj);
-	metadata_menuitem_clean_album_art_temp_dir ();
-	_g_free0 (self->priv->previous_temp_album_art_path);
-	self->priv->previous_temp_album_art_path = NULL;
-	_tmp0_ = metadata_menuitem_create_album_art_temp_dir ();
-	_g_free0 (metadata_menuitem_album_art_cache_dir);
-	metadata_menuitem_album_art_cache_dir = _tmp0_;
-	_tmp1_ = player_item_get_owner ((PlayerItem*) self);
-	_tmp2_ = _tmp1_;
-	_tmp3_ = player_controller_get_app_info (_tmp2_);
-	_tmp4_ = _tmp3_;
-	_tmp5_ = g_app_info_get_name (_tmp4_);
-	dbusmenu_menuitem_property_set ((DbusmenuMenuitem*) self, DBUSMENU_METADATA_MENUITEM_PLAYER_NAME, _tmp5_);
-	_tmp6_ = player_item_get_owner ((PlayerItem*) self);
-	_tmp7_ = _tmp6_;
-	_tmp8_ = player_controller_get_icon_name (_tmp7_);
-	_tmp9_ = _tmp8_;
-	dbusmenu_menuitem_property_set ((DbusmenuMenuitem*) self, DBUSMENU_METADATA_MENUITEM_PLAYER_ICON, _tmp9_);
-	dbusmenu_menuitem_property_set_bool ((DbusmenuMenuitem*) self, DBUSMENU_METADATA_MENUITEM_PLAYER_RUNNING, FALSE);
-	dbusmenu_menuitem_property_set_bool ((DbusmenuMenuitem*) self, DBUSMENU_METADATA_MENUITEM_HIDE_TRACK_DETAILS, TRUE);
-	_tmp10_ = metadata_menuitem_relevant_attributes_for_ui ();
-	_tmp11_ = _tmp10_;
-	player_item_reset ((PlayerItem*) self, _tmp11_);
-	_g_object_unref0 (_tmp11_);
-	return obj;
-}
-
-
-static void metadata_menuitem_class_init (MetadataMenuitemClass * klass) {
-	metadata_menuitem_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (MetadataMenuitemPrivate));
-	DBUSMENU_MENUITEM_CLASS (klass)->handle_event = metadata_menuitem_real_handle_event;
-	G_OBJECT_CLASS (klass)->constructor = metadata_menuitem_constructor;
-	G_OBJECT_CLASS (klass)->finalize = metadata_menuitem_finalize;
-}
-
-
-static void metadata_menuitem_instance_init (MetadataMenuitem * self) {
-	self->priv = METADATA_MENUITEM_GET_PRIVATE (self);
-}
-
-
-static void metadata_menuitem_finalize (GObject* obj) {
-	MetadataMenuitem * self;
-	self = METADATA_MENUITEM (obj);
-	_g_free0 (self->priv->previous_temp_album_art_path);
-	G_OBJECT_CLASS (metadata_menuitem_parent_class)->finalize (obj);
-}
-
-
-GType metadata_menuitem_get_type (void) {
-	static volatile gsize metadata_menuitem_type_id__volatile = 0;
-	if (g_once_init_enter (&metadata_menuitem_type_id__volatile)) {
-		static const GTypeInfo g_define_type_info = { sizeof (MetadataMenuitemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) metadata_menuitem_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MetadataMenuitem), 0, (GInstanceInitFunc) metadata_menuitem_instance_init, NULL };
-		GType metadata_menuitem_type_id;
-		metadata_menuitem_type_id = g_type_register_static (TYPE_PLAYER_ITEM, "MetadataMenuitem", &g_define_type_info, 0);
-		g_once_init_leave (&metadata_menuitem_type_id__volatile, metadata_menuitem_type_id);
-	}
-	return metadata_menuitem_type_id__volatile;
-}
-
-
-
diff -Naur indicator-sound-0.8.5.0/src/metadata-widget.c indicator-sound-precise/src/metadata-widget.c
--- indicator-sound-0.8.5.0/src/metadata-widget.c	2012-03-30 10:30:51.000000000 -0700
+++ indicator-sound-precise/src/metadata-widget.c	2012-07-26 21:03:55.488143000 -0700
@@ -68,7 +68,8 @@
                                              GVariant* value,
                                              gpointer userdata);
 static void metadata_widget_style_labels ( MetadataWidget* self,
-                                           GtkLabel* label);
+                                           GtkLabel* label,
+                                           gchar* markup_str);
 static void draw_album_art_placeholder (GtkWidget *metadata);
 
 static void draw_album_border (GtkWidget *metadata, gboolean selected);
@@ -138,7 +139,7 @@
   #else
   hbox = gtk_hbox_new(FALSE, 0);
   #endif 
-  
+
   priv->meta_data_h_box = hbox;
   priv->current_height = 1;
   
@@ -155,6 +156,7 @@
   g_signal_connect_after (GTK_WIDGET(self), "draw", 
                           G_CALLBACK(metadata_widget_icon_triangle_draw_cb_gtk_3),
                           GTK_WIDGET(self));
+
   #else
   g_signal_connect(priv->album_art, "expose-event", 
                    G_CALLBACK(metadata_image_expose),
@@ -185,7 +187,7 @@
   gtk_widget_set_size_request (artist, 140, 15);
 
   gtk_label_set_ellipsize(GTK_LABEL(artist), PANGO_ELLIPSIZE_MIDDLE); 
-  metadata_widget_style_labels(self, GTK_LABEL(artist));
+  metadata_widget_style_labels(self, GTK_LABEL(artist), NULL);
   priv->artist_label = artist;
   
   // title
@@ -196,7 +198,7 @@
   
   gtk_widget_set_size_request (piece, 140, 15);
   gtk_label_set_ellipsize(GTK_LABEL(piece), PANGO_ELLIPSIZE_MIDDLE);
-  metadata_widget_style_labels(self, GTK_LABEL(piece));
+  metadata_widget_style_labels(self, GTK_LABEL(piece), "<b>%s</b>");
   priv->piece_label =  piece;
 
   // container
@@ -207,7 +209,7 @@
   gtk_widget_set_size_request (container, 140, 15);
 
   gtk_label_set_ellipsize(GTK_LABEL(container), PANGO_ELLIPSIZE_MIDDLE);  
-  metadata_widget_style_labels(self, GTK_LABEL(container));
+  metadata_widget_style_labels(self, GTK_LABEL(container), NULL);
   priv->container_label = container;
 
   gtk_box_pack_start (GTK_BOX (vbox), priv->piece_label, FALSE, FALSE, 0);  
@@ -222,6 +224,8 @@
                    G_CALLBACK(metadata_widget_selection_received_event_callback),
                    GTK_WIDGET(self));   
 
+
+
   gint padding = 4;
   gtk_widget_style_get(GTK_WIDGET(self), "toggle-spacing", &padding, NULL);
 
@@ -289,7 +293,8 @@
 }
 
 
-#if GTK_CHECK_VERSION(3, 0, 0)  
+#if GTK_CHECK_VERSION(3, 0, 0)
+
 static void
 metadata_widget_get_preferred_width (GtkWidget* self,
                                      gint* minimum_width,
@@ -717,15 +722,15 @@
   
   if(g_ascii_strcasecmp(DBUSMENU_METADATA_MENUITEM_ARTIST, property) == 0){  
     gtk_label_set_text(GTK_LABEL(priv->artist_label), g_variant_get_string(value, NULL));
-    metadata_widget_style_labels(mitem, GTK_LABEL(priv->artist_label));
+    metadata_widget_style_labels(mitem, GTK_LABEL(priv->artist_label), NULL);
   }
   else if(g_ascii_strcasecmp(DBUSMENU_METADATA_MENUITEM_TITLE, property) == 0){  
     gtk_label_set_text(GTK_LABEL(priv->piece_label), g_variant_get_string(value, NULL));    
-    metadata_widget_style_labels(mitem, GTK_LABEL(priv->piece_label));
+    metadata_widget_style_labels(mitem, GTK_LABEL(priv->piece_label), "<b>%s</b>");
   } 
   else if(g_ascii_strcasecmp(DBUSMENU_METADATA_MENUITEM_ALBUM, property) == 0){  
     gtk_label_set_text(GTK_LABEL(priv->container_label), g_variant_get_string(value, NULL));
-    metadata_widget_style_labels(mitem, GTK_LABEL(priv->container_label));
+    metadata_widget_style_labels(mitem, GTK_LABEL(priv->container_label), NULL);
   } 
   else if(g_ascii_strcasecmp(DBUSMENU_METADATA_MENUITEM_ARTURL, property) == 0){
     g_string_erase(priv->image_path, 0, -1);
@@ -756,17 +761,20 @@
   else{
     gtk_widget_show (priv->meta_data_h_box);     
   }
+
   gtk_widget_queue_draw(GTK_WIDGET(self));
 }
 
 static void
-metadata_widget_style_labels(MetadataWidget* self, GtkLabel* label)
+metadata_widget_style_labels(MetadataWidget* self, GtkLabel* label, char* markup_str)
 {
+  if (markup_str == NULL)
+    markup_str = "%s";
+
   char* markup;
-  markup = g_markup_printf_escaped ("<span size=\"smaller\">%s</span>",
-                                    gtk_label_get_text(GTK_LABEL(label)));
+  markup = g_markup_printf_escaped (markup_str, gtk_label_get_text(GTK_LABEL(label)));
   gtk_label_set_markup (GTK_LABEL (label), markup);
-  g_free(markup); 
+  g_free(markup);
 }
 
 static void
@@ -822,16 +830,16 @@
   gtk_label_set_text( GTK_LABEL(priv->container_label), 
                       dbusmenu_menuitem_property_get( priv->twin_item,
                                                       DBUSMENU_METADATA_MENUITEM_ALBUM));
-  metadata_widget_style_labels( self, GTK_LABEL(priv->container_label));
+  metadata_widget_style_labels( self, GTK_LABEL(priv->container_label), NULL);
 
   gtk_label_set_text( GTK_LABEL(priv->piece_label), 
                       dbusmenu_menuitem_property_get( priv->twin_item,
                                                       DBUSMENU_METADATA_MENUITEM_TITLE));
-  metadata_widget_style_labels( self, GTK_LABEL(priv->piece_label));
+  metadata_widget_style_labels( self, GTK_LABEL(priv->piece_label), "<b>%s</b>");
   gtk_label_set_text( GTK_LABEL(priv->artist_label), 
                       dbusmenu_menuitem_property_get( priv->twin_item,
                                                       DBUSMENU_METADATA_MENUITEM_ARTIST));
-  metadata_widget_style_labels( self, GTK_LABEL(priv->artist_label));
+  metadata_widget_style_labels( self, GTK_LABEL(priv->artist_label), NULL);
 
   g_string_erase(priv->image_path, 0, -1);
   const gchar *arturl = dbusmenu_menuitem_property_get( priv->twin_item,
diff -Naur indicator-sound-0.8.5.0/src/mpris2-controller.c indicator-sound-precise/src/mpris2-controller.c
--- indicator-sound-0.8.5.0/src/mpris2-controller.c	2012-03-30 10:32:34.000000000 -0700
+++ indicator-sound-precise/src/mpris2-controller.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,1769 +0,0 @@
-/* mpris2-controller.c generated by valac 0.14.2, the Vala compiler
- * generated from mpris2-controller.vala, do not modify */
-
-/*
-Copyright 2010 Canonical Ltd.
-
-Authors:
-    Conor Curran <conor.curran@canonical.com>
-
-This program is free software: you can redistribute it and/or modify it 
-under the terms of the GNU General Public License version 3, as published 
-by the Free Software Foundation.
-
-This program is distributed in the hope that it will be useful, but 
-WITHOUT ANY WARRANTY; without even the implied warranties of 
-MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
-PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along 
-with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gio/gio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <common-defs.h>
-#include <libdbusmenu-glib/client.h>
-#include <libdbusmenu-glib/dbusmenu-glib.h>
-#include <libdbusmenu-glib/enum-types.h>
-#include <libdbusmenu-glib/menuitem-proxy.h>
-#include <libdbusmenu-glib/menuitem.h>
-#include <libdbusmenu-glib/server.h>
-#include <libdbusmenu-glib/types.h>
-#include <gee.h>
-
-
-#define TYPE_MPRIS2_CONTROLLER (mpris2_controller_get_type ())
-#define MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2Controller))
-#define MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
-#define IS_MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS2_CONTROLLER))
-#define IS_MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS2_CONTROLLER))
-#define MPRIS2_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
-
-typedef struct _Mpris2Controller Mpris2Controller;
-typedef struct _Mpris2ControllerClass Mpris2ControllerClass;
-typedef struct _Mpris2ControllerPrivate Mpris2ControllerPrivate;
-
-#define TYPE_MPRIS_ROOT (mpris_root_get_type ())
-#define MPRIS_ROOT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_ROOT, MprisRoot))
-#define IS_MPRIS_ROOT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_ROOT))
-#define MPRIS_ROOT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MPRIS_ROOT, MprisRootIface))
-
-typedef struct _MprisRoot MprisRoot;
-typedef struct _MprisRootIface MprisRootIface;
-
-#define TYPE_MPRIS_ROOT_PROXY (mpris_root_proxy_get_type ())
-
-#define TYPE_MPRIS_PLAYER (mpris_player_get_type ())
-#define MPRIS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_PLAYER, MprisPlayer))
-#define IS_MPRIS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_PLAYER))
-#define MPRIS_PLAYER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MPRIS_PLAYER, MprisPlayerIface))
-
-typedef struct _MprisPlayer MprisPlayer;
-typedef struct _MprisPlayerIface MprisPlayerIface;
-
-#define TYPE_MPRIS_PLAYER_PROXY (mpris_player_proxy_get_type ())
-
-#define TYPE_MPRIS_PLAYLISTS (mpris_playlists_get_type ())
-#define MPRIS_PLAYLISTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_PLAYLISTS, MprisPlaylists))
-#define IS_MPRIS_PLAYLISTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_PLAYLISTS))
-#define MPRIS_PLAYLISTS_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MPRIS_PLAYLISTS, MprisPlaylistsIface))
-
-typedef struct _MprisPlaylists MprisPlaylists;
-typedef struct _MprisPlaylistsIface MprisPlaylistsIface;
-
-#define TYPE_MPRIS_PLAYLISTS_PROXY (mpris_playlists_proxy_get_type ())
-
-#define TYPE_PLAYLIST_DETAILS (playlist_details_get_type ())
-typedef struct _PlaylistDetails PlaylistDetails;
-
-#define TYPE_ACTIVE_PLAYLIST_CONTAINER (active_playlist_container_get_type ())
-typedef struct _ActivePlaylistContainer ActivePlaylistContainer;
-
-#define TYPE_FREE_DESKTOP_PROPERTIES (free_desktop_properties_get_type ())
-#define FREE_DESKTOP_PROPERTIES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FREE_DESKTOP_PROPERTIES, FreeDesktopProperties))
-#define IS_FREE_DESKTOP_PROPERTIES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FREE_DESKTOP_PROPERTIES))
-#define FREE_DESKTOP_PROPERTIES_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_FREE_DESKTOP_PROPERTIES, FreeDesktopPropertiesIface))
-
-typedef struct _FreeDesktopProperties FreeDesktopProperties;
-typedef struct _FreeDesktopPropertiesIface FreeDesktopPropertiesIface;
-
-#define TYPE_FREE_DESKTOP_PROPERTIES_PROXY (free_desktop_properties_proxy_get_type ())
-
-#define TYPE_PLAYER_CONTROLLER (player_controller_get_type ())
-#define PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONTROLLER, PlayerController))
-#define PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-#define IS_PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONTROLLER))
-#define IS_PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONTROLLER))
-#define PLAYER_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-
-typedef struct _PlayerController PlayerController;
-typedef struct _PlayerControllerClass PlayerControllerClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-typedef struct _PlayerControllerPrivate PlayerControllerPrivate;
-
-#define TYPE_PLAYER_ITEM (player_item_get_type ())
-#define PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_ITEM, PlayerItem))
-#define PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_ITEM, PlayerItemClass))
-#define IS_PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_ITEM))
-#define IS_PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_ITEM))
-#define PLAYER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_ITEM, PlayerItemClass))
-
-typedef struct _PlayerItem PlayerItem;
-typedef struct _PlayerItemClass PlayerItemClass;
-
-#define PLAYER_CONTROLLER_TYPE_WIDGET_ORDER (player_controller_widget_order_get_type ())
-
-#define TYPE_TRANSPORT_MENUITEM (transport_menuitem_get_type ())
-#define TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitem))
-#define TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))
-#define IS_TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRANSPORT_MENUITEM))
-#define IS_TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRANSPORT_MENUITEM))
-#define TRANSPORT_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))
-
-typedef struct _TransportMenuitem TransportMenuitem;
-typedef struct _TransportMenuitemClass TransportMenuitemClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-#define TYPE_METADATA_MENUITEM (metadata_menuitem_get_type ())
-#define METADATA_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_METADATA_MENUITEM, MetadataMenuitem))
-#define METADATA_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_METADATA_MENUITEM, MetadataMenuitemClass))
-#define IS_METADATA_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_METADATA_MENUITEM))
-#define IS_METADATA_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_METADATA_MENUITEM))
-#define METADATA_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_METADATA_MENUITEM, MetadataMenuitemClass))
-
-typedef struct _MetadataMenuitem MetadataMenuitem;
-typedef struct _MetadataMenuitemClass MetadataMenuitemClass;
-#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
-#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
-
-#define TYPE_PLAYLISTS_MENUITEM (playlists_menuitem_get_type ())
-#define PLAYLISTS_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYLISTS_MENUITEM, PlaylistsMenuitem))
-#define PLAYLISTS_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYLISTS_MENUITEM, PlaylistsMenuitemClass))
-#define IS_PLAYLISTS_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYLISTS_MENUITEM))
-#define IS_PLAYLISTS_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYLISTS_MENUITEM))
-#define PLAYLISTS_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYLISTS_MENUITEM, PlaylistsMenuitemClass))
-
-typedef struct _PlaylistsMenuitem PlaylistsMenuitem;
-typedef struct _PlaylistsMenuitemClass PlaylistsMenuitemClass;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-typedef struct _Mpris2ControllerFetchPlaylistsData Mpris2ControllerFetchPlaylistsData;
-#define _active_playlist_container_free0(var) ((var == NULL) ? NULL : (var = (active_playlist_container_free (var), NULL)))
-
-struct _Mpris2Controller {
-	GObject parent_instance;
-	Mpris2ControllerPrivate * priv;
-};
-
-struct _Mpris2ControllerClass {
-	GObjectClass parent_class;
-};
-
-struct _MprisRootIface {
-	GTypeInterface parent_iface;
-	void (*Quit) (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*Quit_finish) (MprisRoot* self, GAsyncResult* _res_, GError** error);
-	void (*Raise) (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*Raise_finish) (MprisRoot* self, GAsyncResult* _res_, GError** error);
-	gboolean (*get_HasTracklist) (MprisRoot* self);
-	void (*set_HasTracklist) (MprisRoot* self, gboolean value);
-	gboolean (*get_CanQuit) (MprisRoot* self);
-	void (*set_CanQuit) (MprisRoot* self, gboolean value);
-	gboolean (*get_CanRaise) (MprisRoot* self);
-	void (*set_CanRaise) (MprisRoot* self, gboolean value);
-	gchar* (*get_Identity) (MprisRoot* self);
-	void (*set_Identity) (MprisRoot* self, const gchar* value);
-	gchar* (*get_DesktopEntry) (MprisRoot* self);
-	void (*set_DesktopEntry) (MprisRoot* self, const gchar* value);
-};
-
-struct _MprisPlayerIface {
-	GTypeInterface parent_iface;
-	void (*PlayPause) (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*PlayPause_finish) (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-	void (*Next) (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*Next_finish) (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-	void (*Previous) (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*Previous_finish) (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-	void (*Seek) (MprisPlayer* self, gint64 offset, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*Seek_finish) (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-	GHashTable* (*get_Metadata) (MprisPlayer* self);
-	void (*set_Metadata) (MprisPlayer* self, GHashTable* value);
-	gint32 (*get_Position) (MprisPlayer* self);
-	void (*set_Position) (MprisPlayer* self, gint32 value);
-	gchar* (*get_PlaybackStatus) (MprisPlayer* self);
-	void (*set_PlaybackStatus) (MprisPlayer* self, const gchar* value);
-};
-
-struct _PlaylistDetails {
-	char* path;
-	gchar* name;
-	gchar* icon_path;
-};
-
-struct _ActivePlaylistContainer {
-	gboolean valid;
-	PlaylistDetails* details;
-};
-
-struct _MprisPlaylistsIface {
-	GTypeInterface parent_iface;
-	void (*ActivatePlaylist) (MprisPlaylists* self, const char* playlist_id, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*ActivatePlaylist_finish) (MprisPlaylists* self, GAsyncResult* _res_, GError** error);
-	void (*GetPlaylists) (MprisPlaylists* self, guint32 index, guint32 max_count, const gchar* order, gboolean reverse_order, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	PlaylistDetails* (*GetPlaylists_finish) (MprisPlaylists* self, GAsyncResult* _res_, int* result_length1, GError** error);
-	gchar** (*get_Orderings) (MprisPlaylists* self, int* result_length1);
-	void (*set_Orderings) (MprisPlaylists* self, gchar** value, int value_length1);
-	guint32 (*get_PlaylistCount) (MprisPlaylists* self);
-	void (*set_PlaylistCount) (MprisPlaylists* self, guint32 value);
-	ActivePlaylistContainer* (*get_ActivePlaylist) (MprisPlaylists* self);
-	void (*set_ActivePlaylist) (MprisPlaylists* self, ActivePlaylistContainer* value);
-};
-
-struct _FreeDesktopPropertiesIface {
-	GTypeInterface parent_iface;
-};
-
-struct _Mpris2ControllerPrivate {
-	MprisRoot* _mpris2_root;
-	MprisPlayer* _player;
-	MprisPlaylists* _playlists;
-	FreeDesktopProperties* _properties_interface;
-	PlayerController* _owner;
-};
-
-struct _PlayerController {
-	GObject parent_instance;
-	PlayerControllerPrivate * priv;
-	gint current_state;
-	DbusmenuMenuitem* root_menu;
-	GeeArrayList* custom_items;
-	Mpris2Controller* mpris_bridge;
-	gboolean* use_playlists;
-};
-
-struct _PlayerControllerClass {
-	GObjectClass parent_class;
-};
-
-typedef enum  {
-	PLAYER_CONTROLLER_WIDGET_ORDER_SEPARATOR,
-	PLAYER_CONTROLLER_WIDGET_ORDER_METADATA,
-	PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT,
-	PLAYER_CONTROLLER_WIDGET_ORDER_PLAYLISTS
-} PlayerControllerwidget_order;
-
-struct _Mpris2ControllerFetchPlaylistsData {
-	int _state_;
-	GObject* _source_object_;
-	GAsyncResult* _res_;
-	GSimpleAsyncResult* _async_result;
-	Mpris2Controller* self;
-	PlaylistDetails* current_playlists;
-	gint current_playlists_length1;
-	gint _current_playlists_size_;
-	MprisPlaylists* _tmp0_;
-	gint _tmp1_;
-	PlaylistDetails* _tmp2_;
-	PlaylistDetails* _tmp3_;
-	gint _tmp3__length1;
-	gint __tmp3__size_;
-	GError* e;
-	PlaylistDetails* _tmp4_;
-	gint _tmp4__length1;
-	PlayerController* _tmp5_;
-	GeeArrayList* _tmp6_;
-	gpointer _tmp7_;
-	PlaylistsMenuitem* playlists_item;
-	PlaylistsMenuitem* _tmp8_;
-	PlaylistDetails* _tmp9_;
-	gint _tmp9__length1;
-	PlayerController* _tmp10_;
-	GAppInfo* _tmp11_;
-	GAppInfo* _tmp12_;
-	const gchar* _tmp13_;
-	PlayerController* _tmp14_;
-	gboolean _tmp15_;
-	gboolean* _tmp16_;
-	GError * _inner_error_;
-};
-
-
-static gpointer mpris2_controller_parent_class = NULL;
-
-GType mpris2_controller_get_type (void) G_GNUC_CONST;
-GType mpris_root_proxy_get_type (void) G_GNUC_CONST;
-guint mpris_root_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-GType mpris_root_get_type (void) G_GNUC_CONST;
-GType mpris_player_proxy_get_type (void) G_GNUC_CONST;
-guint mpris_player_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-GType mpris_player_get_type (void) G_GNUC_CONST;
-GType mpris_playlists_proxy_get_type (void) G_GNUC_CONST;
-guint mpris_playlists_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-GType playlist_details_get_type (void) G_GNUC_CONST;
-PlaylistDetails* playlist_details_dup (const PlaylistDetails* self);
-void playlist_details_free (PlaylistDetails* self);
-void playlist_details_copy (const PlaylistDetails* self, PlaylistDetails* dest);
-void playlist_details_destroy (PlaylistDetails* self);
-GType active_playlist_container_get_type (void) G_GNUC_CONST;
-ActivePlaylistContainer* active_playlist_container_dup (const ActivePlaylistContainer* self);
-void active_playlist_container_free (ActivePlaylistContainer* self);
-void active_playlist_container_copy (const ActivePlaylistContainer* self, ActivePlaylistContainer* dest);
-void active_playlist_container_destroy (ActivePlaylistContainer* self);
-GType mpris_playlists_get_type (void) G_GNUC_CONST;
-GType free_desktop_properties_get_type (void) G_GNUC_CONST;
-GType free_desktop_properties_proxy_get_type (void) G_GNUC_CONST;
-guint free_desktop_properties_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-GType player_controller_get_type (void) G_GNUC_CONST;
-#define MPRIS2_CONTROLLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerPrivate))
-enum  {
-	MPRIS2_CONTROLLER_DUMMY_PROPERTY,
-	MPRIS2_CONTROLLER_MPRIS2_ROOT,
-	MPRIS2_CONTROLLER_PLAYER,
-	MPRIS2_CONTROLLER_PLAYLISTS,
-	MPRIS2_CONTROLLER_PROPERTIES_INTERFACE,
-	MPRIS2_CONTROLLER_OWNER
-};
-#define MPRIS2_CONTROLLER_MAX_PLAYLIST_COUNT 100
-Mpris2Controller* mpris2_controller_new (PlayerController* ctrl);
-Mpris2Controller* mpris2_controller_construct (GType object_type, PlayerController* ctrl);
-void mpris2_controller_property_changed_cb (Mpris2Controller* self, const gchar* interface_source, GHashTable* changed_properties, gchar** invalid, int invalid_length1);
-#define MPRIS_PREFIX "org.mpris.MediaPlayer2."
-MprisPlayer* mpris2_controller_get_player (Mpris2Controller* self);
-gchar* mpris_player_get_PlaybackStatus (MprisPlayer* self);
-static gboolean mpris2_controller_ensure_correct_playback_status (Mpris2Controller* self);
-static gboolean _mpris2_controller_ensure_correct_playback_status_gsource_func (gpointer self);
-static TransportState mpris2_controller_determine_play_state (Mpris2Controller* self, const gchar* status);
-PlayerController* mpris2_controller_get_owner (Mpris2Controller* self);
-GType player_item_get_type (void) G_GNUC_CONST;
-GType player_controller_widget_order_get_type (void) G_GNUC_CONST;
-GType transport_menuitem_get_type (void) G_GNUC_CONST;
-void transport_menuitem_change_play_state (TransportMenuitem* self, TransportState update);
-static gboolean mpris2_controller_ensure_correct_metadata (Mpris2Controller* self);
-static gboolean _mpris2_controller_ensure_correct_metadata_gsource_func (gpointer self);
-static gboolean _bool_equal (const gboolean* s1, const gboolean* s2);
-static gboolean mpris2_controller_fetch_active_playlist (Mpris2Controller* self);
-static gboolean _mpris2_controller_fetch_active_playlist_gsource_func (gpointer self);
-void mpris2_controller_fetch_playlists (Mpris2Controller* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris2_controller_fetch_playlists_finish (Mpris2Controller* self, GAsyncResult* _res_);
-GType metadata_menuitem_get_type (void) G_GNUC_CONST;
-void metadata_menuitem_alter_label (MetadataMenuitem* self, const gchar* new_title);
-MprisRoot* mpris2_controller_get_mpris2_root (Mpris2Controller* self);
-gchar* mpris_root_get_Identity (MprisRoot* self);
-static GHashTable* mpris2_controller_clean_metadata (Mpris2Controller* self);
-void player_item_reset (PlayerItem* self, GeeHashSet* attrs);
-GeeHashSet* metadata_menuitem_relevant_attributes_for_ui (void);
-void player_item_update (PlayerItem* self, GHashTable* data, GeeHashSet* attributes);
-gboolean player_item_populated (PlayerItem* self, GeeHashSet* attrs);
-void metadata_menuitem_should_collapse (MetadataMenuitem* self, gboolean collapse);
-GHashTable* mpris_player_get_Metadata (MprisPlayer* self);
-static GVariant* _variant_new1 (const gchar* value);
-void mpris2_controller_initial_update (Mpris2Controller* self);
-GeeHashSet* metadata_menuitem_attributes_format (void);
-void mpris2_controller_transport_update (Mpris2Controller* self, TransportAction command);
-void mpris_player_PlayPause (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_player_PlayPause_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-void mpris_player_Previous (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_player_Previous_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-void mpris_player_Next (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_player_Next_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-void mpris_player_Seek (MprisPlayer* self, gint64 offset, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_player_Seek_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-gboolean mpris2_controller_connected (Mpris2Controller* self);
-void mpris2_controller_expose (Mpris2Controller* self);
-void mpris_root_Raise (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_root_Raise_finish (MprisRoot* self, GAsyncResult* _res_, GError** error);
-static void mpris2_controller_on_playlistdetails_changed (Mpris2Controller* self, PlaylistDetails* details);
-GType playlists_menuitem_get_type (void) G_GNUC_CONST;
-void playlists_menuitem_update_individual_playlist (PlaylistsMenuitem* self, PlaylistDetails* new_detail);
-static void mpris2_controller_fetch_playlists_data_free (gpointer _data);
-static gboolean mpris2_controller_fetch_playlists_co (Mpris2ControllerFetchPlaylistsData* _data_);
-MprisPlaylists* mpris2_controller_get_playlists (Mpris2Controller* self);
-void mpris_playlists_GetPlaylists (MprisPlaylists* self, guint32 index, guint32 max_count, const gchar* order, gboolean reverse_order, GAsyncReadyCallback _callback_, gpointer _user_data_);
-PlaylistDetails* mpris_playlists_GetPlaylists_finish (MprisPlaylists* self, GAsyncResult* _res_, int* result_length1, GError** error);
-static void mpris2_controller_fetch_playlists_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
-static void _vala_PlaylistDetails_array_free (PlaylistDetails* array, gint array_length);
-void playlists_menuitem_update (PlaylistsMenuitem* self, PlaylistDetails* playlists, int playlists_length1);
-GAppInfo* player_controller_get_app_info (PlayerController* self);
-static gboolean* _bool_dup (gboolean* self);
-static gboolean mpris2_controller_validate_playlists_details (Mpris2Controller* self);
-ActivePlaylistContainer* mpris_playlists_get_ActivePlaylist (MprisPlaylists* self);
-void playlists_menuitem_active_playlist_update (PlaylistsMenuitem* self, PlaylistDetails* detail);
-void mpris2_controller_activate_playlist (Mpris2Controller* self, const char* path);
-void mpris_playlists_ActivatePlaylist (MprisPlaylists* self, const char* playlist_id, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_playlists_ActivatePlaylist_finish (MprisPlaylists* self, GAsyncResult* _res_, GError** error);
-static void mpris2_controller_set_mpris2_root (Mpris2Controller* self, MprisRoot* value);
-static void mpris2_controller_set_player (Mpris2Controller* self, MprisPlayer* value);
-static void mpris2_controller_set_playlists (Mpris2Controller* self, MprisPlaylists* value);
-FreeDesktopProperties* mpris2_controller_get_properties_interface (Mpris2Controller* self);
-static void mpris2_controller_set_properties_interface (Mpris2Controller* self, FreeDesktopProperties* value);
-static void mpris2_controller_set_owner (Mpris2Controller* self, PlayerController* value);
-static GObject * mpris2_controller_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
-const gchar* player_controller_get_dbus_name (PlayerController* self);
-static void _mpris2_controller_property_changed_cb_free_desktop_properties_properties_changed (FreeDesktopProperties* _sender, const gchar* source, GHashTable* changed_properties, gchar** invalid, int invalid_length1, gpointer self);
-static void _mpris2_controller_on_playlistdetails_changed_mpris_playlists_playlist_changed (MprisPlaylists* _sender, PlaylistDetails* details, gpointer self);
-static void mpris2_controller_finalize (GObject* obj);
-static void _vala_mpris2_controller_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
-static void _vala_mpris2_controller_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-
-
-Mpris2Controller* mpris2_controller_construct (GType object_type, PlayerController* ctrl) {
-	Mpris2Controller * self = NULL;
-	PlayerController* _tmp0_;
-	g_return_val_if_fail (ctrl != NULL, NULL);
-	_tmp0_ = ctrl;
-	self = (Mpris2Controller*) g_object_new (object_type, "owner", _tmp0_, NULL);
-	return self;
-}
-
-
-Mpris2Controller* mpris2_controller_new (PlayerController* ctrl) {
-	return mpris2_controller_construct (TYPE_MPRIS2_CONTROLLER, ctrl);
-}
-
-
-static gpointer _g_variant_ref0 (gpointer self) {
-	return self ? g_variant_ref (self) : NULL;
-}
-
-
-static gboolean _mpris2_controller_ensure_correct_playback_status_gsource_func (gpointer self) {
-	gboolean result;
-	result = mpris2_controller_ensure_correct_playback_status (self);
-	return result;
-}
-
-
-static gboolean _mpris2_controller_ensure_correct_metadata_gsource_func (gpointer self) {
-	gboolean result;
-	result = mpris2_controller_ensure_correct_metadata (self);
-	return result;
-}
-
-
-static gboolean _bool_equal (const gboolean* s1, const gboolean* s2) {
-	if (s1 == s2) {
-		return TRUE;
-	}
-	if (s1 == NULL) {
-		return FALSE;
-	}
-	if (s2 == NULL) {
-		return FALSE;
-	}
-	return (*s1) == (*s2);
-}
-
-
-static gboolean _mpris2_controller_fetch_active_playlist_gsource_func (gpointer self) {
-	gboolean result;
-	result = mpris2_controller_fetch_active_playlist (self);
-	return result;
-}
-
-
-void mpris2_controller_property_changed_cb (Mpris2Controller* self, const gchar* interface_source, GHashTable* changed_properties, gchar** invalid, int invalid_length1) {
-	gboolean _tmp0_ = FALSE;
-	GHashTable* _tmp1_;
-	gboolean _tmp4_;
-	GHashTable* _tmp5_;
-	gconstpointer _tmp6_ = NULL;
-	GVariant* _tmp7_;
-	GVariant* play_v;
-	GVariant* _tmp8_;
-	GHashTable* _tmp19_;
-	gconstpointer _tmp20_ = NULL;
-	GVariant* _tmp21_;
-	GVariant* meta_v;
-	GVariant* _tmp22_;
-	GHashTable* _tmp23_;
-	gconstpointer _tmp24_ = NULL;
-	GVariant* _tmp25_;
-	GVariant* playlist_v;
-	gboolean _tmp26_ = FALSE;
-	GVariant* _tmp27_;
-	gboolean _tmp31_;
-	GHashTable* _tmp32_;
-	gconstpointer _tmp33_ = NULL;
-	GVariant* _tmp34_;
-	GVariant* playlist_count_v;
-	gboolean _tmp35_ = FALSE;
-	GVariant* _tmp36_;
-	gboolean _tmp40_;
-	GHashTable* _tmp41_;
-	gconstpointer _tmp42_ = NULL;
-	GVariant* _tmp43_;
-	GVariant* playlist_orderings_v;
-	gboolean _tmp44_ = FALSE;
-	GVariant* _tmp45_;
-	gboolean _tmp49_;
-	GHashTable* _tmp50_;
-	gconstpointer _tmp51_ = NULL;
-	GVariant* _tmp52_;
-	GVariant* identity_v;
-	GVariant* _tmp53_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (interface_source != NULL);
-	g_return_if_fail (changed_properties != NULL);
-	_tmp1_ = changed_properties;
-	if (_tmp1_ == NULL) {
-		_tmp0_ = TRUE;
-	} else {
-		const gchar* _tmp2_;
-		gboolean _tmp3_ = FALSE;
-		_tmp2_ = interface_source;
-		_tmp3_ = g_str_has_prefix (_tmp2_, MPRIS_PREFIX);
-		_tmp0_ = _tmp3_ == FALSE;
-	}
-	_tmp4_ = _tmp0_;
-	if (_tmp4_) {
-		g_warning ("mpris2-controller.vala:78: Property-changed hash is null or this is an" \
-" interface that doesn't concern us");
-		return;
-	}
-	_tmp5_ = changed_properties;
-	_tmp6_ = g_hash_table_lookup (_tmp5_, "PlaybackStatus");
-	_tmp7_ = _g_variant_ref0 ((GVariant*) _tmp6_);
-	play_v = _tmp7_;
-	_tmp8_ = play_v;
-	if (_tmp8_ != NULL) {
-		MprisPlayer* _tmp9_;
-		gchar* _tmp10_;
-		gchar* _tmp11_;
-		gchar* state;
-		const gchar* _tmp12_;
-		TransportState _tmp13_ = 0;
-		TransportState p;
-		PlayerController* _tmp14_;
-		GeeArrayList* _tmp15_;
-		gpointer _tmp16_ = NULL;
-		TransportMenuitem* _tmp17_;
-		TransportState _tmp18_;
-		_tmp9_ = self->priv->_player;
-		_tmp10_ = mpris_player_get_PlaybackStatus (_tmp9_);
-		_tmp11_ = _tmp10_;
-		state = _tmp11_;
-		g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 200, _mpris2_controller_ensure_correct_playback_status_gsource_func, g_object_ref (self), g_object_unref);
-		_tmp12_ = state;
-		_tmp13_ = mpris2_controller_determine_play_state (self, _tmp12_);
-		p = (TransportState) _tmp13_;
-		_tmp14_ = self->priv->_owner;
-		_tmp15_ = _tmp14_->custom_items;
-		_tmp16_ = gee_abstract_list_get ((GeeAbstractList*) _tmp15_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT);
-		_tmp17_ = IS_TRANSPORT_MENUITEM ((PlayerItem*) _tmp16_) ? ((TransportMenuitem*) ((PlayerItem*) _tmp16_)) : NULL;
-		_tmp18_ = p;
-		transport_menuitem_change_play_state (_tmp17_, _tmp18_);
-		_g_object_unref0 (_tmp17_);
-		_g_free0 (state);
-	}
-	_tmp19_ = changed_properties;
-	_tmp20_ = g_hash_table_lookup (_tmp19_, "Metadata");
-	_tmp21_ = _g_variant_ref0 ((GVariant*) _tmp20_);
-	meta_v = _tmp21_;
-	_tmp22_ = meta_v;
-	if (_tmp22_ != NULL) {
-		g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 200, _mpris2_controller_ensure_correct_metadata_gsource_func, g_object_ref (self), g_object_unref);
-	}
-	_tmp23_ = changed_properties;
-	_tmp24_ = g_hash_table_lookup (_tmp23_, "ActivePlaylist");
-	_tmp25_ = _g_variant_ref0 ((GVariant*) _tmp24_);
-	playlist_v = _tmp25_;
-	_tmp27_ = playlist_v;
-	if (_tmp27_ != NULL) {
-		PlayerController* _tmp28_;
-		gboolean* _tmp29_;
-		gboolean _tmp30_;
-		_tmp28_ = self->priv->_owner;
-		_tmp29_ = _tmp28_->use_playlists;
-		_tmp30_ = TRUE;
-		_tmp26_ = _bool_equal (_tmp29_, &_tmp30_) == TRUE;
-	} else {
-		_tmp26_ = FALSE;
-	}
-	_tmp31_ = _tmp26_;
-	if (_tmp31_) {
-		g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 500, _mpris2_controller_fetch_active_playlist_gsource_func, g_object_ref (self), g_object_unref);
-	}
-	_tmp32_ = changed_properties;
-	_tmp33_ = g_hash_table_lookup (_tmp32_, "PlaylistCount");
-	_tmp34_ = _g_variant_ref0 ((GVariant*) _tmp33_);
-	playlist_count_v = _tmp34_;
-	_tmp36_ = playlist_count_v;
-	if (_tmp36_ != NULL) {
-		PlayerController* _tmp37_;
-		gboolean* _tmp38_;
-		gboolean _tmp39_;
-		_tmp37_ = self->priv->_owner;
-		_tmp38_ = _tmp37_->use_playlists;
-		_tmp39_ = TRUE;
-		_tmp35_ = _bool_equal (_tmp38_, &_tmp39_) == TRUE;
-	} else {
-		_tmp35_ = FALSE;
-	}
-	_tmp40_ = _tmp35_;
-	if (_tmp40_) {
-		mpris2_controller_fetch_playlists (self, NULL, NULL);
-		mpris2_controller_fetch_active_playlist (self);
-	}
-	_tmp41_ = changed_properties;
-	_tmp42_ = g_hash_table_lookup (_tmp41_, "Orderings");
-	_tmp43_ = _g_variant_ref0 ((GVariant*) _tmp42_);
-	playlist_orderings_v = _tmp43_;
-	_tmp45_ = playlist_orderings_v;
-	if (_tmp45_ != NULL) {
-		PlayerController* _tmp46_;
-		gboolean* _tmp47_;
-		gboolean _tmp48_;
-		_tmp46_ = self->priv->_owner;
-		_tmp47_ = _tmp46_->use_playlists;
-		_tmp48_ = TRUE;
-		_tmp44_ = _bool_equal (_tmp47_, &_tmp48_) == TRUE;
-	} else {
-		_tmp44_ = FALSE;
-	}
-	_tmp49_ = _tmp44_;
-	if (_tmp49_) {
-		mpris2_controller_fetch_playlists (self, NULL, NULL);
-		mpris2_controller_fetch_active_playlist (self);
-	}
-	_tmp50_ = changed_properties;
-	_tmp51_ = g_hash_table_lookup (_tmp50_, "Identity");
-	_tmp52_ = _g_variant_ref0 ((GVariant*) _tmp51_);
-	identity_v = _tmp52_;
-	_tmp53_ = identity_v;
-	if (_tmp53_ != NULL) {
-		PlayerController* _tmp54_;
-		GeeArrayList* _tmp55_;
-		gpointer _tmp56_ = NULL;
-		MetadataMenuitem* md;
-		MetadataMenuitem* _tmp57_;
-		MprisRoot* _tmp58_;
-		gchar* _tmp59_;
-		gchar* _tmp60_;
-		gchar* _tmp61_;
-		_tmp54_ = self->priv->_owner;
-		_tmp55_ = _tmp54_->custom_items;
-		_tmp56_ = gee_abstract_list_get ((GeeAbstractList*) _tmp55_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA);
-		md = IS_METADATA_MENUITEM ((PlayerItem*) _tmp56_) ? ((MetadataMenuitem*) ((PlayerItem*) _tmp56_)) : NULL;
-		_tmp57_ = md;
-		_tmp58_ = self->priv->_mpris2_root;
-		_tmp59_ = mpris_root_get_Identity (_tmp58_);
-		_tmp60_ = _tmp59_;
-		_tmp61_ = _tmp60_;
-		metadata_menuitem_alter_label (_tmp57_, _tmp61_);
-		_g_free0 (_tmp61_);
-		_g_object_unref0 (md);
-	}
-	_g_variant_unref0 (identity_v);
-	_g_variant_unref0 (playlist_orderings_v);
-	_g_variant_unref0 (playlist_count_v);
-	_g_variant_unref0 (playlist_v);
-	_g_variant_unref0 (meta_v);
-	_g_variant_unref0 (play_v);
-}
-
-
-static gboolean mpris2_controller_ensure_correct_metadata (Mpris2Controller* self) {
-	gboolean result = FALSE;
-	GHashTable* _tmp0_ = NULL;
-	GHashTable* changed_updates;
-	PlayerController* _tmp1_;
-	GeeArrayList* _tmp2_;
-	gpointer _tmp3_ = NULL;
-	PlayerItem* metadata;
-	GeeHashSet* _tmp4_ = NULL;
-	GeeHashSet* _tmp5_;
-	GeeHashSet* _tmp6_ = NULL;
-	GeeHashSet* _tmp7_;
-	PlayerController* _tmp8_;
-	GeeArrayList* _tmp9_;
-	gpointer _tmp10_ = NULL;
-	MetadataMenuitem* md;
-	GeeHashSet* _tmp11_ = NULL;
-	GeeHashSet* _tmp12_;
-	gboolean _tmp13_ = FALSE;
-	gboolean _tmp14_;
-	gboolean collapsing;
-	g_return_val_if_fail (self != NULL, FALSE);
-	_tmp0_ = mpris2_controller_clean_metadata (self);
-	changed_updates = _tmp0_;
-	_tmp1_ = self->priv->_owner;
-	_tmp2_ = _tmp1_->custom_items;
-	_tmp3_ = gee_abstract_list_get ((GeeAbstractList*) _tmp2_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA);
-	metadata = (PlayerItem*) _tmp3_;
-	_tmp4_ = metadata_menuitem_relevant_attributes_for_ui ();
-	_tmp5_ = _tmp4_;
-	player_item_reset (metadata, _tmp5_);
-	_g_object_unref0 (_tmp5_);
-	_tmp6_ = metadata_menuitem_relevant_attributes_for_ui ();
-	_tmp7_ = _tmp6_;
-	player_item_update (metadata, changed_updates, _tmp7_);
-	_g_object_unref0 (_tmp7_);
-	_tmp8_ = self->priv->_owner;
-	_tmp9_ = _tmp8_->custom_items;
-	_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp9_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA);
-	md = IS_METADATA_MENUITEM ((PlayerItem*) _tmp10_) ? ((MetadataMenuitem*) ((PlayerItem*) _tmp10_)) : NULL;
-	_tmp11_ = metadata_menuitem_relevant_attributes_for_ui ();
-	_tmp12_ = _tmp11_;
-	_tmp13_ = player_item_populated (metadata, _tmp12_);
-	_tmp14_ = !_tmp13_;
-	_g_object_unref0 (_tmp12_);
-	collapsing = _tmp14_;
-	metadata_menuitem_should_collapse (md, collapsing);
-	result = FALSE;
-	_g_object_unref0 (md);
-	_g_object_unref0 (metadata);
-	_g_hash_table_unref0 (changed_updates);
-	return result;
-}
-
-
-static gboolean mpris2_controller_ensure_correct_playback_status (Mpris2Controller* self) {
-	gboolean result = FALSE;
-	MprisPlayer* _tmp0_;
-	gchar* _tmp1_;
-	gchar* _tmp2_;
-	gchar* _tmp3_;
-	TransportState _tmp4_ = 0;
-	TransportState _tmp5_;
-	TransportState p;
-	PlayerController* _tmp6_;
-	GeeArrayList* _tmp7_;
-	gpointer _tmp8_ = NULL;
-	TransportMenuitem* _tmp9_;
-	g_return_val_if_fail (self != NULL, FALSE);
-	_tmp0_ = self->priv->_player;
-	_tmp1_ = mpris_player_get_PlaybackStatus (_tmp0_);
-	_tmp2_ = _tmp1_;
-	_tmp3_ = _tmp2_;
-	_tmp4_ = mpris2_controller_determine_play_state (self, _tmp3_);
-	_tmp5_ = (TransportState) _tmp4_;
-	_g_free0 (_tmp3_);
-	p = _tmp5_;
-	_tmp6_ = self->priv->_owner;
-	_tmp7_ = _tmp6_->custom_items;
-	_tmp8_ = gee_abstract_list_get ((GeeAbstractList*) _tmp7_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT);
-	_tmp9_ = IS_TRANSPORT_MENUITEM ((PlayerItem*) _tmp8_) ? ((TransportMenuitem*) ((PlayerItem*) _tmp8_)) : NULL;
-	transport_menuitem_change_play_state (_tmp9_, p);
-	_g_object_unref0 (_tmp9_);
-	result = FALSE;
-	return result;
-}
-
-
-static GVariant* _variant_new1 (const gchar* value) {
-	return g_variant_ref_sink (g_variant_new_string (value));
-}
-
-
-static GHashTable* mpris2_controller_clean_metadata (Mpris2Controller* self) {
-	GHashTable* result = NULL;
-	MprisPlayer* _tmp0_;
-	GHashTable* _tmp1_;
-	GHashTable* _tmp2_;
-	GHashTable* changed_updates;
-	MprisPlayer* _tmp3_;
-	GHashTable* _tmp4_;
-	GHashTable* _tmp5_;
-	GHashTable* _tmp6_;
-	gconstpointer _tmp7_ = NULL;
-	GVariant* _tmp8_;
-	GVariant* _tmp9_;
-	GVariant* artist_v;
-	GVariant* _tmp10_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = self->priv->_player;
-	_tmp1_ = mpris_player_get_Metadata (_tmp0_);
-	_tmp2_ = _tmp1_;
-	changed_updates = _tmp2_;
-	_tmp3_ = self->priv->_player;
-	_tmp4_ = mpris_player_get_Metadata (_tmp3_);
-	_tmp5_ = _tmp4_;
-	_tmp6_ = _tmp5_;
-	_tmp7_ = g_hash_table_lookup (_tmp6_, "xesam:artist");
-	_tmp8_ = _g_variant_ref0 ((GVariant*) _tmp7_);
-	_tmp9_ = _tmp8_;
-	_g_hash_table_unref0 (_tmp6_);
-	artist_v = _tmp9_;
-	_tmp10_ = artist_v;
-	if (_tmp10_ != NULL) {
-		gchar* display_artists = NULL;
-		GVariant* _tmp11_;
-		const gchar* _tmp12_ = NULL;
-		GHashTable* _tmp21_;
-		gchar* _tmp22_;
-		const gchar* _tmp23_;
-		GVariant* _tmp24_;
-		_tmp11_ = artist_v;
-		_tmp12_ = g_variant_get_type_string (_tmp11_);
-		if (g_strcmp0 (_tmp12_, "s") == 0) {
-			GVariant* _tmp13_;
-			const gchar* _tmp14_ = NULL;
-			gchar* _tmp15_;
-			_tmp13_ = artist_v;
-			_tmp14_ = g_variant_get_string (_tmp13_, NULL);
-			_tmp15_ = g_strdup (_tmp14_);
-			_g_free0 (display_artists);
-			display_artists = _tmp15_;
-		} else {
-			GVariant* _tmp16_;
-			size_t _tmp17_;
-			gchar** _tmp18_ = NULL;
-			gchar** artists;
-			gint artists_length1;
-			gint _artists_size_;
-			gchar** _tmp19_;
-			gint _tmp19__length1;
-			gchar* _tmp20_ = NULL;
-			_tmp16_ = artist_v;
-			_tmp18_ = g_variant_dup_strv (_tmp16_, &_tmp17_);
-			artists = _tmp18_;
-			artists_length1 = _tmp17_;
-			_artists_size_ = artists_length1;
-			_tmp19_ = artists;
-			_tmp19__length1 = artists_length1;
-			_tmp20_ = g_strjoinv (", ", _tmp19_);
-			_g_free0 (display_artists);
-			display_artists = _tmp20_;
-			artists = (_vala_array_free (artists, artists_length1, (GDestroyNotify) g_free), NULL);
-		}
-		_tmp21_ = changed_updates;
-		_tmp22_ = g_strdup ("xesam:artist");
-		_tmp23_ = display_artists;
-		_tmp24_ = _variant_new1 (_tmp23_);
-		g_hash_table_replace (_tmp21_, _tmp22_, _tmp24_);
-		_g_free0 (display_artists);
-	}
-	result = changed_updates;
-	_g_variant_unref0 (artist_v);
-	return result;
-}
-
-
-static TransportState mpris2_controller_determine_play_state (Mpris2Controller* self, const gchar* status) {
-	TransportState result = 0;
-	gboolean _tmp0_ = FALSE;
-	const gchar* _tmp1_;
-	gboolean _tmp3_;
-	g_return_val_if_fail (self != NULL, 0);
-	_tmp1_ = status;
-	if (_tmp1_ != NULL) {
-		const gchar* _tmp2_;
-		_tmp2_ = status;
-		_tmp0_ = g_strcmp0 (_tmp2_, "Playing") == 0;
-	} else {
-		_tmp0_ = FALSE;
-	}
-	_tmp3_ = _tmp0_;
-	if (_tmp3_) {
-		result = TRANSPORT_STATE_PLAYING;
-		return result;
-	}
-	result = TRANSPORT_STATE_PAUSED;
-	return result;
-}
-
-
-void mpris2_controller_initial_update (Mpris2Controller* self) {
-	TransportState update = 0;
-	MprisPlayer* _tmp0_;
-	gchar* _tmp1_;
-	gchar* _tmp2_;
-	gchar* _tmp3_;
-	gboolean _tmp4_;
-	MprisRoot* _tmp10_;
-	gchar* _tmp11_;
-	gchar* _tmp12_;
-	gchar* _tmp13_;
-	gboolean _tmp14_;
-	PlayerController* _tmp23_;
-	GeeArrayList* _tmp24_;
-	gpointer _tmp25_ = NULL;
-	TransportMenuitem* _tmp26_;
-	TransportState _tmp27_;
-	GHashTable* _tmp28_ = NULL;
-	GHashTable* cleaned_metadata;
-	PlayerController* _tmp29_;
-	GeeArrayList* _tmp30_;
-	gpointer _tmp31_ = NULL;
-	PlayerItem* _tmp32_;
-	GHashTable* _tmp33_;
-	GeeHashSet* _tmp34_ = NULL;
-	GeeHashSet* _tmp35_;
-	PlayerController* _tmp36_;
-	gboolean* _tmp37_;
-	gboolean _tmp38_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = self->priv->_player;
-	_tmp1_ = mpris_player_get_PlaybackStatus (_tmp0_);
-	_tmp2_ = _tmp1_;
-	_tmp3_ = _tmp2_;
-	_tmp4_ = _tmp3_ == NULL;
-	_g_free0 (_tmp3_);
-	if (_tmp4_) {
-		update = TRANSPORT_STATE_PAUSED;
-	} else {
-		MprisPlayer* _tmp5_;
-		gchar* _tmp6_;
-		gchar* _tmp7_;
-		gchar* _tmp8_;
-		TransportState _tmp9_ = 0;
-		_tmp5_ = self->priv->_player;
-		_tmp6_ = mpris_player_get_PlaybackStatus (_tmp5_);
-		_tmp7_ = _tmp6_;
-		_tmp8_ = _tmp7_;
-		_tmp9_ = mpris2_controller_determine_play_state (self, _tmp8_);
-		update = _tmp9_;
-		_g_free0 (_tmp8_);
-	}
-	_tmp10_ = self->priv->_mpris2_root;
-	_tmp11_ = mpris_root_get_Identity (_tmp10_);
-	_tmp12_ = _tmp11_;
-	_tmp13_ = _tmp12_;
-	_tmp14_ = _tmp13_ != NULL;
-	_g_free0 (_tmp13_);
-	if (_tmp14_) {
-		PlayerController* _tmp15_;
-		GeeArrayList* _tmp16_;
-		gpointer _tmp17_ = NULL;
-		MetadataMenuitem* md;
-		MetadataMenuitem* _tmp18_;
-		MprisRoot* _tmp19_;
-		gchar* _tmp20_;
-		gchar* _tmp21_;
-		gchar* _tmp22_;
-		_tmp15_ = self->priv->_owner;
-		_tmp16_ = _tmp15_->custom_items;
-		_tmp17_ = gee_abstract_list_get ((GeeAbstractList*) _tmp16_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA);
-		md = IS_METADATA_MENUITEM ((PlayerItem*) _tmp17_) ? ((MetadataMenuitem*) ((PlayerItem*) _tmp17_)) : NULL;
-		_tmp18_ = md;
-		_tmp19_ = self->priv->_mpris2_root;
-		_tmp20_ = mpris_root_get_Identity (_tmp19_);
-		_tmp21_ = _tmp20_;
-		_tmp22_ = _tmp21_;
-		metadata_menuitem_alter_label (_tmp18_, _tmp22_);
-		_g_free0 (_tmp22_);
-		_g_object_unref0 (md);
-	}
-	_tmp23_ = self->priv->_owner;
-	_tmp24_ = _tmp23_->custom_items;
-	_tmp25_ = gee_abstract_list_get ((GeeAbstractList*) _tmp24_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT);
-	_tmp26_ = IS_TRANSPORT_MENUITEM ((PlayerItem*) _tmp25_) ? ((TransportMenuitem*) ((PlayerItem*) _tmp25_)) : NULL;
-	_tmp27_ = update;
-	transport_menuitem_change_play_state (_tmp26_, _tmp27_);
-	_g_object_unref0 (_tmp26_);
-	_tmp28_ = mpris2_controller_clean_metadata (self);
-	cleaned_metadata = _tmp28_;
-	_tmp29_ = self->priv->_owner;
-	_tmp30_ = _tmp29_->custom_items;
-	_tmp31_ = gee_abstract_list_get ((GeeAbstractList*) _tmp30_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA);
-	_tmp32_ = (PlayerItem*) _tmp31_;
-	_tmp33_ = cleaned_metadata;
-	_tmp34_ = metadata_menuitem_attributes_format ();
-	_tmp35_ = _tmp34_;
-	player_item_update (_tmp32_, _tmp33_, _tmp35_);
-	_g_object_unref0 (_tmp35_);
-	_g_object_unref0 (_tmp32_);
-	_tmp36_ = self->priv->_owner;
-	_tmp37_ = _tmp36_->use_playlists;
-	_tmp38_ = TRUE;
-	if (_bool_equal (_tmp37_, &_tmp38_) == TRUE) {
-		mpris2_controller_fetch_playlists (self, NULL, NULL);
-		mpris2_controller_fetch_active_playlist (self);
-	}
-	_g_hash_table_unref0 (cleaned_metadata);
-}
-
-
-void mpris2_controller_transport_update (Mpris2Controller* self, TransportAction command) {
-	TransportAction _tmp0_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = command;
-	if (_tmp0_ == TRANSPORT_ACTION_PLAY_PAUSE) {
-		MprisPlayer* _tmp1_;
-		_tmp1_ = self->priv->_player;
-		mpris_player_PlayPause (_tmp1_, NULL, NULL);
-	} else {
-		TransportAction _tmp2_;
-		_tmp2_ = command;
-		if (_tmp2_ == TRANSPORT_ACTION_PREVIOUS) {
-			MprisPlayer* _tmp3_;
-			_tmp3_ = self->priv->_player;
-			mpris_player_Previous (_tmp3_, NULL, NULL);
-		} else {
-			TransportAction _tmp4_;
-			_tmp4_ = command;
-			if (_tmp4_ == TRANSPORT_ACTION_NEXT) {
-				MprisPlayer* _tmp5_;
-				_tmp5_ = self->priv->_player;
-				mpris_player_Next (_tmp5_, NULL, NULL);
-			} else {
-				TransportAction _tmp6_;
-				_tmp6_ = command;
-				if (_tmp6_ == TRANSPORT_ACTION_REWIND) {
-					MprisPlayer* _tmp7_;
-					_tmp7_ = self->priv->_player;
-					mpris_player_Seek (_tmp7_, (gint64) (-500000), NULL, NULL);
-				} else {
-					TransportAction _tmp8_;
-					_tmp8_ = command;
-					if (_tmp8_ == TRANSPORT_ACTION_FORWIND) {
-						MprisPlayer* _tmp9_;
-						_tmp9_ = self->priv->_player;
-						mpris_player_Seek (_tmp9_, (gint64) 400000, NULL, NULL);
-					}
-				}
-			}
-		}
-	}
-}
-
-
-gboolean mpris2_controller_connected (Mpris2Controller* self) {
-	gboolean result = FALSE;
-	gboolean _tmp0_ = FALSE;
-	MprisPlayer* _tmp1_;
-	gboolean _tmp3_;
-	g_return_val_if_fail (self != NULL, FALSE);
-	_tmp1_ = self->priv->_player;
-	if (_tmp1_ != NULL) {
-		MprisRoot* _tmp2_;
-		_tmp2_ = self->priv->_mpris2_root;
-		_tmp0_ = _tmp2_ != NULL;
-	} else {
-		_tmp0_ = FALSE;
-	}
-	_tmp3_ = _tmp0_;
-	result = _tmp3_;
-	return result;
-}
-
-
-void mpris2_controller_expose (Mpris2Controller* self) {
-	gboolean _tmp0_ = FALSE;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = mpris2_controller_connected (self);
-	if (_tmp0_ == TRUE) {
-		MprisRoot* _tmp1_;
-		_tmp1_ = self->priv->_mpris2_root;
-		mpris_root_Raise (_tmp1_, NULL, NULL);
-	}
-}
-
-
-static void mpris2_controller_on_playlistdetails_changed (Mpris2Controller* self, PlaylistDetails* details) {
-	PlayerController* _tmp0_;
-	GeeArrayList* _tmp1_;
-	gpointer _tmp2_ = NULL;
-	PlaylistsMenuitem* playlists_item;
-	PlaylistDetails _tmp3_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (details != NULL);
-	_tmp0_ = self->priv->_owner;
-	_tmp1_ = _tmp0_->custom_items;
-	_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _tmp1_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_PLAYLISTS);
-	playlists_item = IS_PLAYLISTS_MENUITEM ((PlayerItem*) _tmp2_) ? ((PlaylistsMenuitem*) ((PlayerItem*) _tmp2_)) : NULL;
-	_tmp3_ = *details;
-	playlists_menuitem_update_individual_playlist (playlists_item, &_tmp3_);
-	_g_object_unref0 (playlists_item);
-}
-
-
-static void mpris2_controller_fetch_playlists_data_free (gpointer _data) {
-	Mpris2ControllerFetchPlaylistsData* _data_;
-	_data_ = _data;
-	_g_object_unref0 (_data_->self);
-	g_slice_free (Mpris2ControllerFetchPlaylistsData, _data_);
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-void mpris2_controller_fetch_playlists (Mpris2Controller* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	Mpris2ControllerFetchPlaylistsData* _data_;
-	Mpris2Controller* _tmp0_;
-	_data_ = g_slice_new0 (Mpris2ControllerFetchPlaylistsData);
-	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, mpris2_controller_fetch_playlists);
-	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, mpris2_controller_fetch_playlists_data_free);
-	_tmp0_ = _g_object_ref0 (self);
-	_data_->self = _tmp0_;
-	mpris2_controller_fetch_playlists_co (_data_);
-}
-
-
-void mpris2_controller_fetch_playlists_finish (Mpris2Controller* self, GAsyncResult* _res_) {
-	Mpris2ControllerFetchPlaylistsData* _data_;
-	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
-}
-
-
-static void mpris2_controller_fetch_playlists_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
-	Mpris2ControllerFetchPlaylistsData* _data_;
-	_data_ = _user_data_;
-	_data_->_source_object_ = source_object;
-	_data_->_res_ = _res_;
-	mpris2_controller_fetch_playlists_co (_data_);
-}
-
-
-static void _vala_PlaylistDetails_array_free (PlaylistDetails* array, gint array_length) {
-	if (array != NULL) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			playlist_details_destroy (&array[i]);
-		}
-	}
-	g_free (array);
-}
-
-
-static gboolean* _bool_dup (gboolean* self) {
-	gboolean* dup;
-	dup = g_new0 (gboolean, 1);
-	memcpy (dup, self, sizeof (gboolean));
-	return dup;
-}
-
-
-static gpointer __bool_dup0 (gpointer self) {
-	return self ? _bool_dup (self) : NULL;
-}
-
-
-static gboolean mpris2_controller_fetch_playlists_co (Mpris2ControllerFetchPlaylistsData* _data_) {
-	switch (_data_->_state_) {
-		case 0:
-		goto _state_0;
-		case 1:
-		goto _state_1;
-		default:
-		g_assert_not_reached ();
-	}
-	_state_0:
-	_data_->current_playlists = NULL;
-	_data_->current_playlists_length1 = 0;
-	_data_->_current_playlists_size_ = _data_->current_playlists_length1;
-	{
-		_data_->_tmp0_ = _data_->self->priv->_playlists;
-		_data_->_tmp1_ = 0;
-		_data_->_state_ = 1;
-		mpris_playlists_GetPlaylists (_data_->_tmp0_, (guint32) 0, (guint32) MPRIS2_CONTROLLER_MAX_PLAYLIST_COUNT, "Alphabetical", FALSE, mpris2_controller_fetch_playlists_ready, _data_);
-		return FALSE;
-		_state_1:
-		_data_->_tmp2_ = NULL;
-		_data_->_tmp2_ = mpris_playlists_GetPlaylists_finish (_data_->_tmp0_, _data_->_res_, &_data_->_tmp1_, &_data_->_inner_error_);
-		_data_->_tmp3_ = _data_->_tmp2_;
-		_data_->_tmp3__length1 = _data_->_tmp1_;
-		_data_->__tmp3__size_ = _data_->_tmp3__length1;
-		if (_data_->_inner_error_ != NULL) {
-			if (_data_->_inner_error_->domain == G_IO_ERROR) {
-				goto __catch12_g_io_error;
-			}
-			_data_->current_playlists = (_vala_PlaylistDetails_array_free (_data_->current_playlists, _data_->current_playlists_length1), NULL);
-			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
-			g_clear_error (&_data_->_inner_error_);
-			return FALSE;
-		}
-		_data_->current_playlists = (_vala_PlaylistDetails_array_free (_data_->current_playlists, _data_->current_playlists_length1), NULL);
-		_data_->current_playlists = _data_->_tmp3_;
-		_data_->current_playlists_length1 = _data_->_tmp3__length1;
-		_data_->_current_playlists_size_ = _data_->current_playlists_length1;
-	}
-	goto __finally12;
-	__catch12_g_io_error:
-	{
-		_data_->e = _data_->_inner_error_;
-		_data_->_inner_error_ = NULL;
-		_g_error_free0 (_data_->e);
-		_data_->current_playlists = (_vala_PlaylistDetails_array_free (_data_->current_playlists, _data_->current_playlists_length1), NULL);
-		if (_data_->_state_ == 0) {
-			g_simple_async_result_complete_in_idle (_data_->_async_result);
-		} else {
-			g_simple_async_result_complete (_data_->_async_result);
-		}
-		g_object_unref (_data_->_async_result);
-		return FALSE;
-	}
-	__finally12:
-	if (_data_->_inner_error_ != NULL) {
-		_data_->current_playlists = (_vala_PlaylistDetails_array_free (_data_->current_playlists, _data_->current_playlists_length1), NULL);
-		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
-		g_clear_error (&_data_->_inner_error_);
-		return FALSE;
-	}
-	_data_->_tmp4_ = _data_->current_playlists;
-	_data_->_tmp4__length1 = _data_->current_playlists_length1;
-	if (_data_->_tmp4_ != NULL) {
-		_data_->_tmp5_ = _data_->self->priv->_owner;
-		_data_->_tmp6_ = _data_->_tmp5_->custom_items;
-		_data_->_tmp7_ = NULL;
-		_data_->_tmp7_ = gee_abstract_list_get ((GeeAbstractList*) _data_->_tmp6_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_PLAYLISTS);
-		_data_->playlists_item = IS_PLAYLISTS_MENUITEM ((PlayerItem*) _data_->_tmp7_) ? ((PlaylistsMenuitem*) ((PlayerItem*) _data_->_tmp7_)) : NULL;
-		_data_->_tmp8_ = _data_->playlists_item;
-		_data_->_tmp9_ = _data_->current_playlists;
-		_data_->_tmp9__length1 = _data_->current_playlists_length1;
-		playlists_menuitem_update (_data_->_tmp8_, _data_->_tmp9_, _data_->_tmp9__length1);
-		_g_object_unref0 (_data_->playlists_item);
-	} else {
-		_data_->_tmp10_ = _data_->self->priv->_owner;
-		_data_->_tmp11_ = player_controller_get_app_info (_data_->_tmp10_);
-		_data_->_tmp12_ = _data_->_tmp11_;
-		_data_->_tmp13_ = NULL;
-		_data_->_tmp13_ = g_app_info_get_name (_data_->_tmp12_);
-		g_warning ("mpris2-controller.vala:243:  Playlists are on but %s is returning no c" \
-"urrent_playlists ?", _data_->_tmp13_);
-		_data_->_tmp14_ = _data_->self->priv->_owner;
-		_data_->_tmp15_ = FALSE;
-		_data_->_tmp16_ = __bool_dup0 (&_data_->_tmp15_);
-		_g_free0 (_data_->_tmp14_->use_playlists);
-		_data_->_tmp14_->use_playlists = _data_->_tmp16_;
-	}
-	_data_->current_playlists = (_vala_PlaylistDetails_array_free (_data_->current_playlists, _data_->current_playlists_length1), NULL);
-	if (_data_->_state_ == 0) {
-		g_simple_async_result_complete_in_idle (_data_->_async_result);
-	} else {
-		g_simple_async_result_complete (_data_->_async_result);
-	}
-	g_object_unref (_data_->_async_result);
-	return FALSE;
-}
-
-
-static gboolean mpris2_controller_validate_playlists_details (Mpris2Controller* self) {
-	gboolean result = FALSE;
-	MprisPlaylists* _tmp0_;
-	ActivePlaylistContainer* _tmp1_;
-	ActivePlaylistContainer* _tmp2_;
-	ActivePlaylistContainer* _tmp3_;
-	gboolean _tmp4_;
-	MprisPlaylists* _tmp5_;
-	ActivePlaylistContainer* _tmp6_;
-	ActivePlaylistContainer* _tmp7_;
-	ActivePlaylistContainer* _tmp8_;
-	gboolean _tmp9_;
-	gboolean _tmp10_;
-	MprisPlaylists* _tmp11_;
-	ActivePlaylistContainer* _tmp12_;
-	ActivePlaylistContainer* _tmp13_;
-	ActivePlaylistContainer* _tmp14_;
-	PlaylistDetails* _tmp15_;
-	gboolean _tmp16_;
-	gboolean _tmp17_ = FALSE;
-	MprisPlaylists* _tmp18_;
-	ActivePlaylistContainer* _tmp19_;
-	ActivePlaylistContainer* _tmp20_;
-	ActivePlaylistContainer* _tmp21_;
-	PlaylistDetails* _tmp22_;
-	const char* _tmp23_;
-	gboolean _tmp24_;
-	gboolean _tmp31_;
-	g_return_val_if_fail (self != NULL, FALSE);
-	_tmp0_ = self->priv->_playlists;
-	_tmp1_ = mpris_playlists_get_ActivePlaylist (_tmp0_);
-	_tmp2_ = _tmp1_;
-	_tmp3_ = _tmp2_;
-	_tmp4_ = _tmp3_ == NULL;
-	_active_playlist_container_free0 (_tmp3_);
-	if (_tmp4_) {
-		result = FALSE;
-		return result;
-	}
-	_tmp5_ = self->priv->_playlists;
-	_tmp6_ = mpris_playlists_get_ActivePlaylist (_tmp5_);
-	_tmp7_ = _tmp6_;
-	_tmp8_ = _tmp7_;
-	_tmp9_ = (*_tmp8_).valid;
-	_tmp10_ = _tmp9_ == FALSE;
-	_active_playlist_container_free0 (_tmp8_);
-	if (_tmp10_) {
-		result = FALSE;
-		return result;
-	}
-	_tmp11_ = self->priv->_playlists;
-	_tmp12_ = mpris_playlists_get_ActivePlaylist (_tmp11_);
-	_tmp13_ = _tmp12_;
-	_tmp14_ = _tmp13_;
-	_tmp15_ = (*_tmp14_).details;
-	_tmp16_ = _tmp15_ == NULL;
-	_active_playlist_container_free0 (_tmp14_);
-	if (_tmp16_) {
-		result = FALSE;
-		return result;
-	}
-	_tmp18_ = self->priv->_playlists;
-	_tmp19_ = mpris_playlists_get_ActivePlaylist (_tmp18_);
-	_tmp20_ = _tmp19_;
-	_tmp21_ = _tmp20_;
-	_tmp22_ = (*_tmp21_).details;
-	_tmp23_ = (*_tmp22_).path;
-	_tmp24_ = _tmp23_ == NULL;
-	_active_playlist_container_free0 (_tmp21_);
-	if (_tmp24_) {
-		_tmp17_ = TRUE;
-	} else {
-		MprisPlaylists* _tmp25_;
-		ActivePlaylistContainer* _tmp26_;
-		ActivePlaylistContainer* _tmp27_;
-		ActivePlaylistContainer* _tmp28_;
-		PlaylistDetails* _tmp29_;
-		const gchar* _tmp30_;
-		_tmp25_ = self->priv->_playlists;
-		_tmp26_ = mpris_playlists_get_ActivePlaylist (_tmp25_);
-		_tmp27_ = _tmp26_;
-		_tmp28_ = _tmp27_;
-		_tmp29_ = (*_tmp28_).details;
-		_tmp30_ = (*_tmp29_).name;
-		_tmp17_ = _tmp30_ == NULL;
-		_active_playlist_container_free0 (_tmp28_);
-	}
-	_tmp31_ = _tmp17_;
-	if (_tmp31_) {
-		result = FALSE;
-		return result;
-	}
-	result = TRUE;
-	return result;
-}
-
-
-static gboolean mpris2_controller_fetch_active_playlist (Mpris2Controller* self) {
-	gboolean result = FALSE;
-	gboolean _tmp0_ = FALSE;
-	PlayerController* _tmp1_;
-	GeeArrayList* _tmp2_;
-	gpointer _tmp3_ = NULL;
-	PlaylistsMenuitem* playlists_item;
-	PlaylistsMenuitem* _tmp4_;
-	MprisPlaylists* _tmp5_;
-	ActivePlaylistContainer* _tmp6_;
-	ActivePlaylistContainer* _tmp7_;
-	ActivePlaylistContainer* _tmp8_;
-	PlaylistDetails* _tmp9_;
-	PlaylistDetails _tmp10_;
-	g_return_val_if_fail (self != NULL, FALSE);
-	_tmp0_ = mpris2_controller_validate_playlists_details (self);
-	if (_tmp0_ == FALSE) {
-		result = FALSE;
-		return result;
-	}
-	_tmp1_ = self->priv->_owner;
-	_tmp2_ = _tmp1_->custom_items;
-	_tmp3_ = gee_abstract_list_get ((GeeAbstractList*) _tmp2_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_PLAYLISTS);
-	playlists_item = IS_PLAYLISTS_MENUITEM ((PlayerItem*) _tmp3_) ? ((PlaylistsMenuitem*) ((PlayerItem*) _tmp3_)) : NULL;
-	_tmp4_ = playlists_item;
-	_tmp5_ = self->priv->_playlists;
-	_tmp6_ = mpris_playlists_get_ActivePlaylist (_tmp5_);
-	_tmp7_ = _tmp6_;
-	_tmp8_ = _tmp7_;
-	_tmp9_ = (*_tmp8_).details;
-	_tmp10_ = *_tmp9_;
-	playlists_menuitem_active_playlist_update (_tmp4_, &_tmp10_);
-	_active_playlist_container_free0 (_tmp8_);
-	result = FALSE;
-	_g_object_unref0 (playlists_item);
-	return result;
-}
-
-
-void mpris2_controller_activate_playlist (Mpris2Controller* self, const char* path) {
-	GError * _inner_error_ = NULL;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (path != NULL);
-	{
-		MprisPlaylists* _tmp0_;
-		const char* _tmp1_;
-		_tmp0_ = self->priv->_playlists;
-		_tmp1_ = path;
-		mpris_playlists_ActivatePlaylist (_tmp0_, _tmp1_, NULL, NULL);
-	}
-	goto __finally13;
-	__catch13_g_io_error:
-	{
-		GError* e = NULL;
-		const char* _tmp2_;
-		GError* _tmp3_;
-		const gchar* _tmp4_;
-		e = _inner_error_;
-		_inner_error_ = NULL;
-		_tmp2_ = path;
-		_tmp3_ = e;
-		_tmp4_ = _tmp3_->message;
-		g_warning ("mpris2-controller.vala:283: Could not activate playlist %s because %s", (const gchar*) _tmp2_, _tmp4_);
-		_g_error_free0 (e);
-	}
-	__finally13:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-}
-
-
-MprisRoot* mpris2_controller_get_mpris2_root (Mpris2Controller* self) {
-	MprisRoot* result;
-	MprisRoot* _tmp0_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = self->priv->_mpris2_root;
-	result = _tmp0_;
-	return result;
-}
-
-
-static void mpris2_controller_set_mpris2_root (Mpris2Controller* self, MprisRoot* value) {
-	MprisRoot* _tmp0_;
-	MprisRoot* _tmp1_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = value;
-	_tmp1_ = _g_object_ref0 (_tmp0_);
-	_g_object_unref0 (self->priv->_mpris2_root);
-	self->priv->_mpris2_root = _tmp1_;
-	g_object_notify ((GObject *) self, "mpris2-root");
-}
-
-
-MprisPlayer* mpris2_controller_get_player (Mpris2Controller* self) {
-	MprisPlayer* result;
-	MprisPlayer* _tmp0_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = self->priv->_player;
-	result = _tmp0_;
-	return result;
-}
-
-
-static void mpris2_controller_set_player (Mpris2Controller* self, MprisPlayer* value) {
-	MprisPlayer* _tmp0_;
-	MprisPlayer* _tmp1_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = value;
-	_tmp1_ = _g_object_ref0 (_tmp0_);
-	_g_object_unref0 (self->priv->_player);
-	self->priv->_player = _tmp1_;
-	g_object_notify ((GObject *) self, "player");
-}
-
-
-MprisPlaylists* mpris2_controller_get_playlists (Mpris2Controller* self) {
-	MprisPlaylists* result;
-	MprisPlaylists* _tmp0_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = self->priv->_playlists;
-	result = _tmp0_;
-	return result;
-}
-
-
-static void mpris2_controller_set_playlists (Mpris2Controller* self, MprisPlaylists* value) {
-	MprisPlaylists* _tmp0_;
-	MprisPlaylists* _tmp1_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = value;
-	_tmp1_ = _g_object_ref0 (_tmp0_);
-	_g_object_unref0 (self->priv->_playlists);
-	self->priv->_playlists = _tmp1_;
-	g_object_notify ((GObject *) self, "playlists");
-}
-
-
-FreeDesktopProperties* mpris2_controller_get_properties_interface (Mpris2Controller* self) {
-	FreeDesktopProperties* result;
-	FreeDesktopProperties* _tmp0_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = self->priv->_properties_interface;
-	result = _tmp0_;
-	return result;
-}
-
-
-static void mpris2_controller_set_properties_interface (Mpris2Controller* self, FreeDesktopProperties* value) {
-	FreeDesktopProperties* _tmp0_;
-	FreeDesktopProperties* _tmp1_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = value;
-	_tmp1_ = _g_object_ref0 (_tmp0_);
-	_g_object_unref0 (self->priv->_properties_interface);
-	self->priv->_properties_interface = _tmp1_;
-	g_object_notify ((GObject *) self, "properties-interface");
-}
-
-
-PlayerController* mpris2_controller_get_owner (Mpris2Controller* self) {
-	PlayerController* result;
-	PlayerController* _tmp0_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = self->priv->_owner;
-	result = _tmp0_;
-	return result;
-}
-
-
-static void mpris2_controller_set_owner (Mpris2Controller* self, PlayerController* value) {
-	PlayerController* _tmp0_;
-	PlayerController* _tmp1_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = value;
-	_tmp1_ = _g_object_ref0 (_tmp0_);
-	_g_object_unref0 (self->priv->_owner);
-	self->priv->_owner = _tmp1_;
-	g_object_notify ((GObject *) self, "owner");
-}
-
-
-static void _mpris2_controller_property_changed_cb_free_desktop_properties_properties_changed (FreeDesktopProperties* _sender, const gchar* source, GHashTable* changed_properties, gchar** invalid, int invalid_length1, gpointer self) {
-	mpris2_controller_property_changed_cb (self, source, changed_properties, invalid, invalid_length1);
-}
-
-
-static void _mpris2_controller_on_playlistdetails_changed_mpris_playlists_playlist_changed (MprisPlaylists* _sender, PlaylistDetails* details, gpointer self) {
-	mpris2_controller_on_playlistdetails_changed (self, details);
-}
-
-
-static GObject * mpris2_controller_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
-	GObject * obj;
-	GObjectClass * parent_class;
-	Mpris2Controller * self;
-	GError * _inner_error_ = NULL;
-	parent_class = G_OBJECT_CLASS (mpris2_controller_parent_class);
-	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
-	self = MPRIS2_CONTROLLER (obj);
-	{
-		PlayerController* _tmp0_;
-		const gchar* _tmp1_;
-		const gchar* _tmp2_;
-		MprisRoot* _tmp3_ = NULL;
-		MprisRoot* _tmp4_;
-		MprisRoot* _tmp5_;
-		PlayerController* _tmp6_;
-		const gchar* _tmp7_;
-		const gchar* _tmp8_;
-		MprisPlayer* _tmp9_ = NULL;
-		MprisPlayer* _tmp10_;
-		MprisPlayer* _tmp11_;
-		FreeDesktopProperties* _tmp12_ = NULL;
-		FreeDesktopProperties* _tmp13_;
-		FreeDesktopProperties* _tmp14_;
-		FreeDesktopProperties* _tmp15_;
-		PlayerController* _tmp16_;
-		gboolean* _tmp17_;
-		gboolean _tmp18_;
-		_tmp0_ = self->priv->_owner;
-		_tmp1_ = player_controller_get_dbus_name (_tmp0_);
-		_tmp2_ = _tmp1_;
-		_tmp3_ = g_initable_new (TYPE_MPRIS_ROOT_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", _tmp2_, "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", "/org/mpris/MediaPlayer2", "g-interface-name", "org.mpris.MediaPlayer2", NULL);
-		_tmp4_ = (MprisRoot*) _tmp3_;
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == G_IO_ERROR) {
-				goto __catch14_g_io_error;
-			}
-			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-			g_clear_error (&_inner_error_);
-		}
-		_tmp5_ = _tmp4_;
-		mpris2_controller_set_mpris2_root (self, _tmp5_);
-		_g_object_unref0 (_tmp5_);
-		_tmp6_ = self->priv->_owner;
-		_tmp7_ = player_controller_get_dbus_name (_tmp6_);
-		_tmp8_ = _tmp7_;
-		_tmp9_ = g_initable_new (TYPE_MPRIS_PLAYER_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", _tmp8_, "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", "/org/mpris/MediaPlayer2", "g-interface-name", "org.mpris.MediaPlayer2.Player", NULL);
-		_tmp10_ = (MprisPlayer*) _tmp9_;
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == G_IO_ERROR) {
-				goto __catch14_g_io_error;
-			}
-			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-			g_clear_error (&_inner_error_);
-		}
-		_tmp11_ = _tmp10_;
-		mpris2_controller_set_player (self, _tmp11_);
-		_g_object_unref0 (_tmp11_);
-		_tmp12_ = g_initable_new (TYPE_FREE_DESKTOP_PROPERTIES_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.freedesktop.Properties.PropertiesChanged", "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", "/org/mpris/MediaPlayer2", "g-interface-name", "org.freedesktop.DBus.Properties", NULL);
-		_tmp13_ = (FreeDesktopProperties*) _tmp12_;
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == G_IO_ERROR) {
-				goto __catch14_g_io_error;
-			}
-			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-			g_clear_error (&_inner_error_);
-		}
-		_tmp14_ = _tmp13_;
-		mpris2_controller_set_properties_interface (self, _tmp14_);
-		_g_object_unref0 (_tmp14_);
-		_tmp15_ = self->priv->_properties_interface;
-		g_signal_connect_object (_tmp15_, "properties-changed", (GCallback) _mpris2_controller_property_changed_cb_free_desktop_properties_properties_changed, self, 0);
-		_tmp16_ = self->priv->_owner;
-		_tmp17_ = _tmp16_->use_playlists;
-		_tmp18_ = TRUE;
-		if (_bool_equal (_tmp17_, &_tmp18_) == TRUE) {
-			PlayerController* _tmp19_;
-			const gchar* _tmp20_;
-			const gchar* _tmp21_;
-			MprisPlaylists* _tmp22_ = NULL;
-			MprisPlaylists* _tmp23_;
-			MprisPlaylists* _tmp24_;
-			MprisPlaylists* _tmp25_;
-			_tmp19_ = self->priv->_owner;
-			_tmp20_ = player_controller_get_dbus_name (_tmp19_);
-			_tmp21_ = _tmp20_;
-			_tmp22_ = g_initable_new (TYPE_MPRIS_PLAYLISTS_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", _tmp21_, "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", "/org/mpris/MediaPlayer2", "g-interface-name", "org.mpris.MediaPlayer2.Playlists", NULL);
-			_tmp23_ = (MprisPlaylists*) _tmp22_;
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == G_IO_ERROR) {
-					goto __catch14_g_io_error;
-				}
-				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-				g_clear_error (&_inner_error_);
-			}
-			_tmp24_ = _tmp23_;
-			mpris2_controller_set_playlists (self, _tmp24_);
-			_g_object_unref0 (_tmp24_);
-			_tmp25_ = self->priv->_playlists;
-			g_signal_connect_object (_tmp25_, "playlist-changed", (GCallback) _mpris2_controller_on_playlistdetails_changed_mpris_playlists_playlist_changed, self, 0);
-		}
-	}
-	goto __finally14;
-	__catch14_g_io_error:
-	{
-		GError* e = NULL;
-		GError* _tmp26_;
-		const gchar* _tmp27_;
-		e = _inner_error_;
-		_inner_error_ = NULL;
-		_tmp26_ = e;
-		_tmp27_ = _tmp26_->message;
-		g_critical ("mpris2-controller.vala:57: Problems connecting to the session bus - %s", _tmp27_);
-		_g_error_free0 (e);
-	}
-	__finally14:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-		g_clear_error (&_inner_error_);
-	}
-	return obj;
-}
-
-
-static void mpris2_controller_class_init (Mpris2ControllerClass * klass) {
-	mpris2_controller_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (Mpris2ControllerPrivate));
-	G_OBJECT_CLASS (klass)->get_property = _vala_mpris2_controller_get_property;
-	G_OBJECT_CLASS (klass)->set_property = _vala_mpris2_controller_set_property;
-	G_OBJECT_CLASS (klass)->constructor = mpris2_controller_constructor;
-	G_OBJECT_CLASS (klass)->finalize = mpris2_controller_finalize;
-	g_object_class_install_property (G_OBJECT_CLASS (klass), MPRIS2_CONTROLLER_MPRIS2_ROOT, g_param_spec_object ("mpris2-root", "mpris2-root", "mpris2-root", TYPE_MPRIS_ROOT, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), MPRIS2_CONTROLLER_PLAYER, g_param_spec_object ("player", "player", "player", TYPE_MPRIS_PLAYER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), MPRIS2_CONTROLLER_PLAYLISTS, g_param_spec_object ("playlists", "playlists", "playlists", TYPE_MPRIS_PLAYLISTS, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), MPRIS2_CONTROLLER_PROPERTIES_INTERFACE, g_param_spec_object ("properties-interface", "properties-interface", "properties-interface", TYPE_FREE_DESKTOP_PROPERTIES, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), MPRIS2_CONTROLLER_OWNER, g_param_spec_object ("owner", "owner", "owner", TYPE_PLAYER_CONTROLLER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
-}
-
-
-static void mpris2_controller_instance_init (Mpris2Controller * self) {
-	self->priv = MPRIS2_CONTROLLER_GET_PRIVATE (self);
-}
-
-
-static void mpris2_controller_finalize (GObject* obj) {
-	Mpris2Controller * self;
-	self = MPRIS2_CONTROLLER (obj);
-	_g_object_unref0 (self->priv->_mpris2_root);
-	_g_object_unref0 (self->priv->_player);
-	_g_object_unref0 (self->priv->_playlists);
-	_g_object_unref0 (self->priv->_properties_interface);
-	_g_object_unref0 (self->priv->_owner);
-	G_OBJECT_CLASS (mpris2_controller_parent_class)->finalize (obj);
-}
-
-
-GType mpris2_controller_get_type (void) {
-	static volatile gsize mpris2_controller_type_id__volatile = 0;
-	if (g_once_init_enter (&mpris2_controller_type_id__volatile)) {
-		static const GTypeInfo g_define_type_info = { sizeof (Mpris2ControllerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) mpris2_controller_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Mpris2Controller), 0, (GInstanceInitFunc) mpris2_controller_instance_init, NULL };
-		GType mpris2_controller_type_id;
-		mpris2_controller_type_id = g_type_register_static (G_TYPE_OBJECT, "Mpris2Controller", &g_define_type_info, 0);
-		g_once_init_leave (&mpris2_controller_type_id__volatile, mpris2_controller_type_id);
-	}
-	return mpris2_controller_type_id__volatile;
-}
-
-
-static void _vala_mpris2_controller_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
-	Mpris2Controller * self;
-	self = MPRIS2_CONTROLLER (object);
-	switch (property_id) {
-		case MPRIS2_CONTROLLER_MPRIS2_ROOT:
-		g_value_set_object (value, mpris2_controller_get_mpris2_root (self));
-		break;
-		case MPRIS2_CONTROLLER_PLAYER:
-		g_value_set_object (value, mpris2_controller_get_player (self));
-		break;
-		case MPRIS2_CONTROLLER_PLAYLISTS:
-		g_value_set_object (value, mpris2_controller_get_playlists (self));
-		break;
-		case MPRIS2_CONTROLLER_PROPERTIES_INTERFACE:
-		g_value_set_object (value, mpris2_controller_get_properties_interface (self));
-		break;
-		case MPRIS2_CONTROLLER_OWNER:
-		g_value_set_object (value, mpris2_controller_get_owner (self));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void _vala_mpris2_controller_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
-	Mpris2Controller * self;
-	self = MPRIS2_CONTROLLER (object);
-	switch (property_id) {
-		case MPRIS2_CONTROLLER_MPRIS2_ROOT:
-		mpris2_controller_set_mpris2_root (self, g_value_get_object (value));
-		break;
-		case MPRIS2_CONTROLLER_PLAYER:
-		mpris2_controller_set_player (self, g_value_get_object (value));
-		break;
-		case MPRIS2_CONTROLLER_PLAYLISTS:
-		mpris2_controller_set_playlists (self, g_value_get_object (value));
-		break;
-		case MPRIS2_CONTROLLER_PROPERTIES_INTERFACE:
-		mpris2_controller_set_properties_interface (self, g_value_get_object (value));
-		break;
-		case MPRIS2_CONTROLLER_OWNER:
-		mpris2_controller_set_owner (self, g_value_get_object (value));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-
diff -Naur indicator-sound-0.8.5.0/src/mpris2-interfaces.c indicator-sound-precise/src/mpris2-interfaces.c
--- indicator-sound-0.8.5.0/src/mpris2-interfaces.c	2012-03-30 10:32:34.000000000 -0700
+++ indicator-sound-precise/src/mpris2-interfaces.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,2655 +0,0 @@
-/* mpris2-interfaces.c generated by valac 0.14.2, the Vala compiler
- * generated from mpris2-interfaces.vala, do not modify */
-
-/*
-Copyright 2010 Canonical Ltd.
-Authors:
-    Conor Curran <conor.curran@canonical.com>
-
-This program is free software: you can redistribute it and/or modify it 
-under the terms of the GNU General Public License version 3, as published 
-by the Free Software Foundation.
-
-This program is distributed in the hope that it will be useful, but 
-WITHOUT ANY WARRANTY; without even the implied warranties of 
-MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
-PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along 
-with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gio/gio.h>
-
-
-#define TYPE_MPRIS_ROOT (mpris_root_get_type ())
-#define MPRIS_ROOT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_ROOT, MprisRoot))
-#define IS_MPRIS_ROOT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_ROOT))
-#define MPRIS_ROOT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MPRIS_ROOT, MprisRootIface))
-
-typedef struct _MprisRoot MprisRoot;
-typedef struct _MprisRootIface MprisRootIface;
-
-#define TYPE_MPRIS_ROOT_PROXY (mpris_root_proxy_get_type ())
-typedef GDBusProxy MprisRootProxy;
-typedef GDBusProxyClass MprisRootProxyClass;
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-#define TYPE_MPRIS_PLAYER (mpris_player_get_type ())
-#define MPRIS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_PLAYER, MprisPlayer))
-#define IS_MPRIS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_PLAYER))
-#define MPRIS_PLAYER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MPRIS_PLAYER, MprisPlayerIface))
-
-typedef struct _MprisPlayer MprisPlayer;
-typedef struct _MprisPlayerIface MprisPlayerIface;
-
-#define TYPE_MPRIS_PLAYER_PROXY (mpris_player_proxy_get_type ())
-typedef GDBusProxy MprisPlayerProxy;
-typedef GDBusProxyClass MprisPlayerProxyClass;
-#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
-
-#define TYPE_PLAYLIST_DETAILS (playlist_details_get_type ())
-typedef struct _PlaylistDetails PlaylistDetails;
-
-#define TYPE_ACTIVE_PLAYLIST_CONTAINER (active_playlist_container_get_type ())
-typedef struct _ActivePlaylistContainer ActivePlaylistContainer;
-#define _playlist_details_free0(var) ((var == NULL) ? NULL : (var = (playlist_details_free (var), NULL)))
-
-#define TYPE_MPRIS_PLAYLISTS (mpris_playlists_get_type ())
-#define MPRIS_PLAYLISTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_PLAYLISTS, MprisPlaylists))
-#define IS_MPRIS_PLAYLISTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_PLAYLISTS))
-#define MPRIS_PLAYLISTS_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MPRIS_PLAYLISTS, MprisPlaylistsIface))
-
-typedef struct _MprisPlaylists MprisPlaylists;
-typedef struct _MprisPlaylistsIface MprisPlaylistsIface;
-
-#define TYPE_MPRIS_PLAYLISTS_PROXY (mpris_playlists_proxy_get_type ())
-typedef GDBusProxy MprisPlaylistsProxy;
-typedef GDBusProxyClass MprisPlaylistsProxyClass;
-#define _active_playlist_container_free0(var) ((var == NULL) ? NULL : (var = (active_playlist_container_free (var), NULL)))
-
-struct _MprisRootIface {
-	GTypeInterface parent_iface;
-	void (*Quit) (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*Quit_finish) (MprisRoot* self, GAsyncResult* _res_, GError** error);
-	void (*Raise) (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*Raise_finish) (MprisRoot* self, GAsyncResult* _res_, GError** error);
-	gboolean (*get_HasTracklist) (MprisRoot* self);
-	void (*set_HasTracklist) (MprisRoot* self, gboolean value);
-	gboolean (*get_CanQuit) (MprisRoot* self);
-	void (*set_CanQuit) (MprisRoot* self, gboolean value);
-	gboolean (*get_CanRaise) (MprisRoot* self);
-	void (*set_CanRaise) (MprisRoot* self, gboolean value);
-	gchar* (*get_Identity) (MprisRoot* self);
-	void (*set_Identity) (MprisRoot* self, const gchar* value);
-	gchar* (*get_DesktopEntry) (MprisRoot* self);
-	void (*set_DesktopEntry) (MprisRoot* self, const gchar* value);
-};
-
-struct _MprisPlayerIface {
-	GTypeInterface parent_iface;
-	void (*PlayPause) (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*PlayPause_finish) (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-	void (*Next) (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*Next_finish) (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-	void (*Previous) (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*Previous_finish) (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-	void (*Seek) (MprisPlayer* self, gint64 offset, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*Seek_finish) (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-	GHashTable* (*get_Metadata) (MprisPlayer* self);
-	void (*set_Metadata) (MprisPlayer* self, GHashTable* value);
-	gint32 (*get_Position) (MprisPlayer* self);
-	void (*set_Position) (MprisPlayer* self, gint32 value);
-	gchar* (*get_PlaybackStatus) (MprisPlayer* self);
-	void (*set_PlaybackStatus) (MprisPlayer* self, const gchar* value);
-};
-
-struct _PlaylistDetails {
-	char* path;
-	gchar* name;
-	gchar* icon_path;
-};
-
-struct _ActivePlaylistContainer {
-	gboolean valid;
-	PlaylistDetails* details;
-};
-
-struct _MprisPlaylistsIface {
-	GTypeInterface parent_iface;
-	void (*ActivatePlaylist) (MprisPlaylists* self, const char* playlist_id, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*ActivatePlaylist_finish) (MprisPlaylists* self, GAsyncResult* _res_, GError** error);
-	void (*GetPlaylists) (MprisPlaylists* self, guint32 index, guint32 max_count, const gchar* order, gboolean reverse_order, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	PlaylistDetails* (*GetPlaylists_finish) (MprisPlaylists* self, GAsyncResult* _res_, int* result_length1, GError** error);
-	gchar** (*get_Orderings) (MprisPlaylists* self, int* result_length1);
-	void (*set_Orderings) (MprisPlaylists* self, gchar** value, int value_length1);
-	guint32 (*get_PlaylistCount) (MprisPlaylists* self);
-	void (*set_PlaylistCount) (MprisPlaylists* self, guint32 value);
-	ActivePlaylistContainer* (*get_ActivePlaylist) (MprisPlaylists* self);
-	void (*set_ActivePlaylist) (MprisPlaylists* self, ActivePlaylistContainer* value);
-};
-
-
-
-#define MPRIS_PREFIX "org.mpris.MediaPlayer2."
-#define MPRIS_MEDIA_PLAYER_PATH "/org/mpris/MediaPlayer2"
-GType mpris_root_proxy_get_type (void) G_GNUC_CONST;
-guint mpris_root_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-GType mpris_root_get_type (void) G_GNUC_CONST;
-void mpris_root_Quit (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_root_Quit_finish (MprisRoot* self, GAsyncResult* _res_, GError** error);
-void mpris_root_Raise (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_root_Raise_finish (MprisRoot* self, GAsyncResult* _res_, GError** error);
-gboolean mpris_root_get_HasTracklist (MprisRoot* self);
-void mpris_root_set_HasTracklist (MprisRoot* self, gboolean value);
-gboolean mpris_root_get_CanQuit (MprisRoot* self);
-void mpris_root_set_CanQuit (MprisRoot* self, gboolean value);
-gboolean mpris_root_get_CanRaise (MprisRoot* self);
-void mpris_root_set_CanRaise (MprisRoot* self, gboolean value);
-gchar* mpris_root_get_Identity (MprisRoot* self);
-void mpris_root_set_Identity (MprisRoot* self, const gchar* value);
-gchar* mpris_root_get_DesktopEntry (MprisRoot* self);
-void mpris_root_set_DesktopEntry (MprisRoot* self, const gchar* value);
-static void mpris_root_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters);
-static void _vala_g_async_ready_callback (GObject *source_object, GAsyncResult *res, void *user_data);
-static void mpris_root_proxy_Quit_async (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-static void mpris_root_proxy_Quit_finish (MprisRoot* self, GAsyncResult* _res_, GError** error);
-static void mpris_root_proxy_Raise_async (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-static void mpris_root_proxy_Raise_finish (MprisRoot* self, GAsyncResult* _res_, GError** error);
-static gboolean mpris_root_dbus_proxy_get_HasTracklist (MprisRoot* self);
-static void mpris_root_dbus_proxy_set_HasTracklist (MprisRoot* self, gboolean value);
-static gboolean mpris_root_dbus_proxy_get_CanQuit (MprisRoot* self);
-static void mpris_root_dbus_proxy_set_CanQuit (MprisRoot* self, gboolean value);
-static gboolean mpris_root_dbus_proxy_get_CanRaise (MprisRoot* self);
-static void mpris_root_dbus_proxy_set_CanRaise (MprisRoot* self, gboolean value);
-static gchar* mpris_root_dbus_proxy_get_Identity (MprisRoot* self);
-static void mpris_root_dbus_proxy_set_Identity (MprisRoot* self, const gchar* value);
-static gchar* mpris_root_dbus_proxy_get_DesktopEntry (MprisRoot* self);
-static void mpris_root_dbus_proxy_set_DesktopEntry (MprisRoot* self, const gchar* value);
-static void mpris_root_proxy_mpris_root_interface_init (MprisRootIface* iface);
-static void _dbus_mpris_root_Quit (MprisRoot* self, GVariant* parameters, GDBusMethodInvocation* invocation);
-static void _dbus_mpris_root_Quit_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
-static void _dbus_mpris_root_Raise (MprisRoot* self, GVariant* parameters, GDBusMethodInvocation* invocation);
-static void _dbus_mpris_root_Raise_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
-static void mpris_root_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
-static GVariant* mpris_root_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
-static GVariant* _dbus_mpris_root_get_HasTracklist (MprisRoot* self);
-static GVariant* _dbus_mpris_root_get_CanQuit (MprisRoot* self);
-static GVariant* _dbus_mpris_root_get_CanRaise (MprisRoot* self);
-static GVariant* _dbus_mpris_root_get_Identity (MprisRoot* self);
-static GVariant* _dbus_mpris_root_get_DesktopEntry (MprisRoot* self);
-static gboolean mpris_root_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
-static void _dbus_mpris_root_set_HasTracklist (MprisRoot* self, GVariant* _value);
-static void _dbus_mpris_root_set_CanQuit (MprisRoot* self, GVariant* _value);
-static void _dbus_mpris_root_set_CanRaise (MprisRoot* self, GVariant* _value);
-static void _dbus_mpris_root_set_Identity (MprisRoot* self, GVariant* _value);
-static void _dbus_mpris_root_set_DesktopEntry (MprisRoot* self, GVariant* _value);
-static void _mpris_root_unregister_object (gpointer user_data);
-GType mpris_player_proxy_get_type (void) G_GNUC_CONST;
-guint mpris_player_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-GType mpris_player_get_type (void) G_GNUC_CONST;
-void mpris_player_PlayPause (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_player_PlayPause_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-void mpris_player_Next (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_player_Next_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-void mpris_player_Previous (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_player_Previous_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-void mpris_player_Seek (MprisPlayer* self, gint64 offset, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_player_Seek_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-GHashTable* mpris_player_get_Metadata (MprisPlayer* self);
-void mpris_player_set_Metadata (MprisPlayer* self, GHashTable* value);
-gint32 mpris_player_get_Position (MprisPlayer* self);
-void mpris_player_set_Position (MprisPlayer* self, gint32 value);
-gchar* mpris_player_get_PlaybackStatus (MprisPlayer* self);
-void mpris_player_set_PlaybackStatus (MprisPlayer* self, const gchar* value);
-static void g_cclosure_user_marshal_VOID__INT64 (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
-static void mpris_player_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters);
-static void _dbus_handle_mpris_player_seeked (MprisPlayer* self, GVariant* parameters);
-static void mpris_player_proxy_PlayPause_async (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-static void mpris_player_proxy_PlayPause_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-static void mpris_player_proxy_Next_async (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-static void mpris_player_proxy_Next_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-static void mpris_player_proxy_Previous_async (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-static void mpris_player_proxy_Previous_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-static void mpris_player_proxy_Seek_async (MprisPlayer* self, gint64 offset, GAsyncReadyCallback _callback_, gpointer _user_data_);
-static void mpris_player_proxy_Seek_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-static GHashTable* mpris_player_dbus_proxy_get_Metadata (MprisPlayer* self);
-static void mpris_player_dbus_proxy_set_Metadata (MprisPlayer* self, GHashTable* value);
-static gint32 mpris_player_dbus_proxy_get_Position (MprisPlayer* self);
-static void mpris_player_dbus_proxy_set_Position (MprisPlayer* self, gint32 value);
-static gchar* mpris_player_dbus_proxy_get_PlaybackStatus (MprisPlayer* self);
-static void mpris_player_dbus_proxy_set_PlaybackStatus (MprisPlayer* self, const gchar* value);
-static void mpris_player_proxy_mpris_player_interface_init (MprisPlayerIface* iface);
-static void _dbus_mpris_player_PlayPause (MprisPlayer* self, GVariant* parameters, GDBusMethodInvocation* invocation);
-static void _dbus_mpris_player_PlayPause_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
-static void _dbus_mpris_player_Next (MprisPlayer* self, GVariant* parameters, GDBusMethodInvocation* invocation);
-static void _dbus_mpris_player_Next_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
-static void _dbus_mpris_player_Previous (MprisPlayer* self, GVariant* parameters, GDBusMethodInvocation* invocation);
-static void _dbus_mpris_player_Previous_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
-static void _dbus_mpris_player_Seek (MprisPlayer* self, GVariant* parameters, GDBusMethodInvocation* invocation);
-static void _dbus_mpris_player_Seek_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
-static void mpris_player_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
-static GVariant* mpris_player_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
-static GVariant* _dbus_mpris_player_get_Metadata (MprisPlayer* self);
-static GVariant* _dbus_mpris_player_get_Position (MprisPlayer* self);
-static GVariant* _dbus_mpris_player_get_PlaybackStatus (MprisPlayer* self);
-static gboolean mpris_player_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
-static void _dbus_mpris_player_set_Metadata (MprisPlayer* self, GVariant* _value);
-static void _dbus_mpris_player_set_Position (MprisPlayer* self, GVariant* _value);
-static void _dbus_mpris_player_set_PlaybackStatus (MprisPlayer* self, GVariant* _value);
-static void _dbus_mpris_player_seeked (GObject* _sender, gint64 new_position, gpointer* _data);
-static void _mpris_player_unregister_object (gpointer user_data);
-GType playlist_details_get_type (void) G_GNUC_CONST;
-PlaylistDetails* playlist_details_dup (const PlaylistDetails* self);
-void playlist_details_free (PlaylistDetails* self);
-void playlist_details_copy (const PlaylistDetails* self, PlaylistDetails* dest);
-void playlist_details_destroy (PlaylistDetails* self);
-GType active_playlist_container_get_type (void) G_GNUC_CONST;
-ActivePlaylistContainer* active_playlist_container_dup (const ActivePlaylistContainer* self);
-void active_playlist_container_free (ActivePlaylistContainer* self);
-void active_playlist_container_copy (const ActivePlaylistContainer* self, ActivePlaylistContainer* dest);
-void active_playlist_container_destroy (ActivePlaylistContainer* self);
-GType mpris_playlists_proxy_get_type (void) G_GNUC_CONST;
-guint mpris_playlists_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-GType mpris_playlists_get_type (void) G_GNUC_CONST;
-void mpris_playlists_ActivatePlaylist (MprisPlaylists* self, const char* playlist_id, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_playlists_ActivatePlaylist_finish (MprisPlaylists* self, GAsyncResult* _res_, GError** error);
-void mpris_playlists_GetPlaylists (MprisPlaylists* self, guint32 index, guint32 max_count, const gchar* order, gboolean reverse_order, GAsyncReadyCallback _callback_, gpointer _user_data_);
-PlaylistDetails* mpris_playlists_GetPlaylists_finish (MprisPlaylists* self, GAsyncResult* _res_, int* result_length1, GError** error);
-gchar** mpris_playlists_get_Orderings (MprisPlaylists* self, int* result_length1);
-void mpris_playlists_set_Orderings (MprisPlaylists* self, gchar** value, int value_length1);
-guint32 mpris_playlists_get_PlaylistCount (MprisPlaylists* self);
-void mpris_playlists_set_PlaylistCount (MprisPlaylists* self, guint32 value);
-ActivePlaylistContainer* mpris_playlists_get_ActivePlaylist (MprisPlaylists* self);
-void mpris_playlists_set_ActivePlaylist (MprisPlaylists* self, ActivePlaylistContainer* value);
-static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
-static void mpris_playlists_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters);
-static void _dbus_handle_mpris_playlists_playlist_changed (MprisPlaylists* self, GVariant* parameters);
-static void mpris_playlists_proxy_ActivatePlaylist_async (MprisPlaylists* self, const char* playlist_id, GAsyncReadyCallback _callback_, gpointer _user_data_);
-static void mpris_playlists_proxy_ActivatePlaylist_finish (MprisPlaylists* self, GAsyncResult* _res_, GError** error);
-static void mpris_playlists_proxy_GetPlaylists_async (MprisPlaylists* self, guint32 index, guint32 max_count, const gchar* order, gboolean reverse_order, GAsyncReadyCallback _callback_, gpointer _user_data_);
-static PlaylistDetails* mpris_playlists_proxy_GetPlaylists_finish (MprisPlaylists* self, GAsyncResult* _res_, int* result_length1, GError** error);
-static gchar** mpris_playlists_dbus_proxy_get_Orderings (MprisPlaylists* self, int* result_length1);
-static void mpris_playlists_dbus_proxy_set_Orderings (MprisPlaylists* self, gchar** value, int value_length1);
-static guint32 mpris_playlists_dbus_proxy_get_PlaylistCount (MprisPlaylists* self);
-static void mpris_playlists_dbus_proxy_set_PlaylistCount (MprisPlaylists* self, guint32 value);
-static ActivePlaylistContainer* mpris_playlists_dbus_proxy_get_ActivePlaylist (MprisPlaylists* self);
-static void mpris_playlists_dbus_proxy_set_ActivePlaylist (MprisPlaylists* self, ActivePlaylistContainer* value);
-static void mpris_playlists_proxy_mpris_playlists_interface_init (MprisPlaylistsIface* iface);
-static void _dbus_mpris_playlists_ActivatePlaylist (MprisPlaylists* self, GVariant* parameters, GDBusMethodInvocation* invocation);
-static void _dbus_mpris_playlists_ActivatePlaylist_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
-static void _dbus_mpris_playlists_GetPlaylists (MprisPlaylists* self, GVariant* parameters, GDBusMethodInvocation* invocation);
-static void _vala_PlaylistDetails_array_free (PlaylistDetails* array, gint array_length);
-static void _dbus_mpris_playlists_GetPlaylists_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_);
-static void mpris_playlists_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
-static GVariant* mpris_playlists_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
-static GVariant* _dbus_mpris_playlists_get_Orderings (MprisPlaylists* self);
-static GVariant* _dbus_mpris_playlists_get_PlaylistCount (MprisPlaylists* self);
-static GVariant* _dbus_mpris_playlists_get_ActivePlaylist (MprisPlaylists* self);
-static gboolean mpris_playlists_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
-static void _dbus_mpris_playlists_set_Orderings (MprisPlaylists* self, GVariant* _value);
-static void _dbus_mpris_playlists_set_PlaylistCount (MprisPlaylists* self, GVariant* _value);
-static void _dbus_mpris_playlists_set_ActivePlaylist (MprisPlaylists* self, GVariant* _value);
-static void _dbus_mpris_playlists_playlist_changed (GObject* _sender, PlaylistDetails* details, gpointer* _data);
-static void _mpris_playlists_unregister_object (gpointer user_data);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-
-static const GDBusArgInfo * const _mpris_root_dbus_arg_info_Quit_in[] = {NULL};
-static const GDBusArgInfo * const _mpris_root_dbus_arg_info_Quit_out[] = {NULL};
-static const GDBusMethodInfo _mpris_root_dbus_method_info_Quit = {-1, "Quit", (GDBusArgInfo **) (&_mpris_root_dbus_arg_info_Quit_in), (GDBusArgInfo **) (&_mpris_root_dbus_arg_info_Quit_out)};
-static const GDBusArgInfo * const _mpris_root_dbus_arg_info_Raise_in[] = {NULL};
-static const GDBusArgInfo * const _mpris_root_dbus_arg_info_Raise_out[] = {NULL};
-static const GDBusMethodInfo _mpris_root_dbus_method_info_Raise = {-1, "Raise", (GDBusArgInfo **) (&_mpris_root_dbus_arg_info_Raise_in), (GDBusArgInfo **) (&_mpris_root_dbus_arg_info_Raise_out)};
-static const GDBusMethodInfo * const _mpris_root_dbus_method_info[] = {&_mpris_root_dbus_method_info_Quit, &_mpris_root_dbus_method_info_Raise, NULL};
-static const GDBusSignalInfo * const _mpris_root_dbus_signal_info[] = {NULL};
-static const GDBusPropertyInfo _mpris_root_dbus_property_info_HasTracklist = {-1, "HasTracklist", "b", G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE};
-static const GDBusPropertyInfo _mpris_root_dbus_property_info_CanQuit = {-1, "CanQuit", "b", G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE};
-static const GDBusPropertyInfo _mpris_root_dbus_property_info_CanRaise = {-1, "CanRaise", "b", G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE};
-static const GDBusPropertyInfo _mpris_root_dbus_property_info_Identity = {-1, "Identity", "s", G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE};
-static const GDBusPropertyInfo _mpris_root_dbus_property_info_DesktopEntry = {-1, "DesktopEntry", "s", G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE};
-static const GDBusPropertyInfo * const _mpris_root_dbus_property_info[] = {&_mpris_root_dbus_property_info_HasTracklist, &_mpris_root_dbus_property_info_CanQuit, &_mpris_root_dbus_property_info_CanRaise, &_mpris_root_dbus_property_info_Identity, &_mpris_root_dbus_property_info_DesktopEntry, NULL};
-static const GDBusInterfaceInfo _mpris_root_dbus_interface_info = {-1, "org.mpris.MediaPlayer2", (GDBusMethodInfo **) (&_mpris_root_dbus_method_info), (GDBusSignalInfo **) (&_mpris_root_dbus_signal_info), (GDBusPropertyInfo **) (&_mpris_root_dbus_property_info)};
-static const GDBusInterfaceVTable _mpris_root_dbus_interface_vtable = {mpris_root_dbus_interface_method_call, mpris_root_dbus_interface_get_property, mpris_root_dbus_interface_set_property};
-static const GDBusArgInfo * const _mpris_player_dbus_arg_info_PlayPause_in[] = {NULL};
-static const GDBusArgInfo * const _mpris_player_dbus_arg_info_PlayPause_out[] = {NULL};
-static const GDBusMethodInfo _mpris_player_dbus_method_info_PlayPause = {-1, "PlayPause", (GDBusArgInfo **) (&_mpris_player_dbus_arg_info_PlayPause_in), (GDBusArgInfo **) (&_mpris_player_dbus_arg_info_PlayPause_out)};
-static const GDBusArgInfo * const _mpris_player_dbus_arg_info_Next_in[] = {NULL};
-static const GDBusArgInfo * const _mpris_player_dbus_arg_info_Next_out[] = {NULL};
-static const GDBusMethodInfo _mpris_player_dbus_method_info_Next = {-1, "Next", (GDBusArgInfo **) (&_mpris_player_dbus_arg_info_Next_in), (GDBusArgInfo **) (&_mpris_player_dbus_arg_info_Next_out)};
-static const GDBusArgInfo * const _mpris_player_dbus_arg_info_Previous_in[] = {NULL};
-static const GDBusArgInfo * const _mpris_player_dbus_arg_info_Previous_out[] = {NULL};
-static const GDBusMethodInfo _mpris_player_dbus_method_info_Previous = {-1, "Previous", (GDBusArgInfo **) (&_mpris_player_dbus_arg_info_Previous_in), (GDBusArgInfo **) (&_mpris_player_dbus_arg_info_Previous_out)};
-static const GDBusArgInfo _mpris_player_dbus_arg_info_Seek_offset = {-1, "offset", "x"};
-static const GDBusArgInfo * const _mpris_player_dbus_arg_info_Seek_in[] = {&_mpris_player_dbus_arg_info_Seek_offset, NULL};
-static const GDBusArgInfo * const _mpris_player_dbus_arg_info_Seek_out[] = {NULL};
-static const GDBusMethodInfo _mpris_player_dbus_method_info_Seek = {-1, "Seek", (GDBusArgInfo **) (&_mpris_player_dbus_arg_info_Seek_in), (GDBusArgInfo **) (&_mpris_player_dbus_arg_info_Seek_out)};
-static const GDBusMethodInfo * const _mpris_player_dbus_method_info[] = {&_mpris_player_dbus_method_info_PlayPause, &_mpris_player_dbus_method_info_Next, &_mpris_player_dbus_method_info_Previous, &_mpris_player_dbus_method_info_Seek, NULL};
-static const GDBusArgInfo _mpris_player_dbus_arg_info_seeked_new_position = {-1, "new_position", "x"};
-static const GDBusArgInfo * const _mpris_player_dbus_arg_info_seeked[] = {&_mpris_player_dbus_arg_info_seeked_new_position, NULL};
-static const GDBusSignalInfo _mpris_player_dbus_signal_info_seeked = {-1, "Seeked", (GDBusArgInfo **) (&_mpris_player_dbus_arg_info_seeked)};
-static const GDBusSignalInfo * const _mpris_player_dbus_signal_info[] = {&_mpris_player_dbus_signal_info_seeked, NULL};
-static const GDBusPropertyInfo _mpris_player_dbus_property_info_Metadata = {-1, "Metadata", "a{sv}", G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE};
-static const GDBusPropertyInfo _mpris_player_dbus_property_info_Position = {-1, "Position", "i", G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE};
-static const GDBusPropertyInfo _mpris_player_dbus_property_info_PlaybackStatus = {-1, "PlaybackStatus", "s", G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE};
-static const GDBusPropertyInfo * const _mpris_player_dbus_property_info[] = {&_mpris_player_dbus_property_info_Metadata, &_mpris_player_dbus_property_info_Position, &_mpris_player_dbus_property_info_PlaybackStatus, NULL};
-static const GDBusInterfaceInfo _mpris_player_dbus_interface_info = {-1, "org.mpris.MediaPlayer2.Player", (GDBusMethodInfo **) (&_mpris_player_dbus_method_info), (GDBusSignalInfo **) (&_mpris_player_dbus_signal_info), (GDBusPropertyInfo **) (&_mpris_player_dbus_property_info)};
-static const GDBusInterfaceVTable _mpris_player_dbus_interface_vtable = {mpris_player_dbus_interface_method_call, mpris_player_dbus_interface_get_property, mpris_player_dbus_interface_set_property};
-static const GDBusArgInfo _mpris_playlists_dbus_arg_info_ActivatePlaylist_playlist_id = {-1, "playlist_id", "o"};
-static const GDBusArgInfo * const _mpris_playlists_dbus_arg_info_ActivatePlaylist_in[] = {&_mpris_playlists_dbus_arg_info_ActivatePlaylist_playlist_id, NULL};
-static const GDBusArgInfo * const _mpris_playlists_dbus_arg_info_ActivatePlaylist_out[] = {NULL};
-static const GDBusMethodInfo _mpris_playlists_dbus_method_info_ActivatePlaylist = {-1, "ActivatePlaylist", (GDBusArgInfo **) (&_mpris_playlists_dbus_arg_info_ActivatePlaylist_in), (GDBusArgInfo **) (&_mpris_playlists_dbus_arg_info_ActivatePlaylist_out)};
-static const GDBusArgInfo _mpris_playlists_dbus_arg_info_GetPlaylists_index = {-1, "index", "u"};
-static const GDBusArgInfo _mpris_playlists_dbus_arg_info_GetPlaylists_max_count = {-1, "max_count", "u"};
-static const GDBusArgInfo _mpris_playlists_dbus_arg_info_GetPlaylists_order = {-1, "order", "s"};
-static const GDBusArgInfo _mpris_playlists_dbus_arg_info_GetPlaylists_reverse_order = {-1, "reverse_order", "b"};
-static const GDBusArgInfo _mpris_playlists_dbus_arg_info_GetPlaylists_result = {-1, "result", "a(oss)"};
-static const GDBusArgInfo * const _mpris_playlists_dbus_arg_info_GetPlaylists_in[] = {&_mpris_playlists_dbus_arg_info_GetPlaylists_index, &_mpris_playlists_dbus_arg_info_GetPlaylists_max_count, &_mpris_playlists_dbus_arg_info_GetPlaylists_order, &_mpris_playlists_dbus_arg_info_GetPlaylists_reverse_order, NULL};
-static const GDBusArgInfo * const _mpris_playlists_dbus_arg_info_GetPlaylists_out[] = {&_mpris_playlists_dbus_arg_info_GetPlaylists_result, NULL};
-static const GDBusMethodInfo _mpris_playlists_dbus_method_info_GetPlaylists = {-1, "GetPlaylists", (GDBusArgInfo **) (&_mpris_playlists_dbus_arg_info_GetPlaylists_in), (GDBusArgInfo **) (&_mpris_playlists_dbus_arg_info_GetPlaylists_out)};
-static const GDBusMethodInfo * const _mpris_playlists_dbus_method_info[] = {&_mpris_playlists_dbus_method_info_ActivatePlaylist, &_mpris_playlists_dbus_method_info_GetPlaylists, NULL};
-static const GDBusArgInfo _mpris_playlists_dbus_arg_info_playlist_changed_details = {-1, "details", "(oss)"};
-static const GDBusArgInfo * const _mpris_playlists_dbus_arg_info_playlist_changed[] = {&_mpris_playlists_dbus_arg_info_playlist_changed_details, NULL};
-static const GDBusSignalInfo _mpris_playlists_dbus_signal_info_playlist_changed = {-1, "PlaylistChanged", (GDBusArgInfo **) (&_mpris_playlists_dbus_arg_info_playlist_changed)};
-static const GDBusSignalInfo * const _mpris_playlists_dbus_signal_info[] = {&_mpris_playlists_dbus_signal_info_playlist_changed, NULL};
-static const GDBusPropertyInfo _mpris_playlists_dbus_property_info_Orderings = {-1, "Orderings", "as", G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE};
-static const GDBusPropertyInfo _mpris_playlists_dbus_property_info_PlaylistCount = {-1, "PlaylistCount", "u", G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE};
-static const GDBusPropertyInfo _mpris_playlists_dbus_property_info_ActivePlaylist = {-1, "ActivePlaylist", "(b(oss))", G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE};
-static const GDBusPropertyInfo * const _mpris_playlists_dbus_property_info[] = {&_mpris_playlists_dbus_property_info_Orderings, &_mpris_playlists_dbus_property_info_PlaylistCount, &_mpris_playlists_dbus_property_info_ActivePlaylist, NULL};
-static const GDBusInterfaceInfo _mpris_playlists_dbus_interface_info = {-1, "org.mpris.MediaPlayer2.Playlists", (GDBusMethodInfo **) (&_mpris_playlists_dbus_method_info), (GDBusSignalInfo **) (&_mpris_playlists_dbus_signal_info), (GDBusPropertyInfo **) (&_mpris_playlists_dbus_property_info)};
-static const GDBusInterfaceVTable _mpris_playlists_dbus_interface_vtable = {mpris_playlists_dbus_interface_method_call, mpris_playlists_dbus_interface_get_property, mpris_playlists_dbus_interface_set_property};
-
-void mpris_root_Quit (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	MPRIS_ROOT_GET_INTERFACE (self)->Quit (self, _callback_, _user_data_);
-}
-
-
-void mpris_root_Quit_finish (MprisRoot* self, GAsyncResult* _res_, GError** error) {
-	MPRIS_ROOT_GET_INTERFACE (self)->Quit_finish (self, _res_, error);
-}
-
-
-void mpris_root_Raise (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	MPRIS_ROOT_GET_INTERFACE (self)->Raise (self, _callback_, _user_data_);
-}
-
-
-void mpris_root_Raise_finish (MprisRoot* self, GAsyncResult* _res_, GError** error) {
-	MPRIS_ROOT_GET_INTERFACE (self)->Raise_finish (self, _res_, error);
-}
-
-
-gboolean mpris_root_get_HasTracklist (MprisRoot* self) {
-	g_return_val_if_fail (self != NULL, FALSE);
-	return MPRIS_ROOT_GET_INTERFACE (self)->get_HasTracklist (self);
-}
-
-
-void mpris_root_set_HasTracklist (MprisRoot* self, gboolean value) {
-	g_return_if_fail (self != NULL);
-	MPRIS_ROOT_GET_INTERFACE (self)->set_HasTracklist (self, value);
-}
-
-
-gboolean mpris_root_get_CanQuit (MprisRoot* self) {
-	g_return_val_if_fail (self != NULL, FALSE);
-	return MPRIS_ROOT_GET_INTERFACE (self)->get_CanQuit (self);
-}
-
-
-void mpris_root_set_CanQuit (MprisRoot* self, gboolean value) {
-	g_return_if_fail (self != NULL);
-	MPRIS_ROOT_GET_INTERFACE (self)->set_CanQuit (self, value);
-}
-
-
-gboolean mpris_root_get_CanRaise (MprisRoot* self) {
-	g_return_val_if_fail (self != NULL, FALSE);
-	return MPRIS_ROOT_GET_INTERFACE (self)->get_CanRaise (self);
-}
-
-
-void mpris_root_set_CanRaise (MprisRoot* self, gboolean value) {
-	g_return_if_fail (self != NULL);
-	MPRIS_ROOT_GET_INTERFACE (self)->set_CanRaise (self, value);
-}
-
-
-gchar* mpris_root_get_Identity (MprisRoot* self) {
-	g_return_val_if_fail (self != NULL, NULL);
-	return MPRIS_ROOT_GET_INTERFACE (self)->get_Identity (self);
-}
-
-
-void mpris_root_set_Identity (MprisRoot* self, const gchar* value) {
-	g_return_if_fail (self != NULL);
-	MPRIS_ROOT_GET_INTERFACE (self)->set_Identity (self, value);
-}
-
-
-gchar* mpris_root_get_DesktopEntry (MprisRoot* self) {
-	g_return_val_if_fail (self != NULL, NULL);
-	return MPRIS_ROOT_GET_INTERFACE (self)->get_DesktopEntry (self);
-}
-
-
-void mpris_root_set_DesktopEntry (MprisRoot* self, const gchar* value) {
-	g_return_if_fail (self != NULL);
-	MPRIS_ROOT_GET_INTERFACE (self)->set_DesktopEntry (self, value);
-}
-
-
-static void mpris_root_base_init (MprisRootIface * iface) {
-	static gboolean initialized = FALSE;
-	if (!initialized) {
-		initialized = TRUE;
-	}
-}
-
-
-GType mpris_root_get_type (void) {
-	static volatile gsize mpris_root_type_id__volatile = 0;
-	if (g_once_init_enter (&mpris_root_type_id__volatile)) {
-		static const GTypeInfo g_define_type_info = { sizeof (MprisRootIface), (GBaseInitFunc) mpris_root_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
-		GType mpris_root_type_id;
-		mpris_root_type_id = g_type_register_static (G_TYPE_INTERFACE, "MprisRoot", &g_define_type_info, 0);
-		g_type_interface_add_prerequisite (mpris_root_type_id, G_TYPE_OBJECT);
-		g_type_set_qdata (mpris_root_type_id, g_quark_from_static_string ("vala-dbus-proxy-type"), (void*) mpris_root_proxy_get_type);
-		g_type_set_qdata (mpris_root_type_id, g_quark_from_static_string ("vala-dbus-interface-name"), "org.mpris.MediaPlayer2");
-		g_type_set_qdata (mpris_root_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) mpris_root_register_object);
-		g_once_init_leave (&mpris_root_type_id__volatile, mpris_root_type_id);
-	}
-	return mpris_root_type_id__volatile;
-}
-
-
-G_DEFINE_TYPE_EXTENDED (MprisRootProxy, mpris_root_proxy, G_TYPE_DBUS_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_MPRIS_ROOT, mpris_root_proxy_mpris_root_interface_init) )
-static void mpris_root_proxy_class_init (MprisRootProxyClass* klass) {
-	G_DBUS_PROXY_CLASS (klass)->g_signal = mpris_root_proxy_g_signal;
-}
-
-
-static void mpris_root_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters) {
-}
-
-
-static void mpris_root_proxy_init (MprisRootProxy* self) {
-}
-
-
-static void _vala_g_async_ready_callback (GObject *source_object, GAsyncResult *res, void *user_data) {
-	g_simple_async_result_set_op_res_gpointer (user_data, g_object_ref (res), g_object_unref);
-	g_simple_async_result_complete (user_data);
-	g_object_unref (user_data);
-}
-
-
-static void mpris_root_proxy_Quit_async (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	GDBusMessage *_message;
-	GVariant *_arguments;
-	GVariantBuilder _arguments_builder;
-	G_IO_ERROR;
-	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.mpris.MediaPlayer2", "Quit");
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	g_dbus_message_set_body (_message, _arguments);
-	g_dbus_connection_send_message_with_reply (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, _vala_g_async_ready_callback, g_simple_async_result_new ((GObject *) self, _callback_, _user_data_, NULL));
-	g_object_unref (_message);
-}
-
-
-static void mpris_root_proxy_Quit_finish (MprisRoot* self, GAsyncResult* _res_, GError** error) {
-	GDBusMessage *_reply_message;
-	_reply_message = g_dbus_connection_send_message_with_reply_finish (g_dbus_proxy_get_connection ((GDBusProxy *) self), g_simple_async_result_get_op_res_gpointer ((GSimpleAsyncResult *) _res_), error);
-	if (!_reply_message) {
-		return;
-	}
-	if (g_dbus_message_to_gerror (_reply_message, error)) {
-		g_object_unref (_reply_message);
-		return;
-	}
-	g_object_unref (_reply_message);
-}
-
-
-static void mpris_root_proxy_Raise_async (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	GDBusMessage *_message;
-	GVariant *_arguments;
-	GVariantBuilder _arguments_builder;
-	G_IO_ERROR;
-	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.mpris.MediaPlayer2", "Raise");
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	g_dbus_message_set_body (_message, _arguments);
-	g_dbus_connection_send_message_with_reply (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, _vala_g_async_ready_callback, g_simple_async_result_new ((GObject *) self, _callback_, _user_data_, NULL));
-	g_object_unref (_message);
-}
-
-
-static void mpris_root_proxy_Raise_finish (MprisRoot* self, GAsyncResult* _res_, GError** error) {
-	GDBusMessage *_reply_message;
-	_reply_message = g_dbus_connection_send_message_with_reply_finish (g_dbus_proxy_get_connection ((GDBusProxy *) self), g_simple_async_result_get_op_res_gpointer ((GSimpleAsyncResult *) _res_), error);
-	if (!_reply_message) {
-		return;
-	}
-	if (g_dbus_message_to_gerror (_reply_message, error)) {
-		g_object_unref (_reply_message);
-		return;
-	}
-	g_object_unref (_reply_message);
-}
-
-
-static gboolean mpris_root_dbus_proxy_get_HasTracklist (MprisRoot* self) {
-	GVariant *_inner_reply;
-	gboolean _result;
-	_inner_reply = g_dbus_proxy_get_cached_property ((GDBusProxy *) self, "HasTracklist");
-	if (!_inner_reply) {
-		GVariant *_arguments;
-		GVariant *_reply;
-		GVariantBuilder _arguments_builder;
-		g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2"));
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("HasTracklist"));
-		_arguments = g_variant_builder_end (&_arguments_builder);
-		_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Get", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-		if (!_reply) {
-			return FALSE;
-		}
-		g_variant_get (_reply, "(v)", &_inner_reply);
-		g_variant_unref (_reply);
-	}
-	_result = g_variant_get_boolean (_inner_reply);
-	g_variant_unref (_inner_reply);
-	return _result;
-}
-
-
-static void mpris_root_dbus_proxy_set_HasTracklist (MprisRoot* self, gboolean value) {
-	GVariant *_arguments;
-	GVariant *_reply;
-	GVariantBuilder _arguments_builder;
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2"));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("HasTracklist"));
-	g_variant_builder_open (&_arguments_builder, G_VARIANT_TYPE_VARIANT);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_boolean (value));
-	g_variant_builder_close (&_arguments_builder);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Set", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-	if (!_reply) {
-		return;
-	}
-	g_variant_unref (_reply);
-}
-
-
-static gboolean mpris_root_dbus_proxy_get_CanQuit (MprisRoot* self) {
-	GVariant *_inner_reply;
-	gboolean _result;
-	_inner_reply = g_dbus_proxy_get_cached_property ((GDBusProxy *) self, "CanQuit");
-	if (!_inner_reply) {
-		GVariant *_arguments;
-		GVariant *_reply;
-		GVariantBuilder _arguments_builder;
-		g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2"));
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("CanQuit"));
-		_arguments = g_variant_builder_end (&_arguments_builder);
-		_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Get", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-		if (!_reply) {
-			return FALSE;
-		}
-		g_variant_get (_reply, "(v)", &_inner_reply);
-		g_variant_unref (_reply);
-	}
-	_result = g_variant_get_boolean (_inner_reply);
-	g_variant_unref (_inner_reply);
-	return _result;
-}
-
-
-static void mpris_root_dbus_proxy_set_CanQuit (MprisRoot* self, gboolean value) {
-	GVariant *_arguments;
-	GVariant *_reply;
-	GVariantBuilder _arguments_builder;
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2"));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("CanQuit"));
-	g_variant_builder_open (&_arguments_builder, G_VARIANT_TYPE_VARIANT);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_boolean (value));
-	g_variant_builder_close (&_arguments_builder);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Set", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-	if (!_reply) {
-		return;
-	}
-	g_variant_unref (_reply);
-}
-
-
-static gboolean mpris_root_dbus_proxy_get_CanRaise (MprisRoot* self) {
-	GVariant *_inner_reply;
-	gboolean _result;
-	_inner_reply = g_dbus_proxy_get_cached_property ((GDBusProxy *) self, "CanRaise");
-	if (!_inner_reply) {
-		GVariant *_arguments;
-		GVariant *_reply;
-		GVariantBuilder _arguments_builder;
-		g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2"));
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("CanRaise"));
-		_arguments = g_variant_builder_end (&_arguments_builder);
-		_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Get", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-		if (!_reply) {
-			return FALSE;
-		}
-		g_variant_get (_reply, "(v)", &_inner_reply);
-		g_variant_unref (_reply);
-	}
-	_result = g_variant_get_boolean (_inner_reply);
-	g_variant_unref (_inner_reply);
-	return _result;
-}
-
-
-static void mpris_root_dbus_proxy_set_CanRaise (MprisRoot* self, gboolean value) {
-	GVariant *_arguments;
-	GVariant *_reply;
-	GVariantBuilder _arguments_builder;
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2"));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("CanRaise"));
-	g_variant_builder_open (&_arguments_builder, G_VARIANT_TYPE_VARIANT);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_boolean (value));
-	g_variant_builder_close (&_arguments_builder);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Set", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-	if (!_reply) {
-		return;
-	}
-	g_variant_unref (_reply);
-}
-
-
-static gchar* mpris_root_dbus_proxy_get_Identity (MprisRoot* self) {
-	GVariant *_inner_reply;
-	gchar* _result;
-	_inner_reply = g_dbus_proxy_get_cached_property ((GDBusProxy *) self, "Identity");
-	if (!_inner_reply) {
-		GVariant *_arguments;
-		GVariant *_reply;
-		GVariantBuilder _arguments_builder;
-		g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2"));
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("Identity"));
-		_arguments = g_variant_builder_end (&_arguments_builder);
-		_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Get", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-		if (!_reply) {
-			return NULL;
-		}
-		g_variant_get (_reply, "(v)", &_inner_reply);
-		g_variant_unref (_reply);
-	}
-	_result = g_variant_dup_string (_inner_reply, NULL);
-	g_variant_unref (_inner_reply);
-	return _result;
-}
-
-
-static void mpris_root_dbus_proxy_set_Identity (MprisRoot* self, const gchar* value) {
-	GVariant *_arguments;
-	GVariant *_reply;
-	GVariantBuilder _arguments_builder;
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2"));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("Identity"));
-	g_variant_builder_open (&_arguments_builder, G_VARIANT_TYPE_VARIANT);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (value));
-	g_variant_builder_close (&_arguments_builder);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Set", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-	if (!_reply) {
-		return;
-	}
-	g_variant_unref (_reply);
-}
-
-
-static gchar* mpris_root_dbus_proxy_get_DesktopEntry (MprisRoot* self) {
-	GVariant *_inner_reply;
-	gchar* _result;
-	_inner_reply = g_dbus_proxy_get_cached_property ((GDBusProxy *) self, "DesktopEntry");
-	if (!_inner_reply) {
-		GVariant *_arguments;
-		GVariant *_reply;
-		GVariantBuilder _arguments_builder;
-		g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2"));
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("DesktopEntry"));
-		_arguments = g_variant_builder_end (&_arguments_builder);
-		_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Get", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-		if (!_reply) {
-			return NULL;
-		}
-		g_variant_get (_reply, "(v)", &_inner_reply);
-		g_variant_unref (_reply);
-	}
-	_result = g_variant_dup_string (_inner_reply, NULL);
-	g_variant_unref (_inner_reply);
-	return _result;
-}
-
-
-static void mpris_root_dbus_proxy_set_DesktopEntry (MprisRoot* self, const gchar* value) {
-	GVariant *_arguments;
-	GVariant *_reply;
-	GVariantBuilder _arguments_builder;
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2"));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("DesktopEntry"));
-	g_variant_builder_open (&_arguments_builder, G_VARIANT_TYPE_VARIANT);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (value));
-	g_variant_builder_close (&_arguments_builder);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Set", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-	if (!_reply) {
-		return;
-	}
-	g_variant_unref (_reply);
-}
-
-
-static void mpris_root_proxy_mpris_root_interface_init (MprisRootIface* iface) {
-	iface->Quit = mpris_root_proxy_Quit_async;
-	iface->Quit_finish = mpris_root_proxy_Quit_finish;
-	iface->Raise = mpris_root_proxy_Raise_async;
-	iface->Raise_finish = mpris_root_proxy_Raise_finish;
-	iface->get_HasTracklist = mpris_root_dbus_proxy_get_HasTracklist;
-	iface->set_HasTracklist = mpris_root_dbus_proxy_set_HasTracklist;
-	iface->get_CanQuit = mpris_root_dbus_proxy_get_CanQuit;
-	iface->set_CanQuit = mpris_root_dbus_proxy_set_CanQuit;
-	iface->get_CanRaise = mpris_root_dbus_proxy_get_CanRaise;
-	iface->set_CanRaise = mpris_root_dbus_proxy_set_CanRaise;
-	iface->get_Identity = mpris_root_dbus_proxy_get_Identity;
-	iface->set_Identity = mpris_root_dbus_proxy_set_Identity;
-	iface->get_DesktopEntry = mpris_root_dbus_proxy_get_DesktopEntry;
-	iface->set_DesktopEntry = mpris_root_dbus_proxy_set_DesktopEntry;
-}
-
-
-static void _dbus_mpris_root_Quit (MprisRoot* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
-	GVariantIter _arguments_iter;
-	g_variant_iter_init (&_arguments_iter, parameters);
-	mpris_root_Quit (self, (GAsyncReadyCallback) _dbus_mpris_root_Quit_ready, invocation);
-}
-
-
-static void _dbus_mpris_root_Quit_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
-	GDBusMethodInvocation * invocation;
-	GError* error = NULL;
-	GDBusMessage* _reply_message;
-	GVariant* _reply;
-	GVariantBuilder _reply_builder;
-	invocation = _user_data_;
-	mpris_root_Quit_finish ((MprisRoot*) source_object, _res_, &error);
-	if (error) {
-		g_dbus_method_invocation_return_gerror (invocation, error);
-		return;
-	}
-	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
-	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
-	_reply = g_variant_builder_end (&_reply_builder);
-	g_dbus_message_set_body (_reply_message, _reply);
-	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
-	g_object_unref (invocation);
-	g_object_unref (_reply_message);
-}
-
-
-static void _dbus_mpris_root_Raise (MprisRoot* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
-	GVariantIter _arguments_iter;
-	g_variant_iter_init (&_arguments_iter, parameters);
-	mpris_root_Raise (self, (GAsyncReadyCallback) _dbus_mpris_root_Raise_ready, invocation);
-}
-
-
-static void _dbus_mpris_root_Raise_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
-	GDBusMethodInvocation * invocation;
-	GError* error = NULL;
-	GDBusMessage* _reply_message;
-	GVariant* _reply;
-	GVariantBuilder _reply_builder;
-	invocation = _user_data_;
-	mpris_root_Raise_finish ((MprisRoot*) source_object, _res_, &error);
-	if (error) {
-		g_dbus_method_invocation_return_gerror (invocation, error);
-		return;
-	}
-	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
-	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
-	_reply = g_variant_builder_end (&_reply_builder);
-	g_dbus_message_set_body (_reply_message, _reply);
-	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
-	g_object_unref (invocation);
-	g_object_unref (_reply_message);
-}
-
-
-static void mpris_root_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	if (strcmp (method_name, "Quit") == 0) {
-		_dbus_mpris_root_Quit (object, parameters, invocation);
-	} else if (strcmp (method_name, "Raise") == 0) {
-		_dbus_mpris_root_Raise (object, parameters, invocation);
-	} else {
-		g_object_unref (invocation);
-	}
-}
-
-
-static GVariant* _dbus_mpris_root_get_HasTracklist (MprisRoot* self) {
-	gboolean result;
-	GVariant* _reply;
-	result = mpris_root_get_HasTracklist (self);
-	_reply = g_variant_new_boolean (result);
-	return _reply;
-}
-
-
-static GVariant* _dbus_mpris_root_get_CanQuit (MprisRoot* self) {
-	gboolean result;
-	GVariant* _reply;
-	result = mpris_root_get_CanQuit (self);
-	_reply = g_variant_new_boolean (result);
-	return _reply;
-}
-
-
-static GVariant* _dbus_mpris_root_get_CanRaise (MprisRoot* self) {
-	gboolean result;
-	GVariant* _reply;
-	result = mpris_root_get_CanRaise (self);
-	_reply = g_variant_new_boolean (result);
-	return _reply;
-}
-
-
-static GVariant* _dbus_mpris_root_get_Identity (MprisRoot* self) {
-	gchar* result;
-	GVariant* _reply;
-	result = mpris_root_get_Identity (self);
-	_reply = g_variant_new_string (result);
-	_g_free0 (result);
-	return _reply;
-}
-
-
-static GVariant* _dbus_mpris_root_get_DesktopEntry (MprisRoot* self) {
-	gchar* result;
-	GVariant* _reply;
-	result = mpris_root_get_DesktopEntry (self);
-	_reply = g_variant_new_string (result);
-	_g_free0 (result);
-	return _reply;
-}
-
-
-static GVariant* mpris_root_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	if (strcmp (property_name, "HasTracklist") == 0) {
-		return _dbus_mpris_root_get_HasTracklist (object);
-	} else if (strcmp (property_name, "CanQuit") == 0) {
-		return _dbus_mpris_root_get_CanQuit (object);
-	} else if (strcmp (property_name, "CanRaise") == 0) {
-		return _dbus_mpris_root_get_CanRaise (object);
-	} else if (strcmp (property_name, "Identity") == 0) {
-		return _dbus_mpris_root_get_Identity (object);
-	} else if (strcmp (property_name, "DesktopEntry") == 0) {
-		return _dbus_mpris_root_get_DesktopEntry (object);
-	}
-	return NULL;
-}
-
-
-static void _dbus_mpris_root_set_HasTracklist (MprisRoot* self, GVariant* _value) {
-	gboolean value = FALSE;
-	value = g_variant_get_boolean (_value);
-	mpris_root_set_HasTracklist (self, value);
-}
-
-
-static void _dbus_mpris_root_set_CanQuit (MprisRoot* self, GVariant* _value) {
-	gboolean value = FALSE;
-	value = g_variant_get_boolean (_value);
-	mpris_root_set_CanQuit (self, value);
-}
-
-
-static void _dbus_mpris_root_set_CanRaise (MprisRoot* self, GVariant* _value) {
-	gboolean value = FALSE;
-	value = g_variant_get_boolean (_value);
-	mpris_root_set_CanRaise (self, value);
-}
-
-
-static void _dbus_mpris_root_set_Identity (MprisRoot* self, GVariant* _value) {
-	gchar* value = NULL;
-	value = g_variant_dup_string (_value, NULL);
-	mpris_root_set_Identity (self, value);
-	_g_free0 (value);
-}
-
-
-static void _dbus_mpris_root_set_DesktopEntry (MprisRoot* self, GVariant* _value) {
-	gchar* value = NULL;
-	value = g_variant_dup_string (_value, NULL);
-	mpris_root_set_DesktopEntry (self, value);
-	_g_free0 (value);
-}
-
-
-static gboolean mpris_root_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	if (strcmp (property_name, "HasTracklist") == 0) {
-		_dbus_mpris_root_set_HasTracklist (object, value);
-		return TRUE;
-	} else if (strcmp (property_name, "CanQuit") == 0) {
-		_dbus_mpris_root_set_CanQuit (object, value);
-		return TRUE;
-	} else if (strcmp (property_name, "CanRaise") == 0) {
-		_dbus_mpris_root_set_CanRaise (object, value);
-		return TRUE;
-	} else if (strcmp (property_name, "Identity") == 0) {
-		_dbus_mpris_root_set_Identity (object, value);
-		return TRUE;
-	} else if (strcmp (property_name, "DesktopEntry") == 0) {
-		_dbus_mpris_root_set_DesktopEntry (object, value);
-		return TRUE;
-	}
-	return FALSE;
-}
-
-
-guint mpris_root_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
-	guint result;
-	gpointer *data;
-	data = g_new (gpointer, 3);
-	data[0] = g_object_ref (object);
-	data[1] = g_object_ref (connection);
-	data[2] = g_strdup (path);
-	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_mpris_root_dbus_interface_info), &_mpris_root_dbus_interface_vtable, data, _mpris_root_unregister_object, error);
-	if (!result) {
-		return 0;
-	}
-	return result;
-}
-
-
-static void _mpris_root_unregister_object (gpointer user_data) {
-	gpointer* data;
-	data = user_data;
-	g_object_unref (data[0]);
-	g_object_unref (data[1]);
-	g_free (data[2]);
-	g_free (data);
-}
-
-
-void mpris_player_PlayPause (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	MPRIS_PLAYER_GET_INTERFACE (self)->PlayPause (self, _callback_, _user_data_);
-}
-
-
-void mpris_player_PlayPause_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error) {
-	MPRIS_PLAYER_GET_INTERFACE (self)->PlayPause_finish (self, _res_, error);
-}
-
-
-void mpris_player_Next (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	MPRIS_PLAYER_GET_INTERFACE (self)->Next (self, _callback_, _user_data_);
-}
-
-
-void mpris_player_Next_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error) {
-	MPRIS_PLAYER_GET_INTERFACE (self)->Next_finish (self, _res_, error);
-}
-
-
-void mpris_player_Previous (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	MPRIS_PLAYER_GET_INTERFACE (self)->Previous (self, _callback_, _user_data_);
-}
-
-
-void mpris_player_Previous_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error) {
-	MPRIS_PLAYER_GET_INTERFACE (self)->Previous_finish (self, _res_, error);
-}
-
-
-void mpris_player_Seek (MprisPlayer* self, gint64 offset, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	MPRIS_PLAYER_GET_INTERFACE (self)->Seek (self, offset, _callback_, _user_data_);
-}
-
-
-void mpris_player_Seek_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error) {
-	MPRIS_PLAYER_GET_INTERFACE (self)->Seek_finish (self, _res_, error);
-}
-
-
-GHashTable* mpris_player_get_Metadata (MprisPlayer* self) {
-	g_return_val_if_fail (self != NULL, NULL);
-	return MPRIS_PLAYER_GET_INTERFACE (self)->get_Metadata (self);
-}
-
-
-void mpris_player_set_Metadata (MprisPlayer* self, GHashTable* value) {
-	g_return_if_fail (self != NULL);
-	MPRIS_PLAYER_GET_INTERFACE (self)->set_Metadata (self, value);
-}
-
-
-gint32 mpris_player_get_Position (MprisPlayer* self) {
-	g_return_val_if_fail (self != NULL, 0);
-	return MPRIS_PLAYER_GET_INTERFACE (self)->get_Position (self);
-}
-
-
-void mpris_player_set_Position (MprisPlayer* self, gint32 value) {
-	g_return_if_fail (self != NULL);
-	MPRIS_PLAYER_GET_INTERFACE (self)->set_Position (self, value);
-}
-
-
-gchar* mpris_player_get_PlaybackStatus (MprisPlayer* self) {
-	g_return_val_if_fail (self != NULL, NULL);
-	return MPRIS_PLAYER_GET_INTERFACE (self)->get_PlaybackStatus (self);
-}
-
-
-void mpris_player_set_PlaybackStatus (MprisPlayer* self, const gchar* value) {
-	g_return_if_fail (self != NULL);
-	MPRIS_PLAYER_GET_INTERFACE (self)->set_PlaybackStatus (self, value);
-}
-
-
-static void g_cclosure_user_marshal_VOID__INT64 (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
-	typedef void (*GMarshalFunc_VOID__INT64) (gpointer data1, gint64 arg_1, gpointer data2);
-	register GMarshalFunc_VOID__INT64 callback;
-	register GCClosure * cc;
-	register gpointer data1;
-	register gpointer data2;
-	cc = (GCClosure *) closure;
-	g_return_if_fail (n_param_values == 2);
-	if (G_CCLOSURE_SWAP_DATA (closure)) {
-		data1 = closure->data;
-		data2 = param_values->data[0].v_pointer;
-	} else {
-		data1 = param_values->data[0].v_pointer;
-		data2 = closure->data;
-	}
-	callback = (GMarshalFunc_VOID__INT64) (marshal_data ? marshal_data : cc->callback);
-	callback (data1, g_value_get_int64 (param_values + 1), data2);
-}
-
-
-static void mpris_player_base_init (MprisPlayerIface * iface) {
-	static gboolean initialized = FALSE;
-	if (!initialized) {
-		initialized = TRUE;
-		g_signal_new ("seeked", TYPE_MPRIS_PLAYER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__INT64, G_TYPE_NONE, 1, G_TYPE_INT64);
-	}
-}
-
-
-GType mpris_player_get_type (void) {
-	static volatile gsize mpris_player_type_id__volatile = 0;
-	if (g_once_init_enter (&mpris_player_type_id__volatile)) {
-		static const GTypeInfo g_define_type_info = { sizeof (MprisPlayerIface), (GBaseInitFunc) mpris_player_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
-		GType mpris_player_type_id;
-		mpris_player_type_id = g_type_register_static (G_TYPE_INTERFACE, "MprisPlayer", &g_define_type_info, 0);
-		g_type_interface_add_prerequisite (mpris_player_type_id, G_TYPE_OBJECT);
-		g_type_set_qdata (mpris_player_type_id, g_quark_from_static_string ("vala-dbus-proxy-type"), (void*) mpris_player_proxy_get_type);
-		g_type_set_qdata (mpris_player_type_id, g_quark_from_static_string ("vala-dbus-interface-name"), "org.mpris.MediaPlayer2.Player");
-		g_type_set_qdata (mpris_player_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) mpris_player_register_object);
-		g_once_init_leave (&mpris_player_type_id__volatile, mpris_player_type_id);
-	}
-	return mpris_player_type_id__volatile;
-}
-
-
-G_DEFINE_TYPE_EXTENDED (MprisPlayerProxy, mpris_player_proxy, G_TYPE_DBUS_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_MPRIS_PLAYER, mpris_player_proxy_mpris_player_interface_init) )
-static void mpris_player_proxy_class_init (MprisPlayerProxyClass* klass) {
-	G_DBUS_PROXY_CLASS (klass)->g_signal = mpris_player_proxy_g_signal;
-}
-
-
-static void _dbus_handle_mpris_player_seeked (MprisPlayer* self, GVariant* parameters) {
-	GVariantIter _arguments_iter;
-	gint64 new_position = 0LL;
-	GVariant* _tmp0_;
-	g_variant_iter_init (&_arguments_iter, parameters);
-	_tmp0_ = g_variant_iter_next_value (&_arguments_iter);
-	new_position = g_variant_get_int64 (_tmp0_);
-	g_variant_unref (_tmp0_);
-	g_signal_emit_by_name (self, "seeked", new_position);
-}
-
-
-static void mpris_player_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters) {
-	if (strcmp (signal_name, "Seeked") == 0) {
-		_dbus_handle_mpris_player_seeked ((MprisPlayer*) proxy, parameters);
-	}
-}
-
-
-static void mpris_player_proxy_init (MprisPlayerProxy* self) {
-}
-
-
-static void mpris_player_proxy_PlayPause_async (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	GDBusMessage *_message;
-	GVariant *_arguments;
-	GVariantBuilder _arguments_builder;
-	G_IO_ERROR;
-	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.mpris.MediaPlayer2.Player", "PlayPause");
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	g_dbus_message_set_body (_message, _arguments);
-	g_dbus_connection_send_message_with_reply (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, _vala_g_async_ready_callback, g_simple_async_result_new ((GObject *) self, _callback_, _user_data_, NULL));
-	g_object_unref (_message);
-}
-
-
-static void mpris_player_proxy_PlayPause_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error) {
-	GDBusMessage *_reply_message;
-	_reply_message = g_dbus_connection_send_message_with_reply_finish (g_dbus_proxy_get_connection ((GDBusProxy *) self), g_simple_async_result_get_op_res_gpointer ((GSimpleAsyncResult *) _res_), error);
-	if (!_reply_message) {
-		return;
-	}
-	if (g_dbus_message_to_gerror (_reply_message, error)) {
-		g_object_unref (_reply_message);
-		return;
-	}
-	g_object_unref (_reply_message);
-}
-
-
-static void mpris_player_proxy_Next_async (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	GDBusMessage *_message;
-	GVariant *_arguments;
-	GVariantBuilder _arguments_builder;
-	G_IO_ERROR;
-	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.mpris.MediaPlayer2.Player", "Next");
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	g_dbus_message_set_body (_message, _arguments);
-	g_dbus_connection_send_message_with_reply (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, _vala_g_async_ready_callback, g_simple_async_result_new ((GObject *) self, _callback_, _user_data_, NULL));
-	g_object_unref (_message);
-}
-
-
-static void mpris_player_proxy_Next_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error) {
-	GDBusMessage *_reply_message;
-	_reply_message = g_dbus_connection_send_message_with_reply_finish (g_dbus_proxy_get_connection ((GDBusProxy *) self), g_simple_async_result_get_op_res_gpointer ((GSimpleAsyncResult *) _res_), error);
-	if (!_reply_message) {
-		return;
-	}
-	if (g_dbus_message_to_gerror (_reply_message, error)) {
-		g_object_unref (_reply_message);
-		return;
-	}
-	g_object_unref (_reply_message);
-}
-
-
-static void mpris_player_proxy_Previous_async (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	GDBusMessage *_message;
-	GVariant *_arguments;
-	GVariantBuilder _arguments_builder;
-	G_IO_ERROR;
-	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.mpris.MediaPlayer2.Player", "Previous");
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	g_dbus_message_set_body (_message, _arguments);
-	g_dbus_connection_send_message_with_reply (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, _vala_g_async_ready_callback, g_simple_async_result_new ((GObject *) self, _callback_, _user_data_, NULL));
-	g_object_unref (_message);
-}
-
-
-static void mpris_player_proxy_Previous_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error) {
-	GDBusMessage *_reply_message;
-	_reply_message = g_dbus_connection_send_message_with_reply_finish (g_dbus_proxy_get_connection ((GDBusProxy *) self), g_simple_async_result_get_op_res_gpointer ((GSimpleAsyncResult *) _res_), error);
-	if (!_reply_message) {
-		return;
-	}
-	if (g_dbus_message_to_gerror (_reply_message, error)) {
-		g_object_unref (_reply_message);
-		return;
-	}
-	g_object_unref (_reply_message);
-}
-
-
-static void mpris_player_proxy_Seek_async (MprisPlayer* self, gint64 offset, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	GDBusMessage *_message;
-	GVariant *_arguments;
-	GVariantBuilder _arguments_builder;
-	G_IO_ERROR;
-	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.mpris.MediaPlayer2.Player", "Seek");
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_int64 (offset));
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	g_dbus_message_set_body (_message, _arguments);
-	g_dbus_connection_send_message_with_reply (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, _vala_g_async_ready_callback, g_simple_async_result_new ((GObject *) self, _callback_, _user_data_, NULL));
-	g_object_unref (_message);
-}
-
-
-static void mpris_player_proxy_Seek_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error) {
-	GDBusMessage *_reply_message;
-	_reply_message = g_dbus_connection_send_message_with_reply_finish (g_dbus_proxy_get_connection ((GDBusProxy *) self), g_simple_async_result_get_op_res_gpointer ((GSimpleAsyncResult *) _res_), error);
-	if (!_reply_message) {
-		return;
-	}
-	if (g_dbus_message_to_gerror (_reply_message, error)) {
-		g_object_unref (_reply_message);
-		return;
-	}
-	g_object_unref (_reply_message);
-}
-
-
-static GHashTable* mpris_player_dbus_proxy_get_Metadata (MprisPlayer* self) {
-	GVariant *_inner_reply;
-	GHashTable* _result;
-	GHashTable* _tmp1_;
-	GVariantIter _tmp2_;
-	GVariant* _tmp3_;
-	GVariant* _tmp4_;
-	_inner_reply = g_dbus_proxy_get_cached_property ((GDBusProxy *) self, "Metadata");
-	if (!_inner_reply) {
-		GVariant *_arguments;
-		GVariant *_reply;
-		GVariantBuilder _arguments_builder;
-		g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2.Player"));
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("Metadata"));
-		_arguments = g_variant_builder_end (&_arguments_builder);
-		_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Get", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-		if (!_reply) {
-			return NULL;
-		}
-		g_variant_get (_reply, "(v)", &_inner_reply);
-		g_variant_unref (_reply);
-	}
-	_tmp1_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
-	g_variant_iter_init (&_tmp2_, _inner_reply);
-	while (g_variant_iter_loop (&_tmp2_, "{?*}", &_tmp3_, &_tmp4_)) {
-		g_hash_table_insert (_tmp1_, g_variant_dup_string (_tmp3_, NULL), g_variant_get_variant (_tmp4_));
-	}
-	_result = _tmp1_;
-	g_variant_unref (_inner_reply);
-	return _result;
-}
-
-
-static void mpris_player_dbus_proxy_set_Metadata (MprisPlayer* self, GHashTable* value) {
-	GVariant *_arguments;
-	GVariant *_reply;
-	GVariantBuilder _arguments_builder;
-	GVariantBuilder _tmp5_;
-	GHashTableIter _tmp6_;
-	gpointer _tmp7_;
-	gpointer _tmp8_;
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2.Player"));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("Metadata"));
-	g_variant_builder_open (&_arguments_builder, G_VARIANT_TYPE_VARIANT);
-	g_hash_table_iter_init (&_tmp6_, value);
-	g_variant_builder_init (&_tmp5_, G_VARIANT_TYPE ("a{sv}"));
-	while (g_hash_table_iter_next (&_tmp6_, &_tmp7_, &_tmp8_)) {
-		gchar* _key;
-		GVariant* _value;
-		_key = (gchar*) _tmp7_;
-		_value = (GVariant*) _tmp8_;
-		g_variant_builder_add (&_tmp5_, "{?*}", g_variant_new_string (_key), g_variant_new_variant (_value));
-	}
-	g_variant_builder_add_value (&_arguments_builder, g_variant_builder_end (&_tmp5_));
-	g_variant_builder_close (&_arguments_builder);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Set", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-	if (!_reply) {
-		return;
-	}
-	g_variant_unref (_reply);
-}
-
-
-static gint32 mpris_player_dbus_proxy_get_Position (MprisPlayer* self) {
-	GVariant *_inner_reply;
-	gint32 _result;
-	_inner_reply = g_dbus_proxy_get_cached_property ((GDBusProxy *) self, "Position");
-	if (!_inner_reply) {
-		GVariant *_arguments;
-		GVariant *_reply;
-		GVariantBuilder _arguments_builder;
-		g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2.Player"));
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("Position"));
-		_arguments = g_variant_builder_end (&_arguments_builder);
-		_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Get", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-		if (!_reply) {
-			return 0;
-		}
-		g_variant_get (_reply, "(v)", &_inner_reply);
-		g_variant_unref (_reply);
-	}
-	_result = g_variant_get_int32 (_inner_reply);
-	g_variant_unref (_inner_reply);
-	return _result;
-}
-
-
-static void mpris_player_dbus_proxy_set_Position (MprisPlayer* self, gint32 value) {
-	GVariant *_arguments;
-	GVariant *_reply;
-	GVariantBuilder _arguments_builder;
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2.Player"));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("Position"));
-	g_variant_builder_open (&_arguments_builder, G_VARIANT_TYPE_VARIANT);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_int32 (value));
-	g_variant_builder_close (&_arguments_builder);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Set", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-	if (!_reply) {
-		return;
-	}
-	g_variant_unref (_reply);
-}
-
-
-static gchar* mpris_player_dbus_proxy_get_PlaybackStatus (MprisPlayer* self) {
-	GVariant *_inner_reply;
-	gchar* _result;
-	_inner_reply = g_dbus_proxy_get_cached_property ((GDBusProxy *) self, "PlaybackStatus");
-	if (!_inner_reply) {
-		GVariant *_arguments;
-		GVariant *_reply;
-		GVariantBuilder _arguments_builder;
-		g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2.Player"));
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("PlaybackStatus"));
-		_arguments = g_variant_builder_end (&_arguments_builder);
-		_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Get", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-		if (!_reply) {
-			return NULL;
-		}
-		g_variant_get (_reply, "(v)", &_inner_reply);
-		g_variant_unref (_reply);
-	}
-	_result = g_variant_dup_string (_inner_reply, NULL);
-	g_variant_unref (_inner_reply);
-	return _result;
-}
-
-
-static void mpris_player_dbus_proxy_set_PlaybackStatus (MprisPlayer* self, const gchar* value) {
-	GVariant *_arguments;
-	GVariant *_reply;
-	GVariantBuilder _arguments_builder;
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2.Player"));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("PlaybackStatus"));
-	g_variant_builder_open (&_arguments_builder, G_VARIANT_TYPE_VARIANT);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (value));
-	g_variant_builder_close (&_arguments_builder);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Set", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-	if (!_reply) {
-		return;
-	}
-	g_variant_unref (_reply);
-}
-
-
-static void mpris_player_proxy_mpris_player_interface_init (MprisPlayerIface* iface) {
-	iface->PlayPause = mpris_player_proxy_PlayPause_async;
-	iface->PlayPause_finish = mpris_player_proxy_PlayPause_finish;
-	iface->Next = mpris_player_proxy_Next_async;
-	iface->Next_finish = mpris_player_proxy_Next_finish;
-	iface->Previous = mpris_player_proxy_Previous_async;
-	iface->Previous_finish = mpris_player_proxy_Previous_finish;
-	iface->Seek = mpris_player_proxy_Seek_async;
-	iface->Seek_finish = mpris_player_proxy_Seek_finish;
-	iface->get_Metadata = mpris_player_dbus_proxy_get_Metadata;
-	iface->set_Metadata = mpris_player_dbus_proxy_set_Metadata;
-	iface->get_Position = mpris_player_dbus_proxy_get_Position;
-	iface->set_Position = mpris_player_dbus_proxy_set_Position;
-	iface->get_PlaybackStatus = mpris_player_dbus_proxy_get_PlaybackStatus;
-	iface->set_PlaybackStatus = mpris_player_dbus_proxy_set_PlaybackStatus;
-}
-
-
-static void _dbus_mpris_player_PlayPause (MprisPlayer* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
-	GVariantIter _arguments_iter;
-	g_variant_iter_init (&_arguments_iter, parameters);
-	mpris_player_PlayPause (self, (GAsyncReadyCallback) _dbus_mpris_player_PlayPause_ready, invocation);
-}
-
-
-static void _dbus_mpris_player_PlayPause_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
-	GDBusMethodInvocation * invocation;
-	GError* error = NULL;
-	GDBusMessage* _reply_message;
-	GVariant* _reply;
-	GVariantBuilder _reply_builder;
-	invocation = _user_data_;
-	mpris_player_PlayPause_finish ((MprisPlayer*) source_object, _res_, &error);
-	if (error) {
-		g_dbus_method_invocation_return_gerror (invocation, error);
-		return;
-	}
-	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
-	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
-	_reply = g_variant_builder_end (&_reply_builder);
-	g_dbus_message_set_body (_reply_message, _reply);
-	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
-	g_object_unref (invocation);
-	g_object_unref (_reply_message);
-}
-
-
-static void _dbus_mpris_player_Next (MprisPlayer* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
-	GVariantIter _arguments_iter;
-	g_variant_iter_init (&_arguments_iter, parameters);
-	mpris_player_Next (self, (GAsyncReadyCallback) _dbus_mpris_player_Next_ready, invocation);
-}
-
-
-static void _dbus_mpris_player_Next_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
-	GDBusMethodInvocation * invocation;
-	GError* error = NULL;
-	GDBusMessage* _reply_message;
-	GVariant* _reply;
-	GVariantBuilder _reply_builder;
-	invocation = _user_data_;
-	mpris_player_Next_finish ((MprisPlayer*) source_object, _res_, &error);
-	if (error) {
-		g_dbus_method_invocation_return_gerror (invocation, error);
-		return;
-	}
-	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
-	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
-	_reply = g_variant_builder_end (&_reply_builder);
-	g_dbus_message_set_body (_reply_message, _reply);
-	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
-	g_object_unref (invocation);
-	g_object_unref (_reply_message);
-}
-
-
-static void _dbus_mpris_player_Previous (MprisPlayer* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
-	GVariantIter _arguments_iter;
-	g_variant_iter_init (&_arguments_iter, parameters);
-	mpris_player_Previous (self, (GAsyncReadyCallback) _dbus_mpris_player_Previous_ready, invocation);
-}
-
-
-static void _dbus_mpris_player_Previous_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
-	GDBusMethodInvocation * invocation;
-	GError* error = NULL;
-	GDBusMessage* _reply_message;
-	GVariant* _reply;
-	GVariantBuilder _reply_builder;
-	invocation = _user_data_;
-	mpris_player_Previous_finish ((MprisPlayer*) source_object, _res_, &error);
-	if (error) {
-		g_dbus_method_invocation_return_gerror (invocation, error);
-		return;
-	}
-	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
-	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
-	_reply = g_variant_builder_end (&_reply_builder);
-	g_dbus_message_set_body (_reply_message, _reply);
-	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
-	g_object_unref (invocation);
-	g_object_unref (_reply_message);
-}
-
-
-static void _dbus_mpris_player_Seek (MprisPlayer* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
-	GVariantIter _arguments_iter;
-	gint64 offset = 0LL;
-	GVariant* _tmp9_;
-	g_variant_iter_init (&_arguments_iter, parameters);
-	_tmp9_ = g_variant_iter_next_value (&_arguments_iter);
-	offset = g_variant_get_int64 (_tmp9_);
-	g_variant_unref (_tmp9_);
-	mpris_player_Seek (self, offset, (GAsyncReadyCallback) _dbus_mpris_player_Seek_ready, invocation);
-}
-
-
-static void _dbus_mpris_player_Seek_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
-	GDBusMethodInvocation * invocation;
-	GError* error = NULL;
-	GDBusMessage* _reply_message;
-	GVariant* _reply;
-	GVariantBuilder _reply_builder;
-	invocation = _user_data_;
-	mpris_player_Seek_finish ((MprisPlayer*) source_object, _res_, &error);
-	if (error) {
-		g_dbus_method_invocation_return_gerror (invocation, error);
-		return;
-	}
-	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
-	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
-	_reply = g_variant_builder_end (&_reply_builder);
-	g_dbus_message_set_body (_reply_message, _reply);
-	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
-	g_object_unref (invocation);
-	g_object_unref (_reply_message);
-}
-
-
-static void mpris_player_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	if (strcmp (method_name, "PlayPause") == 0) {
-		_dbus_mpris_player_PlayPause (object, parameters, invocation);
-	} else if (strcmp (method_name, "Next") == 0) {
-		_dbus_mpris_player_Next (object, parameters, invocation);
-	} else if (strcmp (method_name, "Previous") == 0) {
-		_dbus_mpris_player_Previous (object, parameters, invocation);
-	} else if (strcmp (method_name, "Seek") == 0) {
-		_dbus_mpris_player_Seek (object, parameters, invocation);
-	} else {
-		g_object_unref (invocation);
-	}
-}
-
-
-static GVariant* _dbus_mpris_player_get_Metadata (MprisPlayer* self) {
-	GHashTable* result;
-	GVariantBuilder _tmp10_;
-	GHashTableIter _tmp11_;
-	gpointer _tmp12_;
-	gpointer _tmp13_;
-	GVariant* _reply;
-	result = mpris_player_get_Metadata (self);
-	g_hash_table_iter_init (&_tmp11_, result);
-	g_variant_builder_init (&_tmp10_, G_VARIANT_TYPE ("a{sv}"));
-	while (g_hash_table_iter_next (&_tmp11_, &_tmp12_, &_tmp13_)) {
-		gchar* _key;
-		GVariant* _value;
-		_key = (gchar*) _tmp12_;
-		_value = (GVariant*) _tmp13_;
-		g_variant_builder_add (&_tmp10_, "{?*}", g_variant_new_string (_key), g_variant_new_variant (_value));
-	}
-	_reply = g_variant_builder_end (&_tmp10_);
-	_g_hash_table_unref0 (result);
-	return _reply;
-}
-
-
-static GVariant* _dbus_mpris_player_get_Position (MprisPlayer* self) {
-	gint32 result;
-	GVariant* _reply;
-	result = mpris_player_get_Position (self);
-	_reply = g_variant_new_int32 (result);
-	return _reply;
-}
-
-
-static GVariant* _dbus_mpris_player_get_PlaybackStatus (MprisPlayer* self) {
-	gchar* result;
-	GVariant* _reply;
-	result = mpris_player_get_PlaybackStatus (self);
-	_reply = g_variant_new_string (result);
-	_g_free0 (result);
-	return _reply;
-}
-
-
-static GVariant* mpris_player_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	if (strcmp (property_name, "Metadata") == 0) {
-		return _dbus_mpris_player_get_Metadata (object);
-	} else if (strcmp (property_name, "Position") == 0) {
-		return _dbus_mpris_player_get_Position (object);
-	} else if (strcmp (property_name, "PlaybackStatus") == 0) {
-		return _dbus_mpris_player_get_PlaybackStatus (object);
-	}
-	return NULL;
-}
-
-
-static void _dbus_mpris_player_set_Metadata (MprisPlayer* self, GVariant* _value) {
-	GHashTable* value = NULL;
-	GHashTable* _tmp14_;
-	GVariantIter _tmp15_;
-	GVariant* _tmp16_;
-	GVariant* _tmp17_;
-	_tmp14_ = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
-	g_variant_iter_init (&_tmp15_, _value);
-	while (g_variant_iter_loop (&_tmp15_, "{?*}", &_tmp16_, &_tmp17_)) {
-		g_hash_table_insert (_tmp14_, g_variant_dup_string (_tmp16_, NULL), g_variant_get_variant (_tmp17_));
-	}
-	value = _tmp14_;
-	mpris_player_set_Metadata (self, value);
-	_g_hash_table_unref0 (value);
-}
-
-
-static void _dbus_mpris_player_set_Position (MprisPlayer* self, GVariant* _value) {
-	gint32 value = 0;
-	value = g_variant_get_int32 (_value);
-	mpris_player_set_Position (self, value);
-}
-
-
-static void _dbus_mpris_player_set_PlaybackStatus (MprisPlayer* self, GVariant* _value) {
-	gchar* value = NULL;
-	value = g_variant_dup_string (_value, NULL);
-	mpris_player_set_PlaybackStatus (self, value);
-	_g_free0 (value);
-}
-
-
-static gboolean mpris_player_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	if (strcmp (property_name, "Metadata") == 0) {
-		_dbus_mpris_player_set_Metadata (object, value);
-		return TRUE;
-	} else if (strcmp (property_name, "Position") == 0) {
-		_dbus_mpris_player_set_Position (object, value);
-		return TRUE;
-	} else if (strcmp (property_name, "PlaybackStatus") == 0) {
-		_dbus_mpris_player_set_PlaybackStatus (object, value);
-		return TRUE;
-	}
-	return FALSE;
-}
-
-
-static void _dbus_mpris_player_seeked (GObject* _sender, gint64 new_position, gpointer* _data) {
-	GDBusConnection * _connection;
-	const gchar * _path;
-	GVariant *_arguments;
-	GVariantBuilder _arguments_builder;
-	_connection = _data[1];
-	_path = _data[2];
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_int64 (new_position));
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.mpris.MediaPlayer2.Player", "Seeked", _arguments, NULL);
-}
-
-
-guint mpris_player_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
-	guint result;
-	gpointer *data;
-	data = g_new (gpointer, 3);
-	data[0] = g_object_ref (object);
-	data[1] = g_object_ref (connection);
-	data[2] = g_strdup (path);
-	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_mpris_player_dbus_interface_info), &_mpris_player_dbus_interface_vtable, data, _mpris_player_unregister_object, error);
-	if (!result) {
-		return 0;
-	}
-	g_signal_connect (object, "seeked", (GCallback) _dbus_mpris_player_seeked, data);
-	return result;
-}
-
-
-static void _mpris_player_unregister_object (gpointer user_data) {
-	gpointer* data;
-	data = user_data;
-	g_signal_handlers_disconnect_by_func (data[0], _dbus_mpris_player_seeked, data);
-	g_object_unref (data[0]);
-	g_object_unref (data[1]);
-	g_free (data[2]);
-	g_free (data);
-}
-
-
-void playlist_details_copy (const PlaylistDetails* self, PlaylistDetails* dest) {
-	const char* _tmp0_;
-	char* _tmp1_;
-	const gchar* _tmp2_;
-	gchar* _tmp3_;
-	const gchar* _tmp4_;
-	gchar* _tmp5_;
-	_tmp0_ = (*self).path;
-	_tmp1_ = g_strdup (_tmp0_);
-	_g_free0 ((*dest).path);
-	(*dest).path = _tmp1_;
-	_tmp2_ = (*self).name;
-	_tmp3_ = g_strdup (_tmp2_);
-	_g_free0 ((*dest).name);
-	(*dest).name = _tmp3_;
-	_tmp4_ = (*self).icon_path;
-	_tmp5_ = g_strdup (_tmp4_);
-	_g_free0 ((*dest).icon_path);
-	(*dest).icon_path = _tmp5_;
-}
-
-
-void playlist_details_destroy (PlaylistDetails* self) {
-	_g_free0 ((*self).path);
-	_g_free0 ((*self).name);
-	_g_free0 ((*self).icon_path);
-}
-
-
-PlaylistDetails* playlist_details_dup (const PlaylistDetails* self) {
-	PlaylistDetails* dup;
-	dup = g_new0 (PlaylistDetails, 1);
-	playlist_details_copy (self, dup);
-	return dup;
-}
-
-
-void playlist_details_free (PlaylistDetails* self) {
-	playlist_details_destroy (self);
-	g_free (self);
-}
-
-
-GType playlist_details_get_type (void) {
-	static volatile gsize playlist_details_type_id__volatile = 0;
-	if (g_once_init_enter (&playlist_details_type_id__volatile)) {
-		GType playlist_details_type_id;
-		playlist_details_type_id = g_boxed_type_register_static ("PlaylistDetails", (GBoxedCopyFunc) playlist_details_dup, (GBoxedFreeFunc) playlist_details_free);
-		g_once_init_leave (&playlist_details_type_id__volatile, playlist_details_type_id);
-	}
-	return playlist_details_type_id__volatile;
-}
-
-
-static gpointer _playlist_details_dup0 (gpointer self) {
-	return self ? playlist_details_dup (self) : NULL;
-}
-
-
-void active_playlist_container_copy (const ActivePlaylistContainer* self, ActivePlaylistContainer* dest) {
-	gboolean _tmp0_;
-	PlaylistDetails* _tmp1_;
-	PlaylistDetails* _tmp2_;
-	_tmp0_ = (*self).valid;
-	(*dest).valid = _tmp0_;
-	_tmp1_ = (*self).details;
-	_tmp2_ = _playlist_details_dup0 (_tmp1_);
-	_playlist_details_free0 ((*dest).details);
-	(*dest).details = _tmp2_;
-}
-
-
-void active_playlist_container_destroy (ActivePlaylistContainer* self) {
-	_playlist_details_free0 ((*self).details);
-}
-
-
-ActivePlaylistContainer* active_playlist_container_dup (const ActivePlaylistContainer* self) {
-	ActivePlaylistContainer* dup;
-	dup = g_new0 (ActivePlaylistContainer, 1);
-	active_playlist_container_copy (self, dup);
-	return dup;
-}
-
-
-void active_playlist_container_free (ActivePlaylistContainer* self) {
-	active_playlist_container_destroy (self);
-	g_free (self);
-}
-
-
-GType active_playlist_container_get_type (void) {
-	static volatile gsize active_playlist_container_type_id__volatile = 0;
-	if (g_once_init_enter (&active_playlist_container_type_id__volatile)) {
-		GType active_playlist_container_type_id;
-		active_playlist_container_type_id = g_boxed_type_register_static ("ActivePlaylistContainer", (GBoxedCopyFunc) active_playlist_container_dup, (GBoxedFreeFunc) active_playlist_container_free);
-		g_once_init_leave (&active_playlist_container_type_id__volatile, active_playlist_container_type_id);
-	}
-	return active_playlist_container_type_id__volatile;
-}
-
-
-void mpris_playlists_ActivatePlaylist (MprisPlaylists* self, const char* playlist_id, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	MPRIS_PLAYLISTS_GET_INTERFACE (self)->ActivatePlaylist (self, playlist_id, _callback_, _user_data_);
-}
-
-
-void mpris_playlists_ActivatePlaylist_finish (MprisPlaylists* self, GAsyncResult* _res_, GError** error) {
-	MPRIS_PLAYLISTS_GET_INTERFACE (self)->ActivatePlaylist_finish (self, _res_, error);
-}
-
-
-void mpris_playlists_GetPlaylists (MprisPlaylists* self, guint32 index, guint32 max_count, const gchar* order, gboolean reverse_order, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	MPRIS_PLAYLISTS_GET_INTERFACE (self)->GetPlaylists (self, index, max_count, order, reverse_order, _callback_, _user_data_);
-}
-
-
-PlaylistDetails* mpris_playlists_GetPlaylists_finish (MprisPlaylists* self, GAsyncResult* _res_, int* result_length1, GError** error) {
-	return MPRIS_PLAYLISTS_GET_INTERFACE (self)->GetPlaylists_finish (self, _res_, result_length1, error);
-}
-
-
-gchar** mpris_playlists_get_Orderings (MprisPlaylists* self, int* result_length1) {
-	g_return_val_if_fail (self != NULL, NULL);
-	return MPRIS_PLAYLISTS_GET_INTERFACE (self)->get_Orderings (self, result_length1);
-}
-
-
-void mpris_playlists_set_Orderings (MprisPlaylists* self, gchar** value, int value_length1) {
-	g_return_if_fail (self != NULL);
-	MPRIS_PLAYLISTS_GET_INTERFACE (self)->set_Orderings (self, value, value_length1);
-}
-
-
-guint32 mpris_playlists_get_PlaylistCount (MprisPlaylists* self) {
-	g_return_val_if_fail (self != NULL, 0U);
-	return MPRIS_PLAYLISTS_GET_INTERFACE (self)->get_PlaylistCount (self);
-}
-
-
-void mpris_playlists_set_PlaylistCount (MprisPlaylists* self, guint32 value) {
-	g_return_if_fail (self != NULL);
-	MPRIS_PLAYLISTS_GET_INTERFACE (self)->set_PlaylistCount (self, value);
-}
-
-
-ActivePlaylistContainer* mpris_playlists_get_ActivePlaylist (MprisPlaylists* self) {
-	g_return_val_if_fail (self != NULL, NULL);
-	return MPRIS_PLAYLISTS_GET_INTERFACE (self)->get_ActivePlaylist (self);
-}
-
-
-void mpris_playlists_set_ActivePlaylist (MprisPlaylists* self, ActivePlaylistContainer* value) {
-	g_return_if_fail (self != NULL);
-	MPRIS_PLAYLISTS_GET_INTERFACE (self)->set_ActivePlaylist (self, value);
-}
-
-
-static void g_cclosure_user_marshal_VOID__BOXED (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
-	typedef void (*GMarshalFunc_VOID__BOXED) (gpointer data1, gpointer arg_1, gpointer data2);
-	register GMarshalFunc_VOID__BOXED callback;
-	register GCClosure * cc;
-	register gpointer data1;
-	register gpointer data2;
-	cc = (GCClosure *) closure;
-	g_return_if_fail (n_param_values == 2);
-	if (G_CCLOSURE_SWAP_DATA (closure)) {
-		data1 = closure->data;
-		data2 = param_values->data[0].v_pointer;
-	} else {
-		data1 = param_values->data[0].v_pointer;
-		data2 = closure->data;
-	}
-	callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc->callback);
-	callback (data1, g_value_get_boxed (param_values + 1), data2);
-}
-
-
-static void mpris_playlists_base_init (MprisPlaylistsIface * iface) {
-	static gboolean initialized = FALSE;
-	if (!initialized) {
-		initialized = TRUE;
-		g_signal_new ("playlist_changed", TYPE_MPRIS_PLAYLISTS, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED, G_TYPE_NONE, 1, TYPE_PLAYLIST_DETAILS);
-	}
-}
-
-
-GType mpris_playlists_get_type (void) {
-	static volatile gsize mpris_playlists_type_id__volatile = 0;
-	if (g_once_init_enter (&mpris_playlists_type_id__volatile)) {
-		static const GTypeInfo g_define_type_info = { sizeof (MprisPlaylistsIface), (GBaseInitFunc) mpris_playlists_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
-		GType mpris_playlists_type_id;
-		mpris_playlists_type_id = g_type_register_static (G_TYPE_INTERFACE, "MprisPlaylists", &g_define_type_info, 0);
-		g_type_interface_add_prerequisite (mpris_playlists_type_id, G_TYPE_OBJECT);
-		g_type_set_qdata (mpris_playlists_type_id, g_quark_from_static_string ("vala-dbus-proxy-type"), (void*) mpris_playlists_proxy_get_type);
-		g_type_set_qdata (mpris_playlists_type_id, g_quark_from_static_string ("vala-dbus-interface-name"), "org.mpris.MediaPlayer2.Playlists");
-		g_type_set_qdata (mpris_playlists_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) mpris_playlists_register_object);
-		g_once_init_leave (&mpris_playlists_type_id__volatile, mpris_playlists_type_id);
-	}
-	return mpris_playlists_type_id__volatile;
-}
-
-
-G_DEFINE_TYPE_EXTENDED (MprisPlaylistsProxy, mpris_playlists_proxy, G_TYPE_DBUS_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_MPRIS_PLAYLISTS, mpris_playlists_proxy_mpris_playlists_interface_init) )
-static void mpris_playlists_proxy_class_init (MprisPlaylistsProxyClass* klass) {
-	G_DBUS_PROXY_CLASS (klass)->g_signal = mpris_playlists_proxy_g_signal;
-}
-
-
-static void _dbus_handle_mpris_playlists_playlist_changed (MprisPlaylists* self, GVariant* parameters) {
-	GVariantIter _arguments_iter;
-	PlaylistDetails details = {0};
-	GVariant* _tmp18_;
-	PlaylistDetails _tmp19_;
-	GVariantIter _tmp20_;
-	GVariant* _tmp21_;
-	GVariant* _tmp22_;
-	GVariant* _tmp23_;
-	g_variant_iter_init (&_arguments_iter, parameters);
-	_tmp18_ = g_variant_iter_next_value (&_arguments_iter);
-	g_variant_iter_init (&_tmp20_, _tmp18_);
-	_tmp21_ = g_variant_iter_next_value (&_tmp20_);
-	_tmp19_.path = g_variant_dup_string (_tmp21_, NULL);
-	g_variant_unref (_tmp21_);
-	_tmp22_ = g_variant_iter_next_value (&_tmp20_);
-	_tmp19_.name = g_variant_dup_string (_tmp22_, NULL);
-	g_variant_unref (_tmp22_);
-	_tmp23_ = g_variant_iter_next_value (&_tmp20_);
-	_tmp19_.icon_path = g_variant_dup_string (_tmp23_, NULL);
-	g_variant_unref (_tmp23_);
-	details = _tmp19_;
-	g_variant_unref (_tmp18_);
-	g_signal_emit_by_name (self, "playlist-changed", &details);
-	playlist_details_destroy (&details);
-}
-
-
-static void mpris_playlists_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters) {
-	if (strcmp (signal_name, "PlaylistChanged") == 0) {
-		_dbus_handle_mpris_playlists_playlist_changed ((MprisPlaylists*) proxy, parameters);
-	}
-}
-
-
-static void mpris_playlists_proxy_init (MprisPlaylistsProxy* self) {
-}
-
-
-static void mpris_playlists_proxy_ActivatePlaylist_async (MprisPlaylists* self, const char* playlist_id, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	GDBusMessage *_message;
-	GVariant *_arguments;
-	GVariantBuilder _arguments_builder;
-	G_IO_ERROR;
-	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.mpris.MediaPlayer2.Playlists", "ActivatePlaylist");
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_object_path (playlist_id));
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	g_dbus_message_set_body (_message, _arguments);
-	g_dbus_connection_send_message_with_reply (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, _vala_g_async_ready_callback, g_simple_async_result_new ((GObject *) self, _callback_, _user_data_, NULL));
-	g_object_unref (_message);
-}
-
-
-static void mpris_playlists_proxy_ActivatePlaylist_finish (MprisPlaylists* self, GAsyncResult* _res_, GError** error) {
-	GDBusMessage *_reply_message;
-	_reply_message = g_dbus_connection_send_message_with_reply_finish (g_dbus_proxy_get_connection ((GDBusProxy *) self), g_simple_async_result_get_op_res_gpointer ((GSimpleAsyncResult *) _res_), error);
-	if (!_reply_message) {
-		return;
-	}
-	if (g_dbus_message_to_gerror (_reply_message, error)) {
-		g_object_unref (_reply_message);
-		return;
-	}
-	g_object_unref (_reply_message);
-}
-
-
-static void mpris_playlists_proxy_GetPlaylists_async (MprisPlaylists* self, guint32 index, guint32 max_count, const gchar* order, gboolean reverse_order, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	GDBusMessage *_message;
-	GVariant *_arguments;
-	GVariantBuilder _arguments_builder;
-	G_IO_ERROR;
-	_message = g_dbus_message_new_method_call (g_dbus_proxy_get_name ((GDBusProxy *) self), g_dbus_proxy_get_object_path ((GDBusProxy *) self), "org.mpris.MediaPlayer2.Playlists", "GetPlaylists");
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_uint32 (index));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_uint32 (max_count));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string (order));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_boolean (reverse_order));
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	g_dbus_message_set_body (_message, _arguments);
-	g_dbus_connection_send_message_with_reply (g_dbus_proxy_get_connection ((GDBusProxy *) self), _message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, g_dbus_proxy_get_default_timeout ((GDBusProxy *) self), NULL, NULL, _vala_g_async_ready_callback, g_simple_async_result_new ((GObject *) self, _callback_, _user_data_, NULL));
-	g_object_unref (_message);
-}
-
-
-static PlaylistDetails* mpris_playlists_proxy_GetPlaylists_finish (MprisPlaylists* self, GAsyncResult* _res_, int* result_length1, GError** error) {
-	GDBusMessage *_reply_message;
-	GVariant *_reply;
-	GVariantIter _reply_iter;
-	PlaylistDetails* _result;
-	int _result_length1;
-	GVariant* _tmp24_;
-	PlaylistDetails* _tmp25_;
-	int _tmp25__length;
-	int _tmp25__size;
-	int _tmp25__length1;
-	GVariantIter _tmp26_;
-	GVariant* _tmp27_;
-	_reply_message = g_dbus_connection_send_message_with_reply_finish (g_dbus_proxy_get_connection ((GDBusProxy *) self), g_simple_async_result_get_op_res_gpointer ((GSimpleAsyncResult *) _res_), error);
-	if (!_reply_message) {
-		return NULL;
-	}
-	if (g_dbus_message_to_gerror (_reply_message, error)) {
-		g_object_unref (_reply_message);
-		return NULL;
-	}
-	_reply = g_dbus_message_get_body (_reply_message);
-	g_variant_iter_init (&_reply_iter, _reply);
-	_result_length1 = 0;
-	_tmp24_ = g_variant_iter_next_value (&_reply_iter);
-	_tmp25_ = g_new (PlaylistDetails, 5);
-	_tmp25__length = 0;
-	_tmp25__size = 4;
-	_tmp25__length1 = 0;
-	g_variant_iter_init (&_tmp26_, _tmp24_);
-	for (; (_tmp27_ = g_variant_iter_next_value (&_tmp26_)) != NULL; _tmp25__length1++) {
-		PlaylistDetails _tmp28_;
-		GVariantIter _tmp29_;
-		GVariant* _tmp30_;
-		GVariant* _tmp31_;
-		GVariant* _tmp32_;
-		if (_tmp25__size == _tmp25__length) {
-			_tmp25__size = 2 * _tmp25__size;
-			_tmp25_ = g_renew (PlaylistDetails, _tmp25_, _tmp25__size + 1);
-		}
-		g_variant_iter_init (&_tmp29_, _tmp27_);
-		_tmp30_ = g_variant_iter_next_value (&_tmp29_);
-		_tmp28_.path = g_variant_dup_string (_tmp30_, NULL);
-		g_variant_unref (_tmp30_);
-		_tmp31_ = g_variant_iter_next_value (&_tmp29_);
-		_tmp28_.name = g_variant_dup_string (_tmp31_, NULL);
-		g_variant_unref (_tmp31_);
-		_tmp32_ = g_variant_iter_next_value (&_tmp29_);
-		_tmp28_.icon_path = g_variant_dup_string (_tmp32_, NULL);
-		g_variant_unref (_tmp32_);
-		_tmp25_[_tmp25__length++] = _tmp28_;
-		g_variant_unref (_tmp27_);
-	}
-	_result_length1 = _tmp25__length1;
-	_result = _tmp25_;
-	g_variant_unref (_tmp24_);
-	*result_length1 = _result_length1;
-	g_object_unref (_reply_message);
-	return _result;
-}
-
-
-static gchar** mpris_playlists_dbus_proxy_get_Orderings (MprisPlaylists* self, int* result_length1) {
-	GVariant *_inner_reply;
-	gchar** _result;
-	int _result_length1;
-	gchar** _tmp33_;
-	int _tmp33__length;
-	int _tmp33__size;
-	int _tmp33__length1;
-	GVariantIter _tmp34_;
-	GVariant* _tmp35_;
-	_inner_reply = g_dbus_proxy_get_cached_property ((GDBusProxy *) self, "Orderings");
-	if (!_inner_reply) {
-		GVariant *_arguments;
-		GVariant *_reply;
-		GVariantBuilder _arguments_builder;
-		g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2.Playlists"));
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("Orderings"));
-		_arguments = g_variant_builder_end (&_arguments_builder);
-		_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Get", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-		if (!_reply) {
-			return NULL;
-		}
-		g_variant_get (_reply, "(v)", &_inner_reply);
-		g_variant_unref (_reply);
-	}
-	_result_length1 = 0;
-	_tmp33_ = g_new (gchar*, 5);
-	_tmp33__length = 0;
-	_tmp33__size = 4;
-	_tmp33__length1 = 0;
-	g_variant_iter_init (&_tmp34_, _inner_reply);
-	for (; (_tmp35_ = g_variant_iter_next_value (&_tmp34_)) != NULL; _tmp33__length1++) {
-		if (_tmp33__size == _tmp33__length) {
-			_tmp33__size = 2 * _tmp33__size;
-			_tmp33_ = g_renew (gchar*, _tmp33_, _tmp33__size + 1);
-		}
-		_tmp33_[_tmp33__length++] = g_variant_dup_string (_tmp35_, NULL);
-		g_variant_unref (_tmp35_);
-	}
-	_result_length1 = _tmp33__length1;
-	_tmp33_[_tmp33__length] = NULL;
-	_result = _tmp33_;
-	*result_length1 = _result_length1;
-	g_variant_unref (_inner_reply);
-	return _result;
-}
-
-
-static void mpris_playlists_dbus_proxy_set_Orderings (MprisPlaylists* self, gchar** value, int value_length1) {
-	GVariant *_arguments;
-	GVariant *_reply;
-	GVariantBuilder _arguments_builder;
-	gchar** _tmp36_;
-	GVariantBuilder _tmp37_;
-	int _tmp38_;
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2.Playlists"));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("Orderings"));
-	g_variant_builder_open (&_arguments_builder, G_VARIANT_TYPE_VARIANT);
-	_tmp36_ = value;
-	g_variant_builder_init (&_tmp37_, G_VARIANT_TYPE ("as"));
-	for (_tmp38_ = 0; _tmp38_ < value_length1; _tmp38_++) {
-		g_variant_builder_add_value (&_tmp37_, g_variant_new_string (*_tmp36_));
-		_tmp36_++;
-	}
-	g_variant_builder_add_value (&_arguments_builder, g_variant_builder_end (&_tmp37_));
-	g_variant_builder_close (&_arguments_builder);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Set", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-	if (!_reply) {
-		return;
-	}
-	g_variant_unref (_reply);
-}
-
-
-static guint32 mpris_playlists_dbus_proxy_get_PlaylistCount (MprisPlaylists* self) {
-	GVariant *_inner_reply;
-	guint32 _result;
-	_inner_reply = g_dbus_proxy_get_cached_property ((GDBusProxy *) self, "PlaylistCount");
-	if (!_inner_reply) {
-		GVariant *_arguments;
-		GVariant *_reply;
-		GVariantBuilder _arguments_builder;
-		g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2.Playlists"));
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("PlaylistCount"));
-		_arguments = g_variant_builder_end (&_arguments_builder);
-		_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Get", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-		if (!_reply) {
-			return 0U;
-		}
-		g_variant_get (_reply, "(v)", &_inner_reply);
-		g_variant_unref (_reply);
-	}
-	_result = g_variant_get_uint32 (_inner_reply);
-	g_variant_unref (_inner_reply);
-	return _result;
-}
-
-
-static void mpris_playlists_dbus_proxy_set_PlaylistCount (MprisPlaylists* self, guint32 value) {
-	GVariant *_arguments;
-	GVariant *_reply;
-	GVariantBuilder _arguments_builder;
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2.Playlists"));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("PlaylistCount"));
-	g_variant_builder_open (&_arguments_builder, G_VARIANT_TYPE_VARIANT);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_uint32 (value));
-	g_variant_builder_close (&_arguments_builder);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Set", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-	if (!_reply) {
-		return;
-	}
-	g_variant_unref (_reply);
-}
-
-
-static ActivePlaylistContainer* mpris_playlists_dbus_proxy_get_ActivePlaylist (MprisPlaylists* self) {
-	GVariant *_inner_reply;
-	ActivePlaylistContainer* _result;
-	ActivePlaylistContainer _tmp39_;
-	GVariantIter _tmp40_;
-	GVariant* _tmp41_;
-	GVariant* _tmp42_;
-	PlaylistDetails _tmp43_;
-	GVariantIter _tmp44_;
-	GVariant* _tmp45_;
-	GVariant* _tmp46_;
-	GVariant* _tmp47_;
-	_inner_reply = g_dbus_proxy_get_cached_property ((GDBusProxy *) self, "ActivePlaylist");
-	if (!_inner_reply) {
-		GVariant *_arguments;
-		GVariant *_reply;
-		GVariantBuilder _arguments_builder;
-		g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2.Playlists"));
-		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("ActivePlaylist"));
-		_arguments = g_variant_builder_end (&_arguments_builder);
-		_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Get", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-		if (!_reply) {
-			return NULL;
-		}
-		g_variant_get (_reply, "(v)", &_inner_reply);
-		g_variant_unref (_reply);
-	}
-	g_variant_iter_init (&_tmp40_, _inner_reply);
-	_tmp41_ = g_variant_iter_next_value (&_tmp40_);
-	_tmp39_.valid = g_variant_get_boolean (_tmp41_);
-	g_variant_unref (_tmp41_);
-	_tmp42_ = g_variant_iter_next_value (&_tmp40_);
-	g_variant_iter_init (&_tmp44_, _tmp42_);
-	_tmp45_ = g_variant_iter_next_value (&_tmp44_);
-	_tmp43_.path = g_variant_dup_string (_tmp45_, NULL);
-	g_variant_unref (_tmp45_);
-	_tmp46_ = g_variant_iter_next_value (&_tmp44_);
-	_tmp43_.name = g_variant_dup_string (_tmp46_, NULL);
-	g_variant_unref (_tmp46_);
-	_tmp47_ = g_variant_iter_next_value (&_tmp44_);
-	_tmp43_.icon_path = g_variant_dup_string (_tmp47_, NULL);
-	g_variant_unref (_tmp47_);
-	_tmp39_.details = g_memdup (&_tmp43_, sizeof (PlaylistDetails));
-	g_variant_unref (_tmp42_);
-	_result = g_memdup (&_tmp39_, sizeof (ActivePlaylistContainer));
-	g_variant_unref (_inner_reply);
-	return _result;
-}
-
-
-static void mpris_playlists_dbus_proxy_set_ActivePlaylist (MprisPlaylists* self, ActivePlaylistContainer* value) {
-	GVariant *_arguments;
-	GVariant *_reply;
-	GVariantBuilder _arguments_builder;
-	GVariantBuilder _tmp48_;
-	GVariantBuilder _tmp49_;
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.mpris.MediaPlayer2.Playlists"));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("ActivePlaylist"));
-	g_variant_builder_open (&_arguments_builder, G_VARIANT_TYPE_VARIANT);
-	g_variant_builder_init (&_tmp48_, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_tmp48_, g_variant_new_boolean ((*value).valid));
-	g_variant_builder_init (&_tmp49_, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_tmp49_, g_variant_new_object_path ((*(*value).details).path));
-	g_variant_builder_add_value (&_tmp49_, g_variant_new_string ((*(*value).details).name));
-	g_variant_builder_add_value (&_tmp49_, g_variant_new_string ((*(*value).details).icon_path));
-	g_variant_builder_add_value (&_tmp48_, g_variant_builder_end (&_tmp49_));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_builder_end (&_tmp48_));
-	g_variant_builder_close (&_arguments_builder);
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Set", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
-	if (!_reply) {
-		return;
-	}
-	g_variant_unref (_reply);
-}
-
-
-static void mpris_playlists_proxy_mpris_playlists_interface_init (MprisPlaylistsIface* iface) {
-	iface->ActivatePlaylist = mpris_playlists_proxy_ActivatePlaylist_async;
-	iface->ActivatePlaylist_finish = mpris_playlists_proxy_ActivatePlaylist_finish;
-	iface->GetPlaylists = mpris_playlists_proxy_GetPlaylists_async;
-	iface->GetPlaylists_finish = mpris_playlists_proxy_GetPlaylists_finish;
-	iface->get_Orderings = mpris_playlists_dbus_proxy_get_Orderings;
-	iface->set_Orderings = mpris_playlists_dbus_proxy_set_Orderings;
-	iface->get_PlaylistCount = mpris_playlists_dbus_proxy_get_PlaylistCount;
-	iface->set_PlaylistCount = mpris_playlists_dbus_proxy_set_PlaylistCount;
-	iface->get_ActivePlaylist = mpris_playlists_dbus_proxy_get_ActivePlaylist;
-	iface->set_ActivePlaylist = mpris_playlists_dbus_proxy_set_ActivePlaylist;
-}
-
-
-static void _dbus_mpris_playlists_ActivatePlaylist (MprisPlaylists* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
-	GVariantIter _arguments_iter;
-	char* playlist_id = NULL;
-	GVariant* _tmp50_;
-	g_variant_iter_init (&_arguments_iter, parameters);
-	_tmp50_ = g_variant_iter_next_value (&_arguments_iter);
-	playlist_id = g_variant_dup_string (_tmp50_, NULL);
-	g_variant_unref (_tmp50_);
-	mpris_playlists_ActivatePlaylist (self, playlist_id, (GAsyncReadyCallback) _dbus_mpris_playlists_ActivatePlaylist_ready, invocation);
-	_g_free0 (playlist_id);
-}
-
-
-static void _dbus_mpris_playlists_ActivatePlaylist_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
-	GDBusMethodInvocation * invocation;
-	GError* error = NULL;
-	GDBusMessage* _reply_message;
-	GVariant* _reply;
-	GVariantBuilder _reply_builder;
-	invocation = _user_data_;
-	mpris_playlists_ActivatePlaylist_finish ((MprisPlaylists*) source_object, _res_, &error);
-	if (error) {
-		g_dbus_method_invocation_return_gerror (invocation, error);
-		return;
-	}
-	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
-	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
-	_reply = g_variant_builder_end (&_reply_builder);
-	g_dbus_message_set_body (_reply_message, _reply);
-	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
-	g_object_unref (invocation);
-	g_object_unref (_reply_message);
-}
-
-
-static void _dbus_mpris_playlists_GetPlaylists (MprisPlaylists* self, GVariant* parameters, GDBusMethodInvocation* invocation) {
-	GVariantIter _arguments_iter;
-	guint32 index = 0U;
-	GVariant* _tmp51_;
-	guint32 max_count = 0U;
-	GVariant* _tmp52_;
-	gchar* order = NULL;
-	GVariant* _tmp53_;
-	gboolean reverse_order = FALSE;
-	GVariant* _tmp54_;
-	g_variant_iter_init (&_arguments_iter, parameters);
-	_tmp51_ = g_variant_iter_next_value (&_arguments_iter);
-	index = g_variant_get_uint32 (_tmp51_);
-	g_variant_unref (_tmp51_);
-	_tmp52_ = g_variant_iter_next_value (&_arguments_iter);
-	max_count = g_variant_get_uint32 (_tmp52_);
-	g_variant_unref (_tmp52_);
-	_tmp53_ = g_variant_iter_next_value (&_arguments_iter);
-	order = g_variant_dup_string (_tmp53_, NULL);
-	g_variant_unref (_tmp53_);
-	_tmp54_ = g_variant_iter_next_value (&_arguments_iter);
-	reverse_order = g_variant_get_boolean (_tmp54_);
-	g_variant_unref (_tmp54_);
-	mpris_playlists_GetPlaylists (self, index, max_count, order, reverse_order, (GAsyncReadyCallback) _dbus_mpris_playlists_GetPlaylists_ready, invocation);
-	_g_free0 (order);
-}
-
-
-static void _vala_PlaylistDetails_array_free (PlaylistDetails* array, gint array_length) {
-	if (array != NULL) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			playlist_details_destroy (&array[i]);
-		}
-	}
-	g_free (array);
-}
-
-
-static void _dbus_mpris_playlists_GetPlaylists_ready (GObject * source_object, GAsyncResult * _res_, gpointer _user_data_) {
-	GDBusMethodInvocation * invocation;
-	GError* error = NULL;
-	GDBusMessage* _reply_message;
-	GVariant* _reply;
-	GVariantBuilder _reply_builder;
-	PlaylistDetails* result;
-	int result_length1 = 0;
-	PlaylistDetails* _tmp55_;
-	GVariantBuilder _tmp56_;
-	int _tmp57_;
-	invocation = _user_data_;
-	result = mpris_playlists_GetPlaylists_finish ((MprisPlaylists*) source_object, _res_, &result_length1, &error);
-	if (error) {
-		g_dbus_method_invocation_return_gerror (invocation, error);
-		return;
-	}
-	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
-	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
-	_tmp55_ = result;
-	g_variant_builder_init (&_tmp56_, G_VARIANT_TYPE ("a(oss)"));
-	for (_tmp57_ = 0; _tmp57_ < result_length1; _tmp57_++) {
-		GVariantBuilder _tmp58_;
-		g_variant_builder_init (&_tmp58_, G_VARIANT_TYPE_TUPLE);
-		g_variant_builder_add_value (&_tmp58_, g_variant_new_object_path ((*_tmp55_).path));
-		g_variant_builder_add_value (&_tmp58_, g_variant_new_string ((*_tmp55_).name));
-		g_variant_builder_add_value (&_tmp58_, g_variant_new_string ((*_tmp55_).icon_path));
-		g_variant_builder_add_value (&_tmp56_, g_variant_builder_end (&_tmp58_));
-		_tmp55_++;
-	}
-	g_variant_builder_add_value (&_reply_builder, g_variant_builder_end (&_tmp56_));
-	result = (_vala_PlaylistDetails_array_free (result, result_length1), NULL);
-	_reply = g_variant_builder_end (&_reply_builder);
-	g_dbus_message_set_body (_reply_message, _reply);
-	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
-	g_object_unref (invocation);
-	g_object_unref (_reply_message);
-}
-
-
-static void mpris_playlists_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	if (strcmp (method_name, "ActivatePlaylist") == 0) {
-		_dbus_mpris_playlists_ActivatePlaylist (object, parameters, invocation);
-	} else if (strcmp (method_name, "GetPlaylists") == 0) {
-		_dbus_mpris_playlists_GetPlaylists (object, parameters, invocation);
-	} else {
-		g_object_unref (invocation);
-	}
-}
-
-
-static GVariant* _dbus_mpris_playlists_get_Orderings (MprisPlaylists* self) {
-	gchar** result;
-	int result_length1;
-	gchar** _tmp59_;
-	GVariantBuilder _tmp60_;
-	int _tmp61_;
-	GVariant* _reply;
-	result = mpris_playlists_get_Orderings (self, &result_length1);
-	_tmp59_ = result;
-	g_variant_builder_init (&_tmp60_, G_VARIANT_TYPE ("as"));
-	for (_tmp61_ = 0; _tmp61_ < result_length1; _tmp61_++) {
-		g_variant_builder_add_value (&_tmp60_, g_variant_new_string (*_tmp59_));
-		_tmp59_++;
-	}
-	_reply = g_variant_builder_end (&_tmp60_);
-	result = (_vala_array_free (result, result_length1, (GDestroyNotify) g_free), NULL);
-	return _reply;
-}
-
-
-static GVariant* _dbus_mpris_playlists_get_PlaylistCount (MprisPlaylists* self) {
-	guint32 result;
-	GVariant* _reply;
-	result = mpris_playlists_get_PlaylistCount (self);
-	_reply = g_variant_new_uint32 (result);
-	return _reply;
-}
-
-
-static GVariant* _dbus_mpris_playlists_get_ActivePlaylist (MprisPlaylists* self) {
-	ActivePlaylistContainer* result;
-	GVariantBuilder _tmp62_;
-	GVariantBuilder _tmp63_;
-	GVariant* _reply;
-	result = mpris_playlists_get_ActivePlaylist (self);
-	g_variant_builder_init (&_tmp62_, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_tmp62_, g_variant_new_boolean ((*result).valid));
-	g_variant_builder_init (&_tmp63_, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_tmp63_, g_variant_new_object_path ((*(*result).details).path));
-	g_variant_builder_add_value (&_tmp63_, g_variant_new_string ((*(*result).details).name));
-	g_variant_builder_add_value (&_tmp63_, g_variant_new_string ((*(*result).details).icon_path));
-	g_variant_builder_add_value (&_tmp62_, g_variant_builder_end (&_tmp63_));
-	_reply = g_variant_builder_end (&_tmp62_);
-	_active_playlist_container_free0 (result);
-	return _reply;
-}
-
-
-static GVariant* mpris_playlists_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	if (strcmp (property_name, "Orderings") == 0) {
-		return _dbus_mpris_playlists_get_Orderings (object);
-	} else if (strcmp (property_name, "PlaylistCount") == 0) {
-		return _dbus_mpris_playlists_get_PlaylistCount (object);
-	} else if (strcmp (property_name, "ActivePlaylist") == 0) {
-		return _dbus_mpris_playlists_get_ActivePlaylist (object);
-	}
-	return NULL;
-}
-
-
-static void _dbus_mpris_playlists_set_Orderings (MprisPlaylists* self, GVariant* _value) {
-	gchar** value = NULL;
-	int value_length1;
-	gchar** _tmp64_;
-	int _tmp64__length;
-	int _tmp64__size;
-	int _tmp64__length1;
-	GVariantIter _tmp65_;
-	GVariant* _tmp66_;
-	_tmp64_ = g_new (gchar*, 5);
-	_tmp64__length = 0;
-	_tmp64__size = 4;
-	_tmp64__length1 = 0;
-	g_variant_iter_init (&_tmp65_, _value);
-	for (; (_tmp66_ = g_variant_iter_next_value (&_tmp65_)) != NULL; _tmp64__length1++) {
-		if (_tmp64__size == _tmp64__length) {
-			_tmp64__size = 2 * _tmp64__size;
-			_tmp64_ = g_renew (gchar*, _tmp64_, _tmp64__size + 1);
-		}
-		_tmp64_[_tmp64__length++] = g_variant_dup_string (_tmp66_, NULL);
-		g_variant_unref (_tmp66_);
-	}
-	value_length1 = _tmp64__length1;
-	_tmp64_[_tmp64__length] = NULL;
-	value = _tmp64_;
-	mpris_playlists_set_Orderings (self, value, value_length1);
-	value = (_vala_array_free (value, value_length1, (GDestroyNotify) g_free), NULL);
-}
-
-
-static void _dbus_mpris_playlists_set_PlaylistCount (MprisPlaylists* self, GVariant* _value) {
-	guint32 value = 0U;
-	value = g_variant_get_uint32 (_value);
-	mpris_playlists_set_PlaylistCount (self, value);
-}
-
-
-static void _dbus_mpris_playlists_set_ActivePlaylist (MprisPlaylists* self, GVariant* _value) {
-	ActivePlaylistContainer* value = NULL;
-	ActivePlaylistContainer _tmp67_;
-	GVariantIter _tmp68_;
-	GVariant* _tmp69_;
-	GVariant* _tmp70_;
-	PlaylistDetails _tmp71_;
-	GVariantIter _tmp72_;
-	GVariant* _tmp73_;
-	GVariant* _tmp74_;
-	GVariant* _tmp75_;
-	g_variant_iter_init (&_tmp68_, _value);
-	_tmp69_ = g_variant_iter_next_value (&_tmp68_);
-	_tmp67_.valid = g_variant_get_boolean (_tmp69_);
-	g_variant_unref (_tmp69_);
-	_tmp70_ = g_variant_iter_next_value (&_tmp68_);
-	g_variant_iter_init (&_tmp72_, _tmp70_);
-	_tmp73_ = g_variant_iter_next_value (&_tmp72_);
-	_tmp71_.path = g_variant_dup_string (_tmp73_, NULL);
-	g_variant_unref (_tmp73_);
-	_tmp74_ = g_variant_iter_next_value (&_tmp72_);
-	_tmp71_.name = g_variant_dup_string (_tmp74_, NULL);
-	g_variant_unref (_tmp74_);
-	_tmp75_ = g_variant_iter_next_value (&_tmp72_);
-	_tmp71_.icon_path = g_variant_dup_string (_tmp75_, NULL);
-	g_variant_unref (_tmp75_);
-	_tmp67_.details = g_memdup (&_tmp71_, sizeof (PlaylistDetails));
-	g_variant_unref (_tmp70_);
-	value = g_memdup (&_tmp67_, sizeof (ActivePlaylistContainer));
-	mpris_playlists_set_ActivePlaylist (self, &value);
-	_active_playlist_container_free0 (value);
-}
-
-
-static gboolean mpris_playlists_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
-	gpointer* data;
-	gpointer object;
-	data = user_data;
-	object = data[0];
-	if (strcmp (property_name, "Orderings") == 0) {
-		_dbus_mpris_playlists_set_Orderings (object, value);
-		return TRUE;
-	} else if (strcmp (property_name, "PlaylistCount") == 0) {
-		_dbus_mpris_playlists_set_PlaylistCount (object, value);
-		return TRUE;
-	} else if (strcmp (property_name, "ActivePlaylist") == 0) {
-		_dbus_mpris_playlists_set_ActivePlaylist (object, value);
-		return TRUE;
-	}
-	return FALSE;
-}
-
-
-static void _dbus_mpris_playlists_playlist_changed (GObject* _sender, PlaylistDetails* details, gpointer* _data) {
-	GDBusConnection * _connection;
-	const gchar * _path;
-	GVariant *_arguments;
-	GVariantBuilder _arguments_builder;
-	GVariantBuilder _tmp76_;
-	_connection = _data[1];
-	_path = _data[2];
-	g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_init (&_tmp76_, G_VARIANT_TYPE_TUPLE);
-	g_variant_builder_add_value (&_tmp76_, g_variant_new_object_path ((*details).path));
-	g_variant_builder_add_value (&_tmp76_, g_variant_new_string ((*details).name));
-	g_variant_builder_add_value (&_tmp76_, g_variant_new_string ((*details).icon_path));
-	g_variant_builder_add_value (&_arguments_builder, g_variant_builder_end (&_tmp76_));
-	_arguments = g_variant_builder_end (&_arguments_builder);
-	g_dbus_connection_emit_signal (_connection, NULL, _path, "org.mpris.MediaPlayer2.Playlists", "PlaylistChanged", _arguments, NULL);
-}
-
-
-guint mpris_playlists_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
-	guint result;
-	gpointer *data;
-	data = g_new (gpointer, 3);
-	data[0] = g_object_ref (object);
-	data[1] = g_object_ref (connection);
-	data[2] = g_strdup (path);
-	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_mpris_playlists_dbus_interface_info), &_mpris_playlists_dbus_interface_vtable, data, _mpris_playlists_unregister_object, error);
-	if (!result) {
-		return 0;
-	}
-	g_signal_connect (object, "playlist-changed", (GCallback) _dbus_mpris_playlists_playlist_changed, data);
-	return result;
-}
-
-
-static void _mpris_playlists_unregister_object (gpointer user_data) {
-	gpointer* data;
-	data = user_data;
-	g_signal_handlers_disconnect_by_func (data[0], _dbus_mpris_playlists_playlist_changed, data);
-	g_object_unref (data[0]);
-	g_object_unref (data[1]);
-	g_free (data[2]);
-	g_free (data);
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-
diff -Naur indicator-sound-0.8.5.0/src/mpris2-watcher.c indicator-sound-precise/src/mpris2-watcher.c
--- indicator-sound-0.8.5.0/src/mpris2-watcher.c	2012-03-30 10:32:34.000000000 -0700
+++ indicator-sound-precise/src/mpris2-watcher.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,838 +0,0 @@
-/* mpris2-watcher.c generated by valac 0.14.2, the Vala compiler
- * generated from mpris2-watcher.vala, do not modify */
-
-/*
-Copyright 2010 Canonical Ltd.
-
-Authors:
-    Conor Curran <conor.curran@canonical.com>
-
-This program is free software: you can redistribute it and/or modify it 
-under the terms of the GNU General Public License version 3, as published 
-by the Free Software Foundation.
-
-This program is distributed in the hope that it will be useful, but 
-WITHOUT ANY WARRANTY; without even the implied warranties of 
-MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
-PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along 
-with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gio/gio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <libxml/parser.h>
-#include <libxml/tree.h>
-
-
-#define TYPE_MPRIS2_WATCHER (mpris2_watcher_get_type ())
-#define MPRIS2_WATCHER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS2_WATCHER, Mpris2Watcher))
-#define MPRIS2_WATCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS2_WATCHER, Mpris2WatcherClass))
-#define IS_MPRIS2_WATCHER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS2_WATCHER))
-#define IS_MPRIS2_WATCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS2_WATCHER))
-#define MPRIS2_WATCHER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS2_WATCHER, Mpris2WatcherClass))
-
-typedef struct _Mpris2Watcher Mpris2Watcher;
-typedef struct _Mpris2WatcherClass Mpris2WatcherClass;
-typedef struct _Mpris2WatcherPrivate Mpris2WatcherPrivate;
-
-#define TYPE_FREE_DESKTOP_OBJECT (free_desktop_object_get_type ())
-#define FREE_DESKTOP_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FREE_DESKTOP_OBJECT, FreeDesktopObject))
-#define IS_FREE_DESKTOP_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FREE_DESKTOP_OBJECT))
-#define FREE_DESKTOP_OBJECT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_FREE_DESKTOP_OBJECT, FreeDesktopObjectIface))
-
-typedef struct _FreeDesktopObject FreeDesktopObject;
-typedef struct _FreeDesktopObjectIface FreeDesktopObjectIface;
-
-#define TYPE_FREE_DESKTOP_OBJECT_PROXY (free_desktop_object_proxy_get_type ())
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-#define TYPE_MPRIS_ROOT (mpris_root_get_type ())
-#define MPRIS_ROOT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_ROOT, MprisRoot))
-#define IS_MPRIS_ROOT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_ROOT))
-#define MPRIS_ROOT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MPRIS_ROOT, MprisRootIface))
-
-typedef struct _MprisRoot MprisRoot;
-typedef struct _MprisRootIface MprisRootIface;
-
-#define TYPE_MPRIS_ROOT_PROXY (mpris_root_proxy_get_type ())
-#define _g_free0(var) (var = (g_free (var), NULL))
-typedef struct _Mpris2WatcherCheckForActiveClientsData Mpris2WatcherCheckForActiveClientsData;
-
-#define TYPE_FREE_DESKTOP_INTROSPECTABLE (free_desktop_introspectable_get_type ())
-#define FREE_DESKTOP_INTROSPECTABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FREE_DESKTOP_INTROSPECTABLE, FreeDesktopIntrospectable))
-#define IS_FREE_DESKTOP_INTROSPECTABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FREE_DESKTOP_INTROSPECTABLE))
-#define FREE_DESKTOP_INTROSPECTABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_FREE_DESKTOP_INTROSPECTABLE, FreeDesktopIntrospectableIface))
-
-typedef struct _FreeDesktopIntrospectable FreeDesktopIntrospectable;
-typedef struct _FreeDesktopIntrospectableIface FreeDesktopIntrospectableIface;
-
-#define TYPE_FREE_DESKTOP_INTROSPECTABLE_PROXY (free_desktop_introspectable_proxy_get_type ())
-
-struct _Mpris2Watcher {
-	GObject parent_instance;
-	Mpris2WatcherPrivate * priv;
-};
-
-struct _Mpris2WatcherClass {
-	GObjectClass parent_class;
-};
-
-struct _FreeDesktopObjectIface {
-	GTypeInterface parent_iface;
-	void (*list_names) (FreeDesktopObject* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	gchar** (*list_names_finish) (FreeDesktopObject* self, GAsyncResult* _res_, int* result_length1, GError** error);
-};
-
-struct _Mpris2WatcherPrivate {
-	FreeDesktopObject* fdesktop_obj;
-};
-
-struct _MprisRootIface {
-	GTypeInterface parent_iface;
-	void (*Quit) (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*Quit_finish) (MprisRoot* self, GAsyncResult* _res_, GError** error);
-	void (*Raise) (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*Raise_finish) (MprisRoot* self, GAsyncResult* _res_, GError** error);
-	gboolean (*get_HasTracklist) (MprisRoot* self);
-	void (*set_HasTracklist) (MprisRoot* self, gboolean value);
-	gboolean (*get_CanQuit) (MprisRoot* self);
-	void (*set_CanQuit) (MprisRoot* self, gboolean value);
-	gboolean (*get_CanRaise) (MprisRoot* self);
-	void (*set_CanRaise) (MprisRoot* self, gboolean value);
-	gchar* (*get_Identity) (MprisRoot* self);
-	void (*set_Identity) (MprisRoot* self, const gchar* value);
-	gchar* (*get_DesktopEntry) (MprisRoot* self);
-	void (*set_DesktopEntry) (MprisRoot* self, const gchar* value);
-};
-
-struct _Mpris2WatcherCheckForActiveClientsData {
-	int _state_;
-	GObject* _source_object_;
-	GAsyncResult* _res_;
-	GSimpleAsyncResult* _async_result;
-	Mpris2Watcher* self;
-	gchar** interfaces;
-	gint interfaces_length1;
-	gint _interfaces_size_;
-	FreeDesktopObject* _tmp0_;
-	gint _tmp1_;
-	gchar** _tmp2_;
-	gchar** _tmp3_;
-	gint _tmp3__length1;
-	gint __tmp3__size_;
-	GError* e;
-	GError* _tmp4_;
-	const gchar* _tmp5_;
-	gchar** _tmp6_;
-	gint _tmp6__length1;
-	gchar** address_collection;
-	gint address_collection_length1;
-	gint _address_collection_size_;
-	gint address_it;
-	gchar* _tmp7_;
-	gchar* address;
-	const gchar* _tmp8_;
-	gboolean _tmp9_;
-	const gchar* _tmp10_;
-	MprisRoot* _tmp11_;
-	MprisRoot* mpris2_root;
-	MprisRoot* _tmp12_;
-	const gchar* _tmp13_;
-	gboolean _tmp14_;
-	gboolean use_playlists;
-	MprisRoot* _tmp15_;
-	gchar* _tmp16_;
-	gchar* _tmp17_;
-	gchar* _tmp18_;
-	const gchar* _tmp19_;
-	gboolean _tmp20_;
-	GError * _inner_error_;
-};
-
-struct _FreeDesktopIntrospectableIface {
-	GTypeInterface parent_iface;
-	gchar* (*Introspect) (FreeDesktopIntrospectable* self, GError** error);
-};
-
-
-static gpointer mpris2_watcher_parent_class = NULL;
-
-GType mpris2_watcher_get_type (void) G_GNUC_CONST;
-GType free_desktop_object_proxy_get_type (void) G_GNUC_CONST;
-guint free_desktop_object_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-GType free_desktop_object_get_type (void) G_GNUC_CONST;
-#define MPRIS2_WATCHER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MPRIS2_WATCHER, Mpris2WatcherPrivate))
-enum  {
-	MPRIS2_WATCHER_DUMMY_PROPERTY
-};
-Mpris2Watcher* mpris2_watcher_new (void);
-Mpris2Watcher* mpris2_watcher_construct (GType object_type);
-static void mpris2_watcher_check_for_active_clients_data_free (gpointer _data);
-void mpris2_watcher_check_for_active_clients (Mpris2Watcher* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris2_watcher_check_for_active_clients_finish (Mpris2Watcher* self, GAsyncResult* _res_);
-static gboolean mpris2_watcher_check_for_active_clients_co (Mpris2WatcherCheckForActiveClientsData* _data_);
-void free_desktop_object_list_names (FreeDesktopObject* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-gchar** free_desktop_object_list_names_finish (FreeDesktopObject* self, GAsyncResult* _res_, int* result_length1, GError** error);
-static void mpris2_watcher_check_for_active_clients_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
-#define MPRIS_PREFIX "org.mpris.MediaPlayer2."
-GType mpris_root_proxy_get_type (void) G_GNUC_CONST;
-guint mpris_root_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-GType mpris_root_get_type (void) G_GNUC_CONST;
-static MprisRoot* mpris2_watcher_create_mpris_root (Mpris2Watcher* self, const gchar* name);
-static gboolean mpris2_watcher_supports_playlists (Mpris2Watcher* self, const gchar* name);
-gchar* mpris_root_get_DesktopEntry (MprisRoot* self);
-static void mpris2_watcher_name_changes_detected (Mpris2Watcher* self, FreeDesktopObject* dbus_obj, const gchar* name, const gchar* previous_owner, const gchar* current_owner);
-#define MPRIS_MEDIA_PLAYER_PATH "/org/mpris/MediaPlayer2"
-GType free_desktop_introspectable_proxy_get_type (void) G_GNUC_CONST;
-guint free_desktop_introspectable_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-GType free_desktop_introspectable_get_type (void) G_GNUC_CONST;
-gchar* free_desktop_introspectable_Introspect (FreeDesktopIntrospectable* self, GError** error);
-static gboolean mpris2_watcher_parse_interfaces (Mpris2Watcher* self, const gchar* interface_info);
-static void g_cclosure_user_marshal_VOID__STRING_STRING_BOOLEAN (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
-static GObject * mpris2_watcher_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
-#define FREEDESKTOP_SERVICE "org.freedesktop.DBus"
-#define FREEDESKTOP_OBJECT "/org/freedesktop/DBus"
-static void _mpris2_watcher_name_changes_detected_free_desktop_object_name_owner_changed (FreeDesktopObject* _sender, const gchar* name, const gchar* old_owner, const gchar* new_owner, gpointer self);
-static void mpris2_watcher_finalize (GObject* obj);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-
-
-Mpris2Watcher* mpris2_watcher_construct (GType object_type) {
-	Mpris2Watcher * self = NULL;
-	self = (Mpris2Watcher*) g_object_new (object_type, NULL);
-	return self;
-}
-
-
-Mpris2Watcher* mpris2_watcher_new (void) {
-	return mpris2_watcher_construct (TYPE_MPRIS2_WATCHER);
-}
-
-
-static void mpris2_watcher_check_for_active_clients_data_free (gpointer _data) {
-	Mpris2WatcherCheckForActiveClientsData* _data_;
-	_data_ = _data;
-	_g_object_unref0 (_data_->self);
-	g_slice_free (Mpris2WatcherCheckForActiveClientsData, _data_);
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-void mpris2_watcher_check_for_active_clients (Mpris2Watcher* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
-	Mpris2WatcherCheckForActiveClientsData* _data_;
-	Mpris2Watcher* _tmp0_;
-	_data_ = g_slice_new0 (Mpris2WatcherCheckForActiveClientsData);
-	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, mpris2_watcher_check_for_active_clients);
-	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, mpris2_watcher_check_for_active_clients_data_free);
-	_tmp0_ = _g_object_ref0 (self);
-	_data_->self = _tmp0_;
-	mpris2_watcher_check_for_active_clients_co (_data_);
-}
-
-
-void mpris2_watcher_check_for_active_clients_finish (Mpris2Watcher* self, GAsyncResult* _res_) {
-	Mpris2WatcherCheckForActiveClientsData* _data_;
-	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
-}
-
-
-static void mpris2_watcher_check_for_active_clients_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
-	Mpris2WatcherCheckForActiveClientsData* _data_;
-	_data_ = _user_data_;
-	_data_->_source_object_ = source_object;
-	_data_->_res_ = _res_;
-	mpris2_watcher_check_for_active_clients_co (_data_);
-}
-
-
-static gboolean mpris2_watcher_check_for_active_clients_co (Mpris2WatcherCheckForActiveClientsData* _data_) {
-	switch (_data_->_state_) {
-		case 0:
-		goto _state_0;
-		case 1:
-		goto _state_1;
-		default:
-		g_assert_not_reached ();
-	}
-	_state_0:
-	_data_->interfaces_length1 = 0;
-	_data_->_interfaces_size_ = 0;
-	{
-		_data_->_tmp0_ = _data_->self->priv->fdesktop_obj;
-		_data_->_tmp1_ = 0;
-		_data_->_state_ = 1;
-		free_desktop_object_list_names (_data_->_tmp0_, mpris2_watcher_check_for_active_clients_ready, _data_);
-		return FALSE;
-		_state_1:
-		_data_->_tmp2_ = NULL;
-		_data_->_tmp2_ = free_desktop_object_list_names_finish (_data_->_tmp0_, _data_->_res_, &_data_->_tmp1_, &_data_->_inner_error_);
-		_data_->_tmp3_ = _data_->_tmp2_;
-		_data_->_tmp3__length1 = _data_->_tmp1_;
-		_data_->__tmp3__size_ = _data_->_tmp3__length1;
-		if (_data_->_inner_error_ != NULL) {
-			if (_data_->_inner_error_->domain == G_IO_ERROR) {
-				goto __catch8_g_io_error;
-			}
-			_data_->interfaces = (_vala_array_free (_data_->interfaces, _data_->interfaces_length1, (GDestroyNotify) g_free), NULL);
-			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
-			g_clear_error (&_data_->_inner_error_);
-			return FALSE;
-		}
-		_data_->interfaces = (_vala_array_free (_data_->interfaces, _data_->interfaces_length1, (GDestroyNotify) g_free), NULL);
-		_data_->interfaces = _data_->_tmp3_;
-		_data_->interfaces_length1 = _data_->_tmp3__length1;
-		_data_->_interfaces_size_ = _data_->interfaces_length1;
-	}
-	goto __finally8;
-	__catch8_g_io_error:
-	{
-		_data_->e = _data_->_inner_error_;
-		_data_->_inner_error_ = NULL;
-		_data_->_tmp4_ = _data_->e;
-		_data_->_tmp5_ = _data_->_tmp4_->message;
-		g_warning ("mpris2-watcher.vala:60: Mpris2watcher could fetch active interfaces at" \
-" startup: %s", _data_->_tmp5_);
-		_g_error_free0 (_data_->e);
-		_data_->interfaces = (_vala_array_free (_data_->interfaces, _data_->interfaces_length1, (GDestroyNotify) g_free), NULL);
-		if (_data_->_state_ == 0) {
-			g_simple_async_result_complete_in_idle (_data_->_async_result);
-		} else {
-			g_simple_async_result_complete (_data_->_async_result);
-		}
-		g_object_unref (_data_->_async_result);
-		return FALSE;
-	}
-	__finally8:
-	if (_data_->_inner_error_ != NULL) {
-		_data_->interfaces = (_vala_array_free (_data_->interfaces, _data_->interfaces_length1, (GDestroyNotify) g_free), NULL);
-		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
-		g_clear_error (&_data_->_inner_error_);
-		return FALSE;
-	}
-	_data_->_tmp6_ = _data_->interfaces;
-	_data_->_tmp6__length1 = _data_->interfaces_length1;
-	{
-		_data_->address_collection_length1 = 0;
-		_data_->_address_collection_size_ = 0;
-		_data_->address_collection = _data_->_tmp6_;
-		_data_->address_collection_length1 = _data_->_tmp6__length1;
-		_data_->address_it = 0;
-		for (_data_->address_it = 0; _data_->address_it < _data_->_tmp6__length1; _data_->address_it = _data_->address_it + 1) {
-			_data_->_tmp7_ = g_strdup (_data_->address_collection[_data_->address_it]);
-			_data_->address = _data_->_tmp7_;
-			{
-				_data_->_tmp8_ = _data_->address;
-				_data_->_tmp9_ = FALSE;
-				_data_->_tmp9_ = g_str_has_prefix (_data_->_tmp8_, MPRIS_PREFIX);
-				if (_data_->_tmp9_) {
-					_data_->_tmp10_ = _data_->address;
-					_data_->_tmp11_ = NULL;
-					_data_->_tmp11_ = mpris2_watcher_create_mpris_root (_data_->self, _data_->_tmp10_);
-					_data_->mpris2_root = _data_->_tmp11_;
-					_data_->_tmp12_ = _data_->mpris2_root;
-					if (_data_->_tmp12_ == NULL) {
-						_g_object_unref0 (_data_->mpris2_root);
-						_g_free0 (_data_->address);
-						_data_->interfaces = (_vala_array_free (_data_->interfaces, _data_->interfaces_length1, (GDestroyNotify) g_free), NULL);
-						if (_data_->_state_ == 0) {
-							g_simple_async_result_complete_in_idle (_data_->_async_result);
-						} else {
-							g_simple_async_result_complete (_data_->_async_result);
-						}
-						g_object_unref (_data_->_async_result);
-						return FALSE;
-					}
-					_data_->_tmp13_ = _data_->address;
-					_data_->_tmp14_ = FALSE;
-					_data_->_tmp14_ = mpris2_watcher_supports_playlists (_data_->self, _data_->_tmp13_);
-					_data_->use_playlists = _data_->_tmp14_;
-					_data_->_tmp15_ = _data_->mpris2_root;
-					_data_->_tmp16_ = mpris_root_get_DesktopEntry (_data_->_tmp15_);
-					_data_->_tmp17_ = _data_->_tmp16_;
-					_data_->_tmp18_ = _data_->_tmp17_;
-					_data_->_tmp19_ = _data_->address;
-					_data_->_tmp20_ = _data_->use_playlists;
-					g_signal_emit_by_name (_data_->self, "client-appeared", _data_->_tmp18_, _data_->_tmp19_, _data_->_tmp20_);
-					_g_free0 (_data_->_tmp18_);
-					_g_object_unref0 (_data_->mpris2_root);
-				}
-				_g_free0 (_data_->address);
-			}
-		}
-	}
-	_data_->interfaces = (_vala_array_free (_data_->interfaces, _data_->interfaces_length1, (GDestroyNotify) g_free), NULL);
-	if (_data_->_state_ == 0) {
-		g_simple_async_result_complete_in_idle (_data_->_async_result);
-	} else {
-		g_simple_async_result_complete (_data_->_async_result);
-	}
-	g_object_unref (_data_->_async_result);
-	return FALSE;
-}
-
-
-static void mpris2_watcher_name_changes_detected (Mpris2Watcher* self, FreeDesktopObject* dbus_obj, const gchar* name, const gchar* previous_owner, const gchar* current_owner) {
-	const gchar* _tmp0_;
-	MprisRoot* _tmp1_ = NULL;
-	MprisRoot* mpris2_root;
-	MprisRoot* _tmp2_;
-	gboolean _tmp3_ = FALSE;
-	const gchar* _tmp4_;
-	gboolean _tmp6_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (dbus_obj != NULL);
-	g_return_if_fail (name != NULL);
-	g_return_if_fail (previous_owner != NULL);
-	g_return_if_fail (current_owner != NULL);
-	_tmp0_ = name;
-	_tmp1_ = mpris2_watcher_create_mpris_root (self, _tmp0_);
-	mpris2_root = _tmp1_;
-	_tmp2_ = mpris2_root;
-	if (_tmp2_ == NULL) {
-		_g_object_unref0 (mpris2_root);
-		return;
-	}
-	_tmp4_ = previous_owner;
-	if (g_strcmp0 (_tmp4_, "") != 0) {
-		const gchar* _tmp5_;
-		_tmp5_ = current_owner;
-		_tmp3_ = g_strcmp0 (_tmp5_, "") == 0;
-	} else {
-		_tmp3_ = FALSE;
-	}
-	_tmp6_ = _tmp3_;
-	if (_tmp6_) {
-		const gchar* _tmp7_;
-		const gchar* _tmp8_;
-		_tmp7_ = name;
-		g_debug ("mpris2-watcher.vala:84: Client '%s' gone down", _tmp7_);
-		_tmp8_ = name;
-		g_signal_emit_by_name (self, "client-disappeared", _tmp8_);
-	} else {
-		gboolean _tmp9_ = FALSE;
-		const gchar* _tmp10_;
-		gboolean _tmp12_;
-		_tmp10_ = previous_owner;
-		if (g_strcmp0 (_tmp10_, "") == 0) {
-			const gchar* _tmp11_;
-			_tmp11_ = current_owner;
-			_tmp9_ = g_strcmp0 (_tmp11_, "") != 0;
-		} else {
-			_tmp9_ = FALSE;
-		}
-		_tmp12_ = _tmp9_;
-		if (_tmp12_) {
-			const gchar* _tmp13_;
-			const gchar* _tmp14_;
-			gboolean _tmp15_ = FALSE;
-			gboolean use_playlists;
-			MprisRoot* _tmp16_;
-			gchar* _tmp17_;
-			gchar* _tmp18_;
-			gchar* _tmp19_;
-			const gchar* _tmp20_;
-			gboolean _tmp21_;
-			_tmp13_ = name;
-			g_debug ("mpris2-watcher.vala:88: Client '%s' has appeared", _tmp13_);
-			_tmp14_ = name;
-			_tmp15_ = mpris2_watcher_supports_playlists (self, _tmp14_);
-			use_playlists = _tmp15_;
-			_tmp16_ = mpris2_root;
-			_tmp17_ = mpris_root_get_DesktopEntry (_tmp16_);
-			_tmp18_ = _tmp17_;
-			_tmp19_ = _tmp18_;
-			_tmp20_ = name;
-			_tmp21_ = use_playlists;
-			g_signal_emit_by_name (self, "client-appeared", _tmp19_, _tmp20_, _tmp21_);
-			_g_free0 (_tmp19_);
-		}
-	}
-	_g_object_unref0 (mpris2_root);
-}
-
-
-static MprisRoot* mpris2_watcher_create_mpris_root (Mpris2Watcher* self, const gchar* name) {
-	MprisRoot* result = NULL;
-	MprisRoot* mpris2_root;
-	const gchar* _tmp0_;
-	gboolean _tmp1_ = FALSE;
-	GError * _inner_error_ = NULL;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (name != NULL, NULL);
-	mpris2_root = NULL;
-	_tmp0_ = name;
-	_tmp1_ = g_str_has_prefix (_tmp0_, MPRIS_PREFIX);
-	if (_tmp1_) {
-		{
-			const gchar* _tmp2_;
-			MprisRoot* _tmp3_ = NULL;
-			MprisRoot* _tmp4_;
-			_tmp2_ = name;
-			_tmp3_ = g_initable_new (TYPE_MPRIS_ROOT_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", _tmp2_, "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", MPRIS_MEDIA_PLAYER_PATH, "g-interface-name", "org.mpris.MediaPlayer2", NULL);
-			_tmp4_ = (MprisRoot*) _tmp3_;
-			if (_inner_error_ != NULL) {
-				if (_inner_error_->domain == G_IO_ERROR) {
-					goto __catch9_g_io_error;
-				}
-				_g_object_unref0 (mpris2_root);
-				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-				g_clear_error (&_inner_error_);
-				return NULL;
-			}
-			_g_object_unref0 (mpris2_root);
-			mpris2_root = _tmp4_;
-		}
-		goto __finally9;
-		__catch9_g_io_error:
-		{
-			GError* e = NULL;
-			GError* _tmp5_;
-			const gchar* _tmp6_;
-			e = _inner_error_;
-			_inner_error_ = NULL;
-			_tmp5_ = e;
-			_tmp6_ = _tmp5_->message;
-			g_warning ("mpris2-watcher.vala:103: Mpris2watcher could not create a root interfa" \
-"ce: %s", _tmp6_);
-			_g_error_free0 (e);
-		}
-		__finally9:
-		if (_inner_error_ != NULL) {
-			_g_object_unref0 (mpris2_root);
-			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	result = mpris2_root;
-	return result;
-}
-
-
-static gboolean mpris2_watcher_supports_playlists (Mpris2Watcher* self, const gchar* name) {
-	gboolean result = FALSE;
-	FreeDesktopIntrospectable* introspectable = NULL;
-	GError * _inner_error_ = NULL;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (name != NULL, FALSE);
-	{
-		const gchar* _tmp0_;
-		FreeDesktopIntrospectable* _tmp1_ = NULL;
-		FreeDesktopIntrospectable* _tmp2_;
-		FreeDesktopIntrospectable* _tmp3_;
-		gchar* _tmp4_ = NULL;
-		gchar* results;
-		const gchar* _tmp5_;
-		gboolean _tmp6_ = FALSE;
-		_tmp0_ = name;
-		_tmp1_ = g_initable_new (TYPE_FREE_DESKTOP_INTROSPECTABLE_PROXY, NULL, &_inner_error_, "g-flags", G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES, "g-name", _tmp0_, "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", MPRIS_MEDIA_PLAYER_PATH, "g-interface-name", "org.freedesktop.DBus.Introspectable", NULL);
-		_tmp2_ = (FreeDesktopIntrospectable*) _tmp1_;
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == G_IO_ERROR) {
-				goto __catch10_g_io_error;
-			}
-			_g_object_unref0 (introspectable);
-			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-			g_clear_error (&_inner_error_);
-			return FALSE;
-		}
-		_g_object_unref0 (introspectable);
-		introspectable = _tmp2_;
-		_tmp3_ = introspectable;
-		_tmp4_ = free_desktop_introspectable_Introspect (_tmp3_, &_inner_error_);
-		results = _tmp4_;
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == G_IO_ERROR) {
-				goto __catch10_g_io_error;
-			}
-			_g_object_unref0 (introspectable);
-			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-			g_clear_error (&_inner_error_);
-			return FALSE;
-		}
-		_tmp5_ = results;
-		_tmp6_ = mpris2_watcher_parse_interfaces (self, _tmp5_);
-		result = _tmp6_;
-		_g_free0 (results);
-		_g_object_unref0 (introspectable);
-		return result;
-	}
-	goto __finally10;
-	__catch10_g_io_error:
-	{
-		GError* e = NULL;
-		GError* _tmp7_;
-		const gchar* _tmp8_;
-		e = _inner_error_;
-		_inner_error_ = NULL;
-		_tmp7_ = e;
-		_tmp8_ = _tmp7_->message;
-		g_warning ("mpris2-watcher.vala:131: Could not create an introspectable object: %s", _tmp8_);
-		_g_error_free0 (e);
-	}
-	__finally10:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (introspectable);
-		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-		g_clear_error (&_inner_error_);
-		return FALSE;
-	}
-	result = FALSE;
-	_g_object_unref0 (introspectable);
-	return result;
-}
-
-
-static gboolean mpris2_watcher_parse_interfaces (Mpris2Watcher* self, const gchar* interface_info) {
-	gboolean result = FALSE;
-	gboolean _result_;
-	const gchar* _tmp0_;
-	xmlDoc* _tmp1_ = NULL;
-	xmlDoc* xml_doc;
-	xmlDoc* _tmp2_;
-	xmlDoc* _tmp3_;
-	xmlNode* _tmp4_ = NULL;
-	xmlNode* root_node;
-	xmlNode* _tmp5_;
-	xmlDoc* _tmp27_;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (interface_info != NULL, FALSE);
-	_result_ = FALSE;
-	_tmp0_ = interface_info;
-	_tmp1_ = xmlParseDoc (_tmp0_);
-	xml_doc = _tmp1_;
-	_tmp2_ = xml_doc;
-	if (_tmp2_ == NULL) {
-		g_warning ("mpris2-watcher.vala:143: Mpris2Watcher - parse-interfaces - failed to " \
-"instantiate xml doc");
-		result = FALSE;
-		return result;
-	}
-	_tmp3_ = xml_doc;
-	_tmp4_ = xmlDocGetRootElement (_tmp3_);
-	root_node = _tmp4_;
-	_tmp5_ = root_node;
-	if (_tmp5_ == NULL) {
-		xmlDoc* _tmp6_;
-		_tmp6_ = xml_doc;
-		xmlFreeDoc (_tmp6_);
-		g_warning ("mpris2-watcher.vala:151: Mpris2Watcher - the interface info xml is emp" \
-"ty");
-		result = FALSE;
-		return result;
-	}
-	{
-		xmlNode* _tmp7_;
-		xmlNode* _tmp8_;
-		xmlNode* iter;
-		_tmp7_ = root_node;
-		_tmp8_ = _tmp7_->children;
-		iter = _tmp8_;
-		{
-			gboolean _tmp9_;
-			_tmp9_ = TRUE;
-			while (TRUE) {
-				gboolean _tmp10_;
-				xmlNode* _tmp13_;
-				xmlNode* _tmp14_;
-				xmlElementType _tmp15_;
-				xmlNode* _tmp16_;
-				xmlAttr* _tmp17_;
-				xmlAttr* attributes;
-				xmlAttr* _tmp18_;
-				xmlNode* _tmp19_;
-				const gchar* _tmp20_;
-				gchar* _tmp21_;
-				gchar* interface_name;
-				const gchar* _tmp22_;
-				const gchar* _tmp23_;
-				gchar* _tmp24_ = NULL;
-				gchar* _tmp25_;
-				gboolean _tmp26_;
-				_tmp10_ = _tmp9_;
-				if (!_tmp10_) {
-					xmlNode* _tmp11_;
-					xmlNode* _tmp12_;
-					_tmp11_ = iter;
-					_tmp12_ = _tmp11_->next;
-					iter = _tmp12_;
-				}
-				_tmp9_ = FALSE;
-				_tmp13_ = iter;
-				if (!(_tmp13_ != NULL)) {
-					break;
-				}
-				_tmp14_ = iter;
-				_tmp15_ = _tmp14_->type;
-				if (_tmp15_ != XML_ELEMENT_NODE) {
-					continue;
-				}
-				_tmp16_ = iter;
-				_tmp17_ = _tmp16_->properties;
-				attributes = _tmp17_;
-				_tmp18_ = attributes;
-				_tmp19_ = _tmp18_->children;
-				_tmp20_ = _tmp19_->content;
-				_tmp21_ = g_strdup (_tmp20_);
-				interface_name = _tmp21_;
-				_tmp22_ = interface_name;
-				g_debug ("mpris2-watcher.vala:163: this dbus object has interface %s ", _tmp22_);
-				_tmp23_ = interface_name;
-				_tmp24_ = g_strconcat (MPRIS_PREFIX, "Playlists", NULL);
-				_tmp25_ = _tmp24_;
-				_tmp26_ = g_strcmp0 (_tmp23_, _tmp25_) == 0;
-				_g_free0 (_tmp25_);
-				if (_tmp26_) {
-					_result_ = TRUE;
-				}
-				_g_free0 (interface_name);
-			}
-		}
-	}
-	_tmp27_ = xml_doc;
-	xmlFreeDoc (_tmp27_);
-	result = _result_;
-	return result;
-}
-
-
-static void g_cclosure_user_marshal_VOID__STRING_STRING_BOOLEAN (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
-	typedef void (*GMarshalFunc_VOID__STRING_STRING_BOOLEAN) (gpointer data1, const char* arg_1, const char* arg_2, gboolean arg_3, gpointer data2);
-	register GMarshalFunc_VOID__STRING_STRING_BOOLEAN callback;
-	register GCClosure * cc;
-	register gpointer data1;
-	register gpointer data2;
-	cc = (GCClosure *) closure;
-	g_return_if_fail (n_param_values == 4);
-	if (G_CCLOSURE_SWAP_DATA (closure)) {
-		data1 = closure->data;
-		data2 = param_values->data[0].v_pointer;
-	} else {
-		data1 = param_values->data[0].v_pointer;
-		data2 = closure->data;
-	}
-	callback = (GMarshalFunc_VOID__STRING_STRING_BOOLEAN) (marshal_data ? marshal_data : cc->callback);
-	callback (data1, g_value_get_string (param_values + 1), g_value_get_string (param_values + 2), g_value_get_boolean (param_values + 3), data2);
-}
-
-
-static void _mpris2_watcher_name_changes_detected_free_desktop_object_name_owner_changed (FreeDesktopObject* _sender, const gchar* name, const gchar* old_owner, const gchar* new_owner, gpointer self) {
-	mpris2_watcher_name_changes_detected (self, _sender, name, old_owner, new_owner);
-}
-
-
-static GObject * mpris2_watcher_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
-	GObject * obj;
-	GObjectClass * parent_class;
-	Mpris2Watcher * self;
-	GError * _inner_error_ = NULL;
-	parent_class = G_OBJECT_CLASS (mpris2_watcher_parent_class);
-	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
-	self = MPRIS2_WATCHER (obj);
-	{
-		FreeDesktopObject* _tmp0_ = NULL;
-		FreeDesktopObject* _tmp1_;
-		FreeDesktopObject* _tmp2_;
-		_tmp0_ = g_initable_new (TYPE_FREE_DESKTOP_OBJECT_PROXY, NULL, &_inner_error_, "g-flags", G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES, "g-name", FREEDESKTOP_SERVICE, "g-bus-type", G_BUS_TYPE_SESSION, "g-object-path", FREEDESKTOP_OBJECT, "g-interface-name", "org.freedesktop.DBus", NULL);
-		_tmp1_ = (FreeDesktopObject*) _tmp0_;
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == G_IO_ERROR) {
-				goto __catch11_g_io_error;
-			}
-			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-			g_clear_error (&_inner_error_);
-		}
-		_g_object_unref0 (self->priv->fdesktop_obj);
-		self->priv->fdesktop_obj = _tmp1_;
-		_tmp2_ = self->priv->fdesktop_obj;
-		g_signal_connect_object (_tmp2_, "name-owner-changed", (GCallback) _mpris2_watcher_name_changes_detected_free_desktop_object_name_owner_changed, self, 0);
-		mpris2_watcher_check_for_active_clients (self, NULL, NULL);
-	}
-	goto __finally11;
-	__catch11_g_io_error:
-	{
-		GError* e = NULL;
-		GError* _tmp3_;
-		const gchar* _tmp4_;
-		e = _inner_error_;
-		_inner_error_ = NULL;
-		_tmp3_ = e;
-		_tmp4_ = _tmp3_->message;
-		g_warning ("mpris2-watcher.vala:46: Mpris2watcher could not set up a watch for mpr" \
-"is clients appearing on the bus: %s", _tmp4_);
-		_g_error_free0 (e);
-	}
-	__finally11:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-		g_clear_error (&_inner_error_);
-	}
-	return obj;
-}
-
-
-static void mpris2_watcher_class_init (Mpris2WatcherClass * klass) {
-	mpris2_watcher_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (Mpris2WatcherPrivate));
-	G_OBJECT_CLASS (klass)->constructor = mpris2_watcher_constructor;
-	G_OBJECT_CLASS (klass)->finalize = mpris2_watcher_finalize;
-	g_signal_new ("client_appeared", TYPE_MPRIS2_WATCHER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__STRING_STRING_BOOLEAN, G_TYPE_NONE, 3, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_BOOLEAN);
-	g_signal_new ("client_disappeared", TYPE_MPRIS2_WATCHER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
-}
-
-
-static void mpris2_watcher_instance_init (Mpris2Watcher * self) {
-	self->priv = MPRIS2_WATCHER_GET_PRIVATE (self);
-}
-
-
-static void mpris2_watcher_finalize (GObject* obj) {
-	Mpris2Watcher * self;
-	self = MPRIS2_WATCHER (obj);
-	_g_object_unref0 (self->priv->fdesktop_obj);
-	G_OBJECT_CLASS (mpris2_watcher_parent_class)->finalize (obj);
-}
-
-
-GType mpris2_watcher_get_type (void) {
-	static volatile gsize mpris2_watcher_type_id__volatile = 0;
-	if (g_once_init_enter (&mpris2_watcher_type_id__volatile)) {
-		static const GTypeInfo g_define_type_info = { sizeof (Mpris2WatcherClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) mpris2_watcher_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Mpris2Watcher), 0, (GInstanceInitFunc) mpris2_watcher_instance_init, NULL };
-		GType mpris2_watcher_type_id;
-		mpris2_watcher_type_id = g_type_register_static (G_TYPE_OBJECT, "Mpris2Watcher", &g_define_type_info, 0);
-		g_once_init_leave (&mpris2_watcher_type_id__volatile, mpris2_watcher_type_id);
-	}
-	return mpris2_watcher_type_id__volatile;
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-
diff -Naur indicator-sound-0.8.5.0/src/music-player-bridge.c indicator-sound-precise/src/music-player-bridge.c
--- indicator-sound-0.8.5.0/src/music-player-bridge.c	2012-03-30 10:32:34.000000000 -0700
+++ indicator-sound-precise/src/music-player-bridge.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,1420 +0,0 @@
-/* music-player-bridge.c generated by valac 0.14.2, the Vala compiler
- * generated from music-player-bridge.vala, do not modify */
-
-/*
-Copyright 2010 Canonical Ltd.
-
-Authors:
-    Conor Curran <conor.curran@canonical.com>
-
-This program is free software: you can redistribute it and/or modify it 
-under the terms of the GNU General Public License version 3, as published 
-by the Free Software Foundation.
-
-This program is distributed in the hope that it will be useful, but 
-WITHOUT ANY WARRANTY; without even the implied warranties of 
-MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
-PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along 
-with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libdbusmenu-glib/client.h>
-#include <libdbusmenu-glib/dbusmenu-glib.h>
-#include <libdbusmenu-glib/enum-types.h>
-#include <libdbusmenu-glib/menuitem-proxy.h>
-#include <libdbusmenu-glib/menuitem.h>
-#include <libdbusmenu-glib/server.h>
-#include <libdbusmenu-glib/types.h>
-#include <gee.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gio/gio.h>
-#include <gio/gdesktopappinfo.h>
-
-
-#define TYPE_MUSIC_PLAYER_BRIDGE (music_player_bridge_get_type ())
-#define MUSIC_PLAYER_BRIDGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MUSIC_PLAYER_BRIDGE, MusicPlayerBridge))
-#define MUSIC_PLAYER_BRIDGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MUSIC_PLAYER_BRIDGE, MusicPlayerBridgeClass))
-#define IS_MUSIC_PLAYER_BRIDGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MUSIC_PLAYER_BRIDGE))
-#define IS_MUSIC_PLAYER_BRIDGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MUSIC_PLAYER_BRIDGE))
-#define MUSIC_PLAYER_BRIDGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MUSIC_PLAYER_BRIDGE, MusicPlayerBridgeClass))
-
-typedef struct _MusicPlayerBridge MusicPlayerBridge;
-typedef struct _MusicPlayerBridgeClass MusicPlayerBridgeClass;
-typedef struct _MusicPlayerBridgePrivate MusicPlayerBridgePrivate;
-
-#define TYPE_SETTINGS_MANAGER (settings_manager_get_type ())
-#define SETTINGS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SETTINGS_MANAGER, SettingsManager))
-#define SETTINGS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SETTINGS_MANAGER, SettingsManagerClass))
-#define IS_SETTINGS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SETTINGS_MANAGER))
-#define IS_SETTINGS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SETTINGS_MANAGER))
-#define SETTINGS_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SETTINGS_MANAGER, SettingsManagerClass))
-
-typedef struct _SettingsManager SettingsManager;
-typedef struct _SettingsManagerClass SettingsManagerClass;
-
-#define TYPE_PLAYER_CONTROLLER (player_controller_get_type ())
-#define PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONTROLLER, PlayerController))
-#define PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-#define IS_PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONTROLLER))
-#define IS_PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONTROLLER))
-#define PLAYER_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-
-typedef struct _PlayerController PlayerController;
-typedef struct _PlayerControllerClass PlayerControllerClass;
-
-#define TYPE_MPRIS2_WATCHER (mpris2_watcher_get_type ())
-#define MPRIS2_WATCHER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS2_WATCHER, Mpris2Watcher))
-#define MPRIS2_WATCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS2_WATCHER, Mpris2WatcherClass))
-#define IS_MPRIS2_WATCHER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS2_WATCHER))
-#define IS_MPRIS2_WATCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS2_WATCHER))
-#define MPRIS2_WATCHER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS2_WATCHER, Mpris2WatcherClass))
-
-typedef struct _Mpris2Watcher Mpris2Watcher;
-typedef struct _Mpris2WatcherClass Mpris2WatcherClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-
-#define PLAYER_CONTROLLER_TYPE_STATE (player_controller_state_get_type ())
-typedef struct _Block1Data Block1Data;
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-typedef struct _PlayerControllerPrivate PlayerControllerPrivate;
-
-#define TYPE_PLAYER_ITEM (player_item_get_type ())
-#define PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_ITEM, PlayerItem))
-#define PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_ITEM, PlayerItemClass))
-#define IS_PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_ITEM))
-#define IS_PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_ITEM))
-#define PLAYER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_ITEM, PlayerItemClass))
-
-typedef struct _PlayerItem PlayerItem;
-typedef struct _PlayerItemClass PlayerItemClass;
-
-#define TYPE_MPRIS2_CONTROLLER (mpris2_controller_get_type ())
-#define MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2Controller))
-#define MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
-#define IS_MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS2_CONTROLLER))
-#define IS_MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS2_CONTROLLER))
-#define MPRIS2_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
-
-typedef struct _Mpris2Controller Mpris2Controller;
-typedef struct _Mpris2ControllerClass Mpris2ControllerClass;
-#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))
-
-struct _MusicPlayerBridge {
-	GObject parent_instance;
-	MusicPlayerBridgePrivate * priv;
-};
-
-struct _MusicPlayerBridgeClass {
-	GObjectClass parent_class;
-};
-
-struct _MusicPlayerBridgePrivate {
-	SettingsManager* settings_manager;
-	DbusmenuMenuitem* root_menu;
-	GeeHashMap* registered_clients;
-	GeeHashMap* file_monitors;
-	Mpris2Watcher* watcher;
-};
-
-typedef enum  {
-	PLAYER_CONTROLLER_STATE_OFFLINE,
-	PLAYER_CONTROLLER_STATE_INSTANTIATING,
-	PLAYER_CONTROLLER_STATE_READY,
-	PLAYER_CONTROLLER_STATE_CONNECTED,
-	PLAYER_CONTROLLER_STATE_DISCONNECTED
-} PlayerControllerstate;
-
-struct _Block1Data {
-	int _ref_count_;
-	MusicPlayerBridge * self;
-	GFileMonitor* weak_monitor;
-};
-
-struct _PlayerController {
-	GObject parent_instance;
-	PlayerControllerPrivate * priv;
-	gint current_state;
-	DbusmenuMenuitem* root_menu;
-	GeeArrayList* custom_items;
-	Mpris2Controller* mpris_bridge;
-	gboolean* use_playlists;
-};
-
-struct _PlayerControllerClass {
-	GObjectClass parent_class;
-};
-
-
-static gpointer music_player_bridge_parent_class = NULL;
-
-GType music_player_bridge_get_type (void) G_GNUC_CONST;
-GType settings_manager_get_type (void) G_GNUC_CONST;
-GType player_controller_get_type (void) G_GNUC_CONST;
-GType mpris2_watcher_get_type (void) G_GNUC_CONST;
-#define MUSIC_PLAYER_BRIDGE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MUSIC_PLAYER_BRIDGE, MusicPlayerBridgePrivate))
-enum  {
-	MUSIC_PLAYER_BRIDGE_DUMMY_PROPERTY
-};
-#define MUSIC_PLAYER_BRIDGE_DEVICE_ITEMS_COUNT 3
-MusicPlayerBridge* music_player_bridge_new (void);
-MusicPlayerBridge* music_player_bridge_construct (GType object_type);
-static void music_player_bridge_on_blacklist_update (MusicPlayerBridge* self, gchar** blacklist, int blacklist_length1);
-static gchar* music_player_bridge_determine_key (gchar* desktop_or_interface);
-void player_controller_remove_from_menu (PlayerController* self);
-void mpris2_watcher_check_for_active_clients (Mpris2Watcher* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris2_watcher_check_for_active_clients_finish (Mpris2Watcher* self, GAsyncResult* _res_);
-static void music_player_bridge_try_to_add_inactive_familiar_clients (MusicPlayerBridge* self);
-GeeArrayList* settings_manager_fetch_interested (SettingsManager* self);
-static GAppInfo* music_player_bridge_create_app_info (const gchar* desktop);
-static gchar* music_player_bridge_fetch_icon_name (const gchar* desktop);
-static gint music_player_bridge_calculate_menu_position (MusicPlayerBridge* self);
-GType player_controller_state_get_type (void) G_GNUC_CONST;
-PlayerController* player_controller_new (DbusmenuMenuitem* root, GAppInfo* app, const gchar* dbus_name, const gchar* icon_name, gint offset, gboolean* use_playlists, PlayerControllerstate initial_state);
-PlayerController* player_controller_construct (GType object_type, DbusmenuMenuitem* root, GAppInfo* app, const gchar* dbus_name, const gchar* icon_name, gint offset, gboolean* use_playlists, PlayerControllerstate initial_state);
-static void music_player_bridge_establish_file_monitoring (MusicPlayerBridge* self, GAppInfo* info, const gchar* mpris_key);
-static Block1Data* block1_data_ref (Block1Data* _data1_);
-static void block1_data_unref (Block1Data* _data1_);
-static void ___lambda2_ (Block1Data* _data1_, GFile* desktop_file, GFile* other_file, GFileMonitorEvent event_type);
-static void music_player_bridge_relevant_desktop_file_changed (MusicPlayerBridge* self, GFile* desktop_file, GFile* other_file, GFileMonitorEvent event_type, GFileMonitor* monitor);
-static void ____lambda2__g_file_monitor_changed (GFileMonitor* _sender, GFile* file, GFile* other_file, GFileMonitorEvent event_type, gpointer self);
-void settings_manager_remove_interested (SettingsManager* self, const gchar* app_desktop_name);
-#define PLAYER_CONTROLLER_WIDGET_QUANTITY 4
-void music_player_bridge_client_has_become_available (MusicPlayerBridge* self, const gchar* desktop, const gchar* dbus_name, gboolean use_playlists);
-gchar** settings_manager_fetch_blacklist (SettingsManager* self, int* result_length1);
-static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle);
-void settings_manager_add_interested (SettingsManager* self, const gchar* app_desktop_name);
-static gboolean* _bool_dup (gboolean* self);
-GType player_item_get_type (void) G_GNUC_CONST;
-GType mpris2_controller_get_type (void) G_GNUC_CONST;
-void player_controller_update_state (PlayerController* self, PlayerControllerstate new_state);
-void player_controller_activate (PlayerController* self, const gchar* dbus_name);
-void music_player_bridge_client_has_vanished (MusicPlayerBridge* self, const gchar* mpris_root_interface);
-void player_controller_hibernate (PlayerController* self);
-void music_player_bridge_set_root_menu_item (MusicPlayerBridge* self, DbusmenuMenuitem* menu);
-Mpris2Watcher* mpris2_watcher_new (void);
-Mpris2Watcher* mpris2_watcher_construct (GType object_type);
-static void _music_player_bridge_client_has_become_available_mpris2_watcher_client_appeared (Mpris2Watcher* _sender, const gchar* desktop_file_name, const gchar* dbus_name, gboolean use_playlists, gpointer self);
-static void _music_player_bridge_client_has_vanished_mpris2_watcher_client_disappeared (Mpris2Watcher* _sender, const gchar* dbus_name, gpointer self);
-void music_player_bridge_enable_player_specific_items_for_client (MusicPlayerBridge* self, const gchar* object_path, const gchar* desktop_id);
-void player_controller_enable_player_specific_items (PlayerController* self, const gchar* object_path);
-void music_player_bridge_enable_track_specific_items_for_client (MusicPlayerBridge* self, const gchar* object_path, const gchar* desktop_id);
-void player_controller_enable_track_specific_items (PlayerController* self, const gchar* object_path);
-static GObject * music_player_bridge_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
-SettingsManager* settings_manager_new (void);
-SettingsManager* settings_manager_construct (GType object_type);
-static void _music_player_bridge_on_blacklist_update_settings_manager_blacklist_updates (SettingsManager* _sender, gchar** new_blacklist, int new_blacklist_length1, gpointer self);
-static void music_player_bridge_finalize (GObject* obj);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static gint _vala_array_length (gpointer array);
-
-
-MusicPlayerBridge* music_player_bridge_construct (GType object_type) {
-	MusicPlayerBridge * self = NULL;
-	self = (MusicPlayerBridge*) g_object_new (object_type, NULL);
-	return self;
-}
-
-
-MusicPlayerBridge* music_player_bridge_new (void) {
-	return music_player_bridge_construct (TYPE_MUSIC_PLAYER_BRIDGE);
-}
-
-
-static void music_player_bridge_on_blacklist_update (MusicPlayerBridge* self, gchar** blacklist, int blacklist_length1) {
-	gchar** _tmp0_;
-	gint _tmp0__length1;
-	Mpris2Watcher* _tmp15_;
-	g_return_if_fail (self != NULL);
-	g_debug ("music-player-bridge.vala:47: some blacklist update");
-	_tmp0_ = blacklist;
-	_tmp0__length1 = blacklist_length1;
-	{
-		gchar** s_collection = NULL;
-		gint s_collection_length1 = 0;
-		gint _s_collection_size_ = 0;
-		gint s_it = 0;
-		s_collection = _tmp0_;
-		s_collection_length1 = _tmp0__length1;
-		for (s_it = 0; s_it < _tmp0__length1; s_it = s_it + 1) {
-			gchar* _tmp1_;
-			gchar* s = NULL;
-			_tmp1_ = g_strdup (s_collection[s_it]);
-			s = _tmp1_;
-			{
-				const gchar* _tmp2_;
-				gchar* _tmp3_;
-				gchar* _tmp4_ = NULL;
-				gchar* key;
-				GeeHashMap* _tmp5_;
-				const gchar* _tmp6_;
-				gboolean _tmp7_ = FALSE;
-				_tmp2_ = s;
-				_tmp3_ = g_strdup (_tmp2_);
-				_tmp4_ = music_player_bridge_determine_key (_tmp3_);
-				key = _tmp4_;
-				_tmp5_ = self->priv->registered_clients;
-				_tmp6_ = key;
-				_tmp7_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp5_, _tmp6_);
-				if (_tmp7_) {
-					const gchar* _tmp8_;
-					GeeHashMap* _tmp9_;
-					const gchar* _tmp10_;
-					gpointer _tmp11_ = NULL;
-					PlayerController* _tmp12_;
-					GeeHashMap* _tmp13_;
-					const gchar* _tmp14_;
-					_tmp8_ = key;
-					g_debug ("music-player-bridge.vala:52: Apparently %s is now blacklisted - remove" \
-" thy self", _tmp8_);
-					_tmp9_ = self->priv->registered_clients;
-					_tmp10_ = key;
-					_tmp11_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp9_, _tmp10_);
-					_tmp12_ = (PlayerController*) _tmp11_;
-					player_controller_remove_from_menu (_tmp12_);
-					_g_object_unref0 (_tmp12_);
-					_tmp13_ = self->priv->registered_clients;
-					_tmp14_ = key;
-					gee_abstract_map_unset ((GeeAbstractMap*) _tmp13_, _tmp14_, NULL);
-				}
-				_g_free0 (key);
-				_g_free0 (s);
-			}
-		}
-	}
-	_tmp15_ = self->priv->watcher;
-	mpris2_watcher_check_for_active_clients (_tmp15_, NULL, NULL);
-}
-
-
-static void music_player_bridge_try_to_add_inactive_familiar_clients (MusicPlayerBridge* self) {
-	g_return_if_fail (self != NULL);
-	{
-		SettingsManager* _tmp0_;
-		GeeArrayList* _tmp1_ = NULL;
-		GeeArrayList* _desktop_list;
-		GeeArrayList* _tmp2_;
-		gint _tmp3_;
-		gint _tmp4_;
-		gint _desktop_size;
-		gint _desktop_index;
-		_tmp0_ = self->priv->settings_manager;
-		_tmp1_ = settings_manager_fetch_interested (_tmp0_);
-		_desktop_list = _tmp1_;
-		_tmp2_ = _desktop_list;
-		_tmp3_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp2_);
-		_tmp4_ = _tmp3_;
-		_desktop_size = _tmp4_;
-		_desktop_index = -1;
-		while (TRUE) {
-			gint _tmp5_;
-			gint _tmp6_;
-			gint _tmp7_;
-			GeeArrayList* _tmp8_;
-			gint _tmp9_;
-			gpointer _tmp10_ = NULL;
-			gchar* desktop;
-			const gchar* _tmp11_;
-			const gchar* _tmp12_;
-			gchar* _tmp13_ = NULL;
-			gchar* _tmp14_;
-			GAppInfo* _tmp15_ = NULL;
-			GAppInfo* _tmp16_;
-			GAppInfo* app_info;
-			GAppInfo* _tmp17_;
-			const gchar* _tmp19_;
-			gchar* _tmp20_;
-			gchar* _tmp21_ = NULL;
-			gchar* mpris_key;
-			DbusmenuMenuitem* _tmp22_;
-			GAppInfo* _tmp23_;
-			const gchar* _tmp24_;
-			gchar* _tmp25_ = NULL;
-			gchar* _tmp26_;
-			gint _tmp27_ = 0;
-			PlayerController* _tmp28_;
-			PlayerController* _tmp29_;
-			PlayerController* ctrl;
-			GeeHashMap* _tmp30_;
-			const gchar* _tmp31_;
-			PlayerController* _tmp32_;
-			GAppInfo* _tmp33_;
-			const gchar* _tmp34_;
-			_tmp5_ = _desktop_index;
-			_desktop_index = _tmp5_ + 1;
-			_tmp6_ = _desktop_index;
-			_tmp7_ = _desktop_size;
-			if (!(_tmp6_ < _tmp7_)) {
-				break;
-			}
-			_tmp8_ = _desktop_list;
-			_tmp9_ = _desktop_index;
-			_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, _tmp9_);
-			desktop = (gchar*) _tmp10_;
-			_tmp11_ = desktop;
-			g_debug ("music-player-bridge.vala:64: interested client found : %s", _tmp11_);
-			_tmp12_ = desktop;
-			_tmp13_ = g_strconcat (_tmp12_, ".desktop", NULL);
-			_tmp14_ = _tmp13_;
-			_tmp15_ = music_player_bridge_create_app_info (_tmp14_);
-			_tmp16_ = _tmp15_;
-			_g_free0 (_tmp14_);
-			app_info = _tmp16_;
-			_tmp17_ = app_info;
-			if (_tmp17_ == NULL) {
-				const gchar* _tmp18_;
-				_tmp18_ = desktop;
-				g_warning ("music-player-bridge.vala:67: Could not create app_info for path %s \n" \
-" Getting out of here ", _tmp18_);
-				_g_object_unref0 (app_info);
-				_g_free0 (desktop);
-				continue;
-			}
-			_tmp19_ = desktop;
-			_tmp20_ = g_strdup (_tmp19_);
-			_tmp21_ = music_player_bridge_determine_key (_tmp20_);
-			mpris_key = _tmp21_;
-			_tmp22_ = self->priv->root_menu;
-			_tmp23_ = app_info;
-			_tmp24_ = desktop;
-			_tmp25_ = music_player_bridge_fetch_icon_name (_tmp24_);
-			_tmp26_ = _tmp25_;
-			_tmp27_ = music_player_bridge_calculate_menu_position (self);
-			_tmp28_ = player_controller_new (_tmp22_, _tmp23_, NULL, _tmp26_, _tmp27_, NULL, PLAYER_CONTROLLER_STATE_OFFLINE);
-			_tmp29_ = _tmp28_;
-			_g_free0 (_tmp26_);
-			ctrl = _tmp29_;
-			_tmp30_ = self->priv->registered_clients;
-			_tmp31_ = mpris_key;
-			_tmp32_ = ctrl;
-			gee_abstract_map_set ((GeeAbstractMap*) _tmp30_, _tmp31_, _tmp32_);
-			_tmp33_ = app_info;
-			_tmp34_ = mpris_key;
-			music_player_bridge_establish_file_monitoring (self, _tmp33_, _tmp34_);
-			_g_object_unref0 (ctrl);
-			_g_free0 (mpris_key);
-			_g_object_unref0 (app_info);
-			_g_free0 (desktop);
-		}
-		_g_object_unref0 (_desktop_list);
-	}
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static Block1Data* block1_data_ref (Block1Data* _data1_) {
-	g_atomic_int_inc (&_data1_->_ref_count_);
-	return _data1_;
-}
-
-
-static void block1_data_unref (Block1Data* _data1_) {
-	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
-		_g_object_unref0 (_data1_->self);
-		g_slice_free (Block1Data, _data1_);
-	}
-}
-
-
-static void ___lambda2_ (Block1Data* _data1_, GFile* desktop_file, GFile* other_file, GFileMonitorEvent event_type) {
-	MusicPlayerBridge * self;
-	GFile* _tmp0_;
-	GFile* _tmp1_;
-	GFileMonitorEvent _tmp2_;
-	GFileMonitor* _tmp3_;
-	self = _data1_->self;
-	g_return_if_fail (desktop_file != NULL);
-	_tmp0_ = desktop_file;
-	_tmp1_ = other_file;
-	_tmp2_ = event_type;
-	_tmp3_ = _data1_->weak_monitor;
-	music_player_bridge_relevant_desktop_file_changed (self, _tmp0_, _tmp1_, _tmp2_, _tmp3_);
-}
-
-
-static void ____lambda2__g_file_monitor_changed (GFileMonitor* _sender, GFile* file, GFile* other_file, GFileMonitorEvent event_type, gpointer self) {
-	___lambda2_ (self, file, other_file, event_type);
-}
-
-
-static void music_player_bridge_establish_file_monitoring (MusicPlayerBridge* self, GAppInfo* info, const gchar* mpris_key) {
-	GAppInfo* _tmp0_;
-	GDesktopAppInfo* _tmp1_;
-	GDesktopAppInfo* desktop_info;
-	GDesktopAppInfo* _tmp2_;
-	const gchar* _tmp3_ = NULL;
-	gchar* _tmp4_;
-	gchar* file_path;
-	const gchar* _tmp5_;
-	GFile* _tmp6_ = NULL;
-	GFile* f;
-	GError * _inner_error_ = NULL;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (info != NULL);
-	g_return_if_fail (mpris_key != NULL);
-	_tmp0_ = info;
-	_tmp1_ = _g_object_ref0 (G_IS_DESKTOP_APP_INFO (_tmp0_) ? ((GDesktopAppInfo*) _tmp0_) : NULL);
-	desktop_info = _tmp1_;
-	_tmp2_ = desktop_info;
-	_tmp3_ = g_desktop_app_info_get_filename (_tmp2_);
-	_tmp4_ = g_strdup (_tmp3_);
-	file_path = _tmp4_;
-	_tmp5_ = file_path;
-	_tmp6_ = g_file_new_for_path (_tmp5_);
-	f = _tmp6_;
-	{
-		Block1Data* _data1_;
-		GFile* _tmp7_;
-		GFileMonitor* _tmp8_ = NULL;
-		GFileMonitor* _tmp9_;
-		GFileMonitor* monitor;
-		GFileMonitor* _tmp10_;
-		GFileMonitor* _tmp11_;
-		GFileMonitor* _tmp12_;
-		const gchar* _tmp13_;
-		GeeHashMap* _tmp14_;
-		const gchar* _tmp15_;
-		const gchar* _tmp16_;
-		_data1_ = g_slice_new0 (Block1Data);
-		_data1_->_ref_count_ = 1;
-		_data1_->self = g_object_ref (self);
-		_tmp7_ = f;
-		_tmp8_ = g_file_monitor (_tmp7_, G_FILE_MONITOR_SEND_MOVED, NULL, &_inner_error_);
-		_tmp9_ = _g_object_ref0 (_tmp8_);
-		monitor = _tmp9_;
-		if (_inner_error_ != NULL) {
-			block1_data_unref (_data1_);
-			_data1_ = NULL;
-			goto __catch0_g_error;
-		}
-		_tmp10_ = monitor;
-		_data1_->weak_monitor = _tmp10_;
-		_tmp11_ = monitor;
-		g_signal_connect_data (_tmp11_, "changed", (GCallback) ____lambda2__g_file_monitor_changed, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
-		_tmp12_ = monitor;
-		g_object_ref ((GObject*) _tmp12_);
-		_tmp13_ = file_path;
-		g_debug ("music-player-bridge.vala:95: monitoring file '%s'", _tmp13_);
-		_tmp14_ = self->priv->file_monitors;
-		_tmp15_ = file_path;
-		_tmp16_ = mpris_key;
-		gee_abstract_map_set ((GeeAbstractMap*) _tmp14_, _tmp15_, _tmp16_);
-		_g_object_unref0 (monitor);
-		block1_data_unref (_data1_);
-		_data1_ = NULL;
-	}
-	goto __finally0;
-	__catch0_g_error:
-	{
-		GError* e = NULL;
-		GAppInfo* _tmp17_;
-		const gchar* _tmp18_ = NULL;
-		e = _inner_error_;
-		_inner_error_ = NULL;
-		_tmp17_ = info;
-		_tmp18_ = g_app_info_get_name (_tmp17_);
-		g_warning ("music-player-bridge.vala:99: Unable to create a file monitor for %s", _tmp18_);
-		_g_error_free0 (e);
-		_g_object_unref0 (f);
-		_g_free0 (file_path);
-		_g_object_unref0 (desktop_info);
-		return;
-	}
-	__finally0:
-	if (_inner_error_ != NULL) {
-		_g_object_unref0 (f);
-		_g_free0 (file_path);
-		_g_object_unref0 (desktop_info);
-		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-	_g_object_unref0 (f);
-	_g_free0 (file_path);
-	_g_object_unref0 (desktop_info);
-}
-
-
-static void music_player_bridge_relevant_desktop_file_changed (MusicPlayerBridge* self, GFile* desktop_file, GFile* other_file, GFileMonitorEvent event_type, GFileMonitor* monitor) {
-	GFileMonitorEvent _tmp0_;
-	GFile* _tmp1_;
-	gchar* _tmp2_ = NULL;
-	gchar* path;
-	const gchar* _tmp3_;
-	GeeHashMap* _tmp4_;
-	const gchar* _tmp5_;
-	gboolean _tmp6_ = FALSE;
-	GeeHashMap* _tmp8_;
-	const gchar* _tmp9_;
-	gpointer _tmp10_ = NULL;
-	gchar* mpris_key;
-	const gchar* _tmp11_;
-	const gchar* _tmp12_;
-	GeeHashMap* _tmp13_;
-	const gchar* _tmp14_;
-	gpointer _tmp15_ = NULL;
-	PlayerController* _tmp16_;
-	SettingsManager* _tmp17_;
-	const gchar* _tmp18_;
-	GeeHashMap* _tmp19_;
-	const gchar* _tmp20_;
-	GFileMonitor* _tmp21_;
-	GFileMonitor* _tmp22_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (desktop_file != NULL);
-	g_return_if_fail (monitor != NULL);
-	_tmp0_ = event_type;
-	if (_tmp0_ != G_FILE_MONITOR_EVENT_DELETED) {
-		return;
-	}
-	_tmp1_ = desktop_file;
-	_tmp2_ = g_file_get_path (_tmp1_);
-	path = _tmp2_;
-	_tmp3_ = path;
-	if (_tmp3_ == NULL) {
-		g_warning ("music-player-bridge.vala:114: relevant_desktop_file_changed is returni" \
-"ng a file with no path !");
-		_g_free0 (path);
-		return;
-	}
-	_tmp4_ = self->priv->file_monitors;
-	_tmp5_ = path;
-	_tmp6_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp4_, _tmp5_);
-	if (!_tmp6_) {
-		const gchar* _tmp7_;
-		_tmp7_ = path;
-		g_warning ("music-player-bridge.vala:118: relevant_desktop_file_changed is returni" \
-"ng a file which we know nothing about - %s", _tmp7_);
-		_g_free0 (path);
-		return;
-	}
-	_tmp8_ = self->priv->file_monitors;
-	_tmp9_ = path;
-	_tmp10_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp8_, _tmp9_);
-	mpris_key = (gchar*) _tmp10_;
-	_tmp11_ = path;
-	_tmp12_ = mpris_key;
-	g_debug ("music-player-bridge.vala:124: file \"%s\" was removed; stopping monito" \
-"ring \"%s\"", _tmp11_, _tmp12_);
-	_tmp13_ = self->priv->registered_clients;
-	_tmp14_ = mpris_key;
-	_tmp15_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp13_, _tmp14_);
-	_tmp16_ = (PlayerController*) _tmp15_;
-	player_controller_remove_from_menu (_tmp16_);
-	_g_object_unref0 (_tmp16_);
-	_tmp17_ = self->priv->settings_manager;
-	_tmp18_ = mpris_key;
-	settings_manager_remove_interested (_tmp17_, _tmp18_);
-	_tmp19_ = self->priv->registered_clients;
-	_tmp20_ = mpris_key;
-	gee_abstract_map_unset ((GeeAbstractMap*) _tmp19_, _tmp20_, NULL);
-	_tmp21_ = monitor;
-	g_file_monitor_cancel (_tmp21_);
-	_tmp22_ = monitor;
-	g_object_unref ((GObject*) _tmp22_);
-	_g_free0 (mpris_key);
-	_g_free0 (path);
-}
-
-
-static gint music_player_bridge_calculate_menu_position (MusicPlayerBridge* self) {
-	gint result = 0;
-	GeeHashMap* _tmp0_;
-	gint _tmp1_;
-	gint _tmp2_;
-	g_return_val_if_fail (self != NULL, 0);
-	_tmp0_ = self->priv->registered_clients;
-	_tmp1_ = gee_abstract_map_get_size ((GeeMap*) _tmp0_);
-	_tmp2_ = _tmp1_;
-	if (_tmp2_ == 0) {
-		result = MUSIC_PLAYER_BRIDGE_DEVICE_ITEMS_COUNT;
-		return result;
-	} else {
-		GeeHashMap* _tmp3_;
-		gint _tmp4_;
-		gint _tmp5_;
-		_tmp3_ = self->priv->registered_clients;
-		_tmp4_ = gee_abstract_map_get_size ((GeeMap*) _tmp3_);
-		_tmp5_ = _tmp4_;
-		result = MUSIC_PLAYER_BRIDGE_DEVICE_ITEMS_COUNT + (_tmp5_ * PLAYER_CONTROLLER_WIDGET_QUANTITY);
-		return result;
-	}
-}
-
-
-static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle) {
-	int i;
-	for (i = 0; i < stack_length; i++) {
-		if (g_strcmp0 (stack[i], needle) == 0) {
-			return TRUE;
-		}
-	}
-	return FALSE;
-}
-
-
-static gboolean* _bool_dup (gboolean* self) {
-	gboolean* dup;
-	dup = g_new0 (gboolean, 1);
-	memcpy (dup, self, sizeof (gboolean));
-	return dup;
-}
-
-
-static gpointer __bool_dup0 (gpointer self) {
-	return self ? _bool_dup (self) : NULL;
-}
-
-
-static gchar* bool_to_string (gboolean self) {
-	gchar* result = NULL;
-	if (self) {
-		gchar* _tmp0_;
-		_tmp0_ = g_strdup ("true");
-		result = _tmp0_;
-		return result;
-	} else {
-		gchar* _tmp1_;
-		_tmp1_ = g_strdup ("false");
-		result = _tmp1_;
-		return result;
-	}
-}
-
-
-void music_player_bridge_client_has_become_available (MusicPlayerBridge* self, const gchar* desktop, const gchar* dbus_name, gboolean use_playlists) {
-	gboolean _tmp0_ = FALSE;
-	const gchar* _tmp1_;
-	gboolean _tmp3_;
-	const gchar* _tmp5_;
-	SettingsManager* _tmp6_;
-	gint _tmp7_ = 0;
-	gchar** _tmp8_ = NULL;
-	gchar** _tmp9_;
-	gint _tmp9__length1;
-	gboolean _tmp10_;
-	const gchar* _tmp12_;
-	const gchar* _tmp13_;
-	gchar* _tmp14_ = NULL;
-	gchar* _tmp15_;
-	GAppInfo* _tmp16_ = NULL;
-	GAppInfo* _tmp17_;
-	GAppInfo* app_info;
-	GAppInfo* _tmp18_;
-	const gchar* _tmp20_;
-	gchar* _tmp21_;
-	gchar* _tmp22_ = NULL;
-	gchar* mpris_key;
-	GeeHashMap* _tmp23_;
-	const gchar* _tmp24_;
-	gboolean _tmp25_ = FALSE;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (desktop != NULL);
-	g_return_if_fail (dbus_name != NULL);
-	_tmp1_ = desktop;
-	if (_tmp1_ == NULL) {
-		_tmp0_ = TRUE;
-	} else {
-		const gchar* _tmp2_;
-		_tmp2_ = desktop;
-		_tmp0_ = g_strcmp0 (_tmp2_, "") == 0;
-	}
-	_tmp3_ = _tmp0_;
-	if (_tmp3_) {
-		const gchar* _tmp4_;
-		_tmp4_ = dbus_name;
-		g_warning ("music-player-bridge.vala:147: Client %s attempting to register without" \
-" desktop entry being set on the mpris root", _tmp4_);
-		return;
-	}
-	_tmp5_ = desktop;
-	_tmp6_ = self->priv->settings_manager;
-	_tmp8_ = settings_manager_fetch_blacklist (_tmp6_, &_tmp7_);
-	_tmp9_ = _tmp8_;
-	_tmp9__length1 = _tmp7_;
-	_tmp10_ = _vala_string_array_contains (_tmp9_, _tmp7_, _tmp5_);
-	_tmp9_ = (_vala_array_free (_tmp9_, _tmp9__length1, (GDestroyNotify) g_free), NULL);
-	if (_tmp10_) {
-		const gchar* _tmp11_;
-		_tmp11_ = desktop;
-		g_debug ("music-player-bridge.vala:152: Client %s attempting to register but I'm" \
-" afraid it is blacklisted", _tmp11_);
-		return;
-	}
-	_tmp12_ = desktop;
-	g_debug ("music-player-bridge.vala:157: client_has_become_available %s", _tmp12_);
-	_tmp13_ = desktop;
-	_tmp14_ = g_strconcat (_tmp13_, ".desktop", NULL);
-	_tmp15_ = _tmp14_;
-	_tmp16_ = music_player_bridge_create_app_info (_tmp15_);
-	_tmp17_ = _tmp16_;
-	_g_free0 (_tmp15_);
-	app_info = _tmp17_;
-	_tmp18_ = app_info;
-	if (_tmp18_ == NULL) {
-		const gchar* _tmp19_;
-		_tmp19_ = desktop;
-		g_warning ("music-player-bridge.vala:160: Could not create app_info for path %s \n" \
-" Getting out of here ", _tmp19_);
-		_g_object_unref0 (app_info);
-		return;
-	}
-	_tmp20_ = desktop;
-	_tmp21_ = g_strdup (_tmp20_);
-	_tmp22_ = music_player_bridge_determine_key (_tmp21_);
-	mpris_key = _tmp22_;
-	_tmp23_ = self->priv->registered_clients;
-	_tmp24_ = mpris_key;
-	_tmp25_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp23_, _tmp24_);
-	if (_tmp25_ == FALSE) {
-		const gchar* _tmp26_;
-		DbusmenuMenuitem* _tmp27_;
-		GAppInfo* _tmp28_;
-		const gchar* _tmp29_;
-		const gchar* _tmp30_;
-		gchar* _tmp31_ = NULL;
-		gchar* _tmp32_;
-		gint _tmp33_ = 0;
-		gboolean _tmp34_;
-		PlayerController* _tmp35_;
-		PlayerController* _tmp36_;
-		PlayerController* ctrl;
-		GeeHashMap* _tmp37_;
-		const gchar* _tmp38_;
-		PlayerController* _tmp39_;
-		const gchar* _tmp40_;
-		SettingsManager* _tmp41_;
-		const gchar* _tmp42_;
-		GAppInfo* _tmp43_;
-		const gchar* _tmp44_;
-		_tmp26_ = dbus_name;
-		g_debug ("music-player-bridge.vala:168: New client has registered that we have n" \
-"ot seen before: %s", _tmp26_);
-		_tmp27_ = self->priv->root_menu;
-		_tmp28_ = app_info;
-		_tmp29_ = dbus_name;
-		_tmp30_ = desktop;
-		_tmp31_ = music_player_bridge_fetch_icon_name (_tmp30_);
-		_tmp32_ = _tmp31_;
-		_tmp33_ = music_player_bridge_calculate_menu_position (self);
-		_tmp34_ = use_playlists;
-		_tmp35_ = player_controller_new (_tmp27_, _tmp28_, _tmp29_, _tmp32_, _tmp33_, &_tmp34_, PLAYER_CONTROLLER_STATE_READY);
-		_tmp36_ = _tmp35_;
-		_g_free0 (_tmp32_);
-		ctrl = _tmp36_;
-		_tmp37_ = self->priv->registered_clients;
-		_tmp38_ = mpris_key;
-		_tmp39_ = ctrl;
-		gee_abstract_map_set ((GeeAbstractMap*) _tmp37_, _tmp38_, _tmp39_);
-		_tmp40_ = desktop;
-		g_debug ("music-player-bridge.vala:177: Have not seen this %s before, new contro" \
-"ller created.", _tmp40_);
-		_tmp41_ = self->priv->settings_manager;
-		_tmp42_ = desktop;
-		settings_manager_add_interested (_tmp41_, _tmp42_);
-		_tmp43_ = app_info;
-		_tmp44_ = mpris_key;
-		music_player_bridge_establish_file_monitoring (self, _tmp43_, _tmp44_);
-		g_debug ("music-player-bridge.vala:180: application added to the interested list");
-		_g_object_unref0 (ctrl);
-	} else {
-		GeeHashMap* _tmp45_;
-		const gchar* _tmp46_;
-		gpointer _tmp47_ = NULL;
-		PlayerController* _tmp48_;
-		gboolean _tmp49_;
-		gboolean* _tmp50_;
-		GeeHashMap* _tmp51_;
-		const gchar* _tmp52_;
-		gpointer _tmp53_ = NULL;
-		PlayerController* _tmp54_;
-		GeeHashMap* _tmp55_;
-		const gchar* _tmp56_;
-		gpointer _tmp57_ = NULL;
-		PlayerController* _tmp58_;
-		const gchar* _tmp59_;
-		const gchar* _tmp60_;
-		gboolean _tmp61_;
-		gchar* _tmp62_ = NULL;
-		gchar* _tmp63_;
-		_tmp45_ = self->priv->registered_clients;
-		_tmp46_ = mpris_key;
-		_tmp47_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp45_, _tmp46_);
-		_tmp48_ = (PlayerController*) _tmp47_;
-		_tmp49_ = use_playlists;
-		_tmp50_ = __bool_dup0 (&_tmp49_);
-		_g_free0 (_tmp48_->use_playlists);
-		_tmp48_->use_playlists = _tmp50_;
-		_g_object_unref0 (_tmp48_);
-		_tmp51_ = self->priv->registered_clients;
-		_tmp52_ = mpris_key;
-		_tmp53_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp51_, _tmp52_);
-		_tmp54_ = (PlayerController*) _tmp53_;
-		player_controller_update_state (_tmp54_, PLAYER_CONTROLLER_STATE_READY);
-		_g_object_unref0 (_tmp54_);
-		_tmp55_ = self->priv->registered_clients;
-		_tmp56_ = mpris_key;
-		_tmp57_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp55_, _tmp56_);
-		_tmp58_ = (PlayerController*) _tmp57_;
-		_tmp59_ = dbus_name;
-		player_controller_activate (_tmp58_, _tmp59_);
-		_g_object_unref0 (_tmp58_);
-		_tmp60_ = dbus_name;
-		_tmp61_ = use_playlists;
-		_tmp62_ = bool_to_string (_tmp61_);
-		_tmp63_ = _tmp62_;
-		g_debug ("music-player-bridge.vala:186: Application has already registered - awa" \
-"ken the hibernation: %s with playlists %s \n", _tmp60_, _tmp63_);
-		_g_free0 (_tmp63_);
-	}
-	_g_free0 (mpris_key);
-	_g_object_unref0 (app_info);
-}
-
-
-void music_player_bridge_client_has_vanished (MusicPlayerBridge* self, const gchar* mpris_root_interface) {
-	const gchar* _tmp0_;
-	DbusmenuMenuitem* _tmp1_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (mpris_root_interface != NULL);
-	_tmp0_ = mpris_root_interface;
-	g_debug ("music-player-bridge.vala:192: MusicPlayerBridge -> client with dbus in" \
-"terface %s has vanished", _tmp0_);
-	_tmp1_ = self->priv->root_menu;
-	if (_tmp1_ != NULL) {
-		const gchar* _tmp2_;
-		const gchar* _tmp3_;
-		gchar* _tmp4_;
-		gchar* _tmp5_ = NULL;
-		gchar* mpris_key;
-		gboolean _tmp6_ = FALSE;
-		const gchar* _tmp7_;
-		gboolean _tmp11_;
-		_tmp2_ = mpris_root_interface;
-		g_debug ("music-player-bridge.vala:195: attempt to remove %s", _tmp2_);
-		_tmp3_ = mpris_root_interface;
-		_tmp4_ = g_strdup (_tmp3_);
-		_tmp5_ = music_player_bridge_determine_key (_tmp4_);
-		mpris_key = _tmp5_;
-		_tmp7_ = mpris_key;
-		if (_tmp7_ != NULL) {
-			GeeHashMap* _tmp8_;
-			const gchar* _tmp9_;
-			gboolean _tmp10_ = FALSE;
-			_tmp8_ = self->priv->registered_clients;
-			_tmp9_ = mpris_key;
-			_tmp10_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp8_, _tmp9_);
-			_tmp6_ = _tmp10_;
-		} else {
-			_tmp6_ = FALSE;
-		}
-		_tmp11_ = _tmp6_;
-		if (_tmp11_) {
-			GeeHashMap* _tmp12_;
-			const gchar* _tmp13_;
-			gpointer _tmp14_ = NULL;
-			PlayerController* _tmp15_;
-			const gchar* _tmp16_;
-			_tmp12_ = self->priv->registered_clients;
-			_tmp13_ = mpris_key;
-			_tmp14_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp12_, _tmp13_);
-			_tmp15_ = (PlayerController*) _tmp14_;
-			player_controller_hibernate (_tmp15_);
-			_g_object_unref0 (_tmp15_);
-			_tmp16_ = mpris_key;
-			g_debug ("music-player-bridge.vala:199: Successively offlined client %s", _tmp16_);
-		}
-		_g_free0 (mpris_key);
-	}
-}
-
-
-static void _music_player_bridge_client_has_become_available_mpris2_watcher_client_appeared (Mpris2Watcher* _sender, const gchar* desktop_file_name, const gchar* dbus_name, gboolean use_playlists, gpointer self) {
-	music_player_bridge_client_has_become_available (self, desktop_file_name, dbus_name, use_playlists);
-}
-
-
-static void _music_player_bridge_client_has_vanished_mpris2_watcher_client_disappeared (Mpris2Watcher* _sender, const gchar* dbus_name, gpointer self) {
-	music_player_bridge_client_has_vanished (self, dbus_name);
-}
-
-
-void music_player_bridge_set_root_menu_item (MusicPlayerBridge* self, DbusmenuMenuitem* menu) {
-	DbusmenuMenuitem* _tmp0_;
-	DbusmenuMenuitem* _tmp1_;
-	Mpris2Watcher* _tmp2_;
-	Mpris2Watcher* _tmp3_;
-	Mpris2Watcher* _tmp4_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (menu != NULL);
-	_tmp0_ = menu;
-	_tmp1_ = _g_object_ref0 (_tmp0_);
-	_g_object_unref0 (self->priv->root_menu);
-	self->priv->root_menu = _tmp1_;
-	music_player_bridge_try_to_add_inactive_familiar_clients (self);
-	_tmp2_ = mpris2_watcher_new ();
-	_g_object_unref0 (self->priv->watcher);
-	self->priv->watcher = _tmp2_;
-	_tmp3_ = self->priv->watcher;
-	g_signal_connect_object (_tmp3_, "client-appeared", (GCallback) _music_player_bridge_client_has_become_available_mpris2_watcher_client_appeared, self, 0);
-	_tmp4_ = self->priv->watcher;
-	g_signal_connect_object (_tmp4_, "client-disappeared", (GCallback) _music_player_bridge_client_has_vanished_mpris2_watcher_client_disappeared, self, 0);
-}
-
-
-void music_player_bridge_enable_player_specific_items_for_client (MusicPlayerBridge* self, const gchar* object_path, const gchar* desktop_id) {
-	const gchar* _tmp0_;
-	gchar* _tmp1_;
-	gchar* _tmp2_ = NULL;
-	gchar* mpris_key;
-	GeeHashMap* _tmp3_;
-	const gchar* _tmp4_;
-	gboolean _tmp5_ = FALSE;
-	GeeHashMap* _tmp7_;
-	const gchar* _tmp8_;
-	gpointer _tmp9_ = NULL;
-	PlayerController* _tmp10_;
-	const gchar* _tmp11_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (object_path != NULL);
-	g_return_if_fail (desktop_id != NULL);
-	_tmp0_ = desktop_id;
-	_tmp1_ = g_strdup (_tmp0_);
-	_tmp2_ = music_player_bridge_determine_key (_tmp1_);
-	mpris_key = _tmp2_;
-	_tmp3_ = self->priv->registered_clients;
-	_tmp4_ = mpris_key;
-	_tmp5_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp3_, _tmp4_);
-	if (_tmp5_ == FALSE) {
-		const gchar* _tmp6_;
-		_tmp6_ = desktop_id;
-		g_warning ("music-player-bridge.vala:218: we don't have a client with desktop id %" \
-"s registered", _tmp6_);
-		_g_free0 (mpris_key);
-		return;
-	}
-	_tmp7_ = self->priv->registered_clients;
-	_tmp8_ = mpris_key;
-	_tmp9_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp7_, _tmp8_);
-	_tmp10_ = (PlayerController*) _tmp9_;
-	_tmp11_ = object_path;
-	player_controller_enable_player_specific_items (_tmp10_, _tmp11_);
-	_g_object_unref0 (_tmp10_);
-	_g_free0 (mpris_key);
-}
-
-
-void music_player_bridge_enable_track_specific_items_for_client (MusicPlayerBridge* self, const gchar* object_path, const gchar* desktop_id) {
-	const gchar* _tmp0_;
-	gchar* _tmp1_;
-	gchar* _tmp2_ = NULL;
-	gchar* mpris_key;
-	GeeHashMap* _tmp3_;
-	const gchar* _tmp4_;
-	gboolean _tmp5_ = FALSE;
-	GeeHashMap* _tmp7_;
-	const gchar* _tmp8_;
-	gpointer _tmp9_ = NULL;
-	PlayerController* _tmp10_;
-	const gchar* _tmp11_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (object_path != NULL);
-	g_return_if_fail (desktop_id != NULL);
-	_tmp0_ = desktop_id;
-	_tmp1_ = g_strdup (_tmp0_);
-	_tmp2_ = music_player_bridge_determine_key (_tmp1_);
-	mpris_key = _tmp2_;
-	_tmp3_ = self->priv->registered_clients;
-	_tmp4_ = mpris_key;
-	_tmp5_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp3_, _tmp4_);
-	if (_tmp5_ == FALSE) {
-		const gchar* _tmp6_;
-		_tmp6_ = desktop_id;
-		g_warning ("music-player-bridge.vala:229: we don't have a client with desktop id %" \
-"s registered", _tmp6_);
-		_g_free0 (mpris_key);
-		return;
-	}
-	_tmp7_ = self->priv->registered_clients;
-	_tmp8_ = mpris_key;
-	_tmp9_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp7_, _tmp8_);
-	_tmp10_ = (PlayerController*) _tmp9_;
-	_tmp11_ = object_path;
-	player_controller_enable_track_specific_items (_tmp10_, _tmp11_);
-	_g_object_unref0 (_tmp10_);
-	_g_free0 (mpris_key);
-}
-
-
-static GAppInfo* music_player_bridge_create_app_info (const gchar* desktop) {
-	GAppInfo* result = NULL;
-	const gchar* _tmp0_;
-	GDesktopAppInfo* _tmp1_;
-	GDesktopAppInfo* info;
-	gboolean _tmp2_ = FALSE;
-	const gchar* _tmp3_;
-	gboolean _tmp5_;
-	GDesktopAppInfo* _tmp7_;
-	GAppInfo* _tmp8_;
-	GAppInfo* app_info;
-	g_return_val_if_fail (desktop != NULL, NULL);
-	_tmp0_ = desktop;
-	_tmp1_ = g_desktop_app_info_new (_tmp0_);
-	info = _tmp1_;
-	_tmp3_ = desktop;
-	if (_tmp3_ == NULL) {
-		_tmp2_ = TRUE;
-	} else {
-		GDesktopAppInfo* _tmp4_;
-		_tmp4_ = info;
-		_tmp2_ = _tmp4_ == NULL;
-	}
-	_tmp5_ = _tmp2_;
-	if (_tmp5_) {
-		const gchar* _tmp6_;
-		_tmp6_ = desktop;
-		g_warning ("music-player-bridge.vala:239: Could not create a desktopappinfo instan" \
-"ce from app: %s", _tmp6_);
-		result = NULL;
-		_g_object_unref0 (info);
-		return result;
-	}
-	_tmp7_ = info;
-	_tmp8_ = _g_object_ref0 (G_IS_APP_INFO (_tmp7_) ? ((GAppInfo*) _tmp7_) : NULL);
-	app_info = _tmp8_;
-	result = app_info;
-	_g_object_unref0 (info);
-	return result;
-}
-
-
-static gchar* music_player_bridge_fetch_icon_name (const gchar* desktop) {
-	gchar* result = NULL;
-	const gchar* _tmp0_;
-	gchar* _tmp1_ = NULL;
-	gchar* _tmp2_;
-	GDesktopAppInfo* _tmp3_;
-	GDesktopAppInfo* _tmp4_;
-	GDesktopAppInfo* info;
-	GKeyFile* _tmp5_;
-	GKeyFile* desktop_keyfile;
-	GError * _inner_error_ = NULL;
-	g_return_val_if_fail (desktop != NULL, NULL);
-	_tmp0_ = desktop;
-	_tmp1_ = g_strconcat (_tmp0_, ".desktop", NULL);
-	_tmp2_ = _tmp1_;
-	_tmp3_ = g_desktop_app_info_new (_tmp2_);
-	_tmp4_ = _tmp3_;
-	_g_free0 (_tmp2_);
-	info = _tmp4_;
-	_tmp5_ = g_key_file_new ();
-	desktop_keyfile = _tmp5_;
-	{
-		GKeyFile* _tmp6_;
-		GDesktopAppInfo* _tmp7_;
-		const gchar* _tmp8_ = NULL;
-		_tmp6_ = desktop_keyfile;
-		_tmp7_ = info;
-		_tmp8_ = g_desktop_app_info_get_filename (_tmp7_);
-		g_key_file_load_from_file (_tmp6_, _tmp8_, G_KEY_FILE_NONE, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == G_FILE_ERROR) {
-				goto __catch1_g_file_error;
-			}
-			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
-				goto __catch1_g_key_file_error;
-			}
-			_g_key_file_free0 (desktop_keyfile);
-			_g_object_unref0 (info);
-			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-	}
-	goto __finally1;
-	__catch1_g_file_error:
-	{
-		GError* _error_ = NULL;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		g_warning ("music-player-bridge.vala:255: Error loading keyfile - FileError");
-		result = NULL;
-		_g_error_free0 (_error_);
-		_g_key_file_free0 (desktop_keyfile);
-		_g_object_unref0 (info);
-		return result;
-	}
-	goto __finally1;
-	__catch1_g_key_file_error:
-	{
-		GError* _error_ = NULL;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		g_warning ("music-player-bridge.vala:259: Error loading keyfile - KeyFileError");
-		result = NULL;
-		_g_error_free0 (_error_);
-		_g_key_file_free0 (desktop_keyfile);
-		_g_object_unref0 (info);
-		return result;
-	}
-	__finally1:
-	if (_inner_error_ != NULL) {
-		_g_key_file_free0 (desktop_keyfile);
-		_g_object_unref0 (info);
-		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-		g_clear_error (&_inner_error_);
-		return NULL;
-	}
-	{
-		GKeyFile* _tmp9_;
-		gchar* _tmp10_ = NULL;
-		gchar* _tmp11_;
-		_tmp9_ = desktop_keyfile;
-		_tmp10_ = g_key_file_get_string (_tmp9_, G_KEY_FILE_DESKTOP_GROUP, G_KEY_FILE_DESKTOP_KEY_ICON, &_inner_error_);
-		_tmp11_ = _tmp10_;
-		if (_inner_error_ != NULL) {
-			if (_inner_error_->domain == G_KEY_FILE_ERROR) {
-				goto __catch2_g_key_file_error;
-			}
-			_g_key_file_free0 (desktop_keyfile);
-			_g_object_unref0 (info);
-			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-			g_clear_error (&_inner_error_);
-			return NULL;
-		}
-		result = _tmp11_;
-		_g_key_file_free0 (desktop_keyfile);
-		_g_object_unref0 (info);
-		return result;
-	}
-	goto __finally2;
-	__catch2_g_key_file_error:
-	{
-		GError* _error_ = NULL;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		g_warning ("music-player-bridge.vala:268: Error trying to fetch the icon name from" \
-" the keyfile");
-		result = NULL;
-		_g_error_free0 (_error_);
-		_g_key_file_free0 (desktop_keyfile);
-		_g_object_unref0 (info);
-		return result;
-	}
-	__finally2:
-	_g_key_file_free0 (desktop_keyfile);
-	_g_object_unref0 (info);
-	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-	g_clear_error (&_inner_error_);
-	return NULL;
-}
-
-
-static gchar* music_player_bridge_determine_key (gchar* desktop_or_interface) {
-	gchar* result = NULL;
-	const gchar* _tmp0_;
-	gchar* _tmp1_;
-	gchar* _result_;
-	const gchar* _tmp2_;
-	gchar** _tmp3_;
-	gchar** _tmp4_ = NULL;
-	gchar** tokens;
-	gint tokens_length1;
-	gint _tokens_size_;
-	gboolean _tmp5_ = FALSE;
-	gchar** _tmp6_;
-	gint _tmp6__length1;
-	gboolean _tmp8_;
-	const gchar* _tmp13_;
-	gchar** _tmp14_;
-	gchar** _tmp15_ = NULL;
-	gchar** temp;
-	gint temp_length1;
-	gint _temp_size_;
-	gboolean _tmp16_ = FALSE;
-	gchar** _tmp17_;
-	gint _tmp17__length1;
-	gboolean _tmp19_;
-	g_return_val_if_fail (desktop_or_interface != NULL, NULL);
-	_tmp0_ = desktop_or_interface;
-	_tmp1_ = g_strdup (_tmp0_);
-	_result_ = _tmp1_;
-	_tmp2_ = desktop_or_interface;
-	_tmp4_ = _tmp3_ = g_strsplit (_tmp2_, ".", 0);
-	tokens = _tmp4_;
-	tokens_length1 = _vala_array_length (_tmp3_);
-	_tokens_size_ = tokens_length1;
-	_tmp6_ = tokens;
-	_tmp6__length1 = tokens_length1;
-	if (_tmp6_ != NULL) {
-		gchar** _tmp7_;
-		gint _tmp7__length1;
-		_tmp7_ = tokens;
-		_tmp7__length1 = tokens_length1;
-		_tmp5_ = _tmp7__length1 > 1;
-	} else {
-		_tmp5_ = FALSE;
-	}
-	_tmp8_ = _tmp5_;
-	if (_tmp8_) {
-		gchar** _tmp9_;
-		gint _tmp9__length1;
-		gchar** _tmp10_;
-		gint _tmp10__length1;
-		const gchar* _tmp11_;
-		gchar* _tmp12_;
-		_tmp9_ = tokens;
-		_tmp9__length1 = tokens_length1;
-		_tmp10_ = tokens;
-		_tmp10__length1 = tokens_length1;
-		_tmp11_ = _tmp9_[_tmp10__length1 - 1];
-		_tmp12_ = g_strdup (_tmp11_);
-		_g_free0 (_result_);
-		_result_ = _tmp12_;
-	}
-	_tmp13_ = _result_;
-	_tmp15_ = _tmp14_ = g_strsplit (_tmp13_, "-", 0);
-	temp = _tmp15_;
-	temp_length1 = _vala_array_length (_tmp14_);
-	_temp_size_ = temp_length1;
-	_tmp17_ = temp;
-	_tmp17__length1 = temp_length1;
-	if (_tmp17_ != NULL) {
-		gchar** _tmp18_;
-		gint _tmp18__length1;
-		_tmp18_ = temp;
-		_tmp18__length1 = temp_length1;
-		_tmp16_ = _tmp18__length1 > 1;
-	} else {
-		_tmp16_ = FALSE;
-	}
-	_tmp19_ = _tmp16_;
-	if (_tmp19_) {
-		gchar** _tmp20_;
-		gint _tmp20__length1;
-		const gchar* _tmp21_;
-		gchar* _tmp22_;
-		_tmp20_ = temp;
-		_tmp20__length1 = temp_length1;
-		_tmp21_ = _tmp20_[0];
-		_tmp22_ = g_strdup (_tmp21_);
-		_g_free0 (_result_);
-		_result_ = _tmp22_;
-	}
-	result = _result_;
-	temp = (_vala_array_free (temp, temp_length1, (GDestroyNotify) g_free), NULL);
-	tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
-	_g_free0 (desktop_or_interface);
-	return result;
-}
-
-
-static void _music_player_bridge_on_blacklist_update_settings_manager_blacklist_updates (SettingsManager* _sender, gchar** new_blacklist, int new_blacklist_length1, gpointer self) {
-	music_player_bridge_on_blacklist_update (self, new_blacklist, new_blacklist_length1);
-}
-
-
-static GObject * music_player_bridge_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
-	GObject * obj;
-	GObjectClass * parent_class;
-	MusicPlayerBridge * self;
-	GeeHashMap* _tmp0_;
-	GeeHashMap* _tmp1_;
-	SettingsManager* _tmp2_;
-	SettingsManager* _tmp3_;
-	parent_class = G_OBJECT_CLASS (music_player_bridge_parent_class);
-	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
-	self = MUSIC_PLAYER_BRIDGE (obj);
-	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, TYPE_PLAYER_CONTROLLER, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
-	_g_object_unref0 (self->priv->registered_clients);
-	self->priv->registered_clients = _tmp0_;
-	_tmp1_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
-	_g_object_unref0 (self->priv->file_monitors);
-	self->priv->file_monitors = _tmp1_;
-	_tmp2_ = settings_manager_new ();
-	_g_object_unref0 (self->priv->settings_manager);
-	self->priv->settings_manager = _tmp2_;
-	_tmp3_ = self->priv->settings_manager;
-	g_signal_connect_object (_tmp3_, "blacklist-updates", (GCallback) _music_player_bridge_on_blacklist_update_settings_manager_blacklist_updates, self, 0);
-	return obj;
-}
-
-
-static void music_player_bridge_class_init (MusicPlayerBridgeClass * klass) {
-	music_player_bridge_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (MusicPlayerBridgePrivate));
-	G_OBJECT_CLASS (klass)->constructor = music_player_bridge_constructor;
-	G_OBJECT_CLASS (klass)->finalize = music_player_bridge_finalize;
-}
-
-
-static void music_player_bridge_instance_init (MusicPlayerBridge * self) {
-	self->priv = MUSIC_PLAYER_BRIDGE_GET_PRIVATE (self);
-}
-
-
-static void music_player_bridge_finalize (GObject* obj) {
-	MusicPlayerBridge * self;
-	self = MUSIC_PLAYER_BRIDGE (obj);
-	_g_object_unref0 (self->priv->settings_manager);
-	_g_object_unref0 (self->priv->root_menu);
-	_g_object_unref0 (self->priv->registered_clients);
-	_g_object_unref0 (self->priv->file_monitors);
-	_g_object_unref0 (self->priv->watcher);
-	G_OBJECT_CLASS (music_player_bridge_parent_class)->finalize (obj);
-}
-
-
-GType music_player_bridge_get_type (void) {
-	static volatile gsize music_player_bridge_type_id__volatile = 0;
-	if (g_once_init_enter (&music_player_bridge_type_id__volatile)) {
-		static const GTypeInfo g_define_type_info = { sizeof (MusicPlayerBridgeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) music_player_bridge_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MusicPlayerBridge), 0, (GInstanceInitFunc) music_player_bridge_instance_init, NULL };
-		GType music_player_bridge_type_id;
-		music_player_bridge_type_id = g_type_register_static (G_TYPE_OBJECT, "MusicPlayerBridge", &g_define_type_info, 0);
-		g_once_init_leave (&music_player_bridge_type_id__volatile, music_player_bridge_type_id);
-	}
-	return music_player_bridge_type_id__volatile;
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-static gint _vala_array_length (gpointer array) {
-	int length;
-	length = 0;
-	if (array) {
-		while (((gpointer*) array)[length]) {
-			length++;
-		}
-	}
-	return length;
-}
-
-
-
diff -Naur indicator-sound-0.8.5.0/src/music-player-bridge.h indicator-sound-precise/src/music-player-bridge.h
--- indicator-sound-0.8.5.0/src/music-player-bridge.h	2012-03-30 10:32:34.000000000 -0700
+++ indicator-sound-precise/src/music-player-bridge.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,605 +0,0 @@
-/* music-player-bridge.h generated by valac 0.14.2, the Vala compiler, do not modify */
-
-
-#ifndef __MUSIC_PLAYER_BRIDGE_H__
-#define __MUSIC_PLAYER_BRIDGE_H__
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <libdbusmenu-glib/client.h>
-#include <libdbusmenu-glib/dbusmenu-glib.h>
-#include <libdbusmenu-glib/enum-types.h>
-#include <libdbusmenu-glib/menuitem-proxy.h>
-#include <libdbusmenu-glib/menuitem.h>
-#include <libdbusmenu-glib/server.h>
-#include <libdbusmenu-glib/types.h>
-#include <common-defs.h>
-#include <gee.h>
-#include <gio/gio.h>
-
-G_BEGIN_DECLS
-
-
-#define TYPE_MUSIC_PLAYER_BRIDGE (music_player_bridge_get_type ())
-#define MUSIC_PLAYER_BRIDGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MUSIC_PLAYER_BRIDGE, MusicPlayerBridge))
-#define MUSIC_PLAYER_BRIDGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MUSIC_PLAYER_BRIDGE, MusicPlayerBridgeClass))
-#define IS_MUSIC_PLAYER_BRIDGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MUSIC_PLAYER_BRIDGE))
-#define IS_MUSIC_PLAYER_BRIDGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MUSIC_PLAYER_BRIDGE))
-#define MUSIC_PLAYER_BRIDGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MUSIC_PLAYER_BRIDGE, MusicPlayerBridgeClass))
-
-typedef struct _MusicPlayerBridge MusicPlayerBridge;
-typedef struct _MusicPlayerBridgeClass MusicPlayerBridgeClass;
-typedef struct _MusicPlayerBridgePrivate MusicPlayerBridgePrivate;
-
-#define TYPE_PLAYER_ITEM (player_item_get_type ())
-#define PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_ITEM, PlayerItem))
-#define PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_ITEM, PlayerItemClass))
-#define IS_PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_ITEM))
-#define IS_PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_ITEM))
-#define PLAYER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_ITEM, PlayerItemClass))
-
-typedef struct _PlayerItem PlayerItem;
-typedef struct _PlayerItemClass PlayerItemClass;
-typedef struct _PlayerItemPrivate PlayerItemPrivate;
-
-#define TYPE_TRANSPORT_MENUITEM (transport_menuitem_get_type ())
-#define TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitem))
-#define TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))
-#define IS_TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRANSPORT_MENUITEM))
-#define IS_TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRANSPORT_MENUITEM))
-#define TRANSPORT_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))
-
-typedef struct _TransportMenuitem TransportMenuitem;
-typedef struct _TransportMenuitemClass TransportMenuitemClass;
-typedef struct _TransportMenuitemPrivate TransportMenuitemPrivate;
-
-#define TYPE_PLAYER_CONTROLLER (player_controller_get_type ())
-#define PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONTROLLER, PlayerController))
-#define PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-#define IS_PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONTROLLER))
-#define IS_PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONTROLLER))
-#define PLAYER_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-
-typedef struct _PlayerController PlayerController;
-typedef struct _PlayerControllerClass PlayerControllerClass;
-
-#define TYPE_SPECIFIC_ITEMS_MANAGER (specific_items_manager_get_type ())
-#define SPECIFIC_ITEMS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SPECIFIC_ITEMS_MANAGER, SpecificItemsManager))
-#define SPECIFIC_ITEMS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SPECIFIC_ITEMS_MANAGER, SpecificItemsManagerClass))
-#define IS_SPECIFIC_ITEMS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SPECIFIC_ITEMS_MANAGER))
-#define IS_SPECIFIC_ITEMS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SPECIFIC_ITEMS_MANAGER))
-#define SPECIFIC_ITEMS_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SPECIFIC_ITEMS_MANAGER, SpecificItemsManagerClass))
-
-typedef struct _SpecificItemsManager SpecificItemsManager;
-typedef struct _SpecificItemsManagerClass SpecificItemsManagerClass;
-typedef struct _SpecificItemsManagerPrivate SpecificItemsManagerPrivate;
-
-#define SPECIFIC_ITEMS_MANAGER_TYPE_CATEGORY (specific_items_manager_category_get_type ())
-
-#define TYPE_METADATA_MENUITEM (metadata_menuitem_get_type ())
-#define METADATA_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_METADATA_MENUITEM, MetadataMenuitem))
-#define METADATA_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_METADATA_MENUITEM, MetadataMenuitemClass))
-#define IS_METADATA_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_METADATA_MENUITEM))
-#define IS_METADATA_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_METADATA_MENUITEM))
-#define METADATA_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_METADATA_MENUITEM, MetadataMenuitemClass))
-
-typedef struct _MetadataMenuitem MetadataMenuitem;
-typedef struct _MetadataMenuitemClass MetadataMenuitemClass;
-typedef struct _MetadataMenuitemPrivate MetadataMenuitemPrivate;
-typedef struct _PlayerControllerPrivate PlayerControllerPrivate;
-
-#define TYPE_MPRIS2_CONTROLLER (mpris2_controller_get_type ())
-#define MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2Controller))
-#define MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
-#define IS_MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS2_CONTROLLER))
-#define IS_MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS2_CONTROLLER))
-#define MPRIS2_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
-
-typedef struct _Mpris2Controller Mpris2Controller;
-typedef struct _Mpris2ControllerClass Mpris2ControllerClass;
-
-#define PLAYER_CONTROLLER_TYPE_WIDGET_ORDER (player_controller_widget_order_get_type ())
-
-#define PLAYER_CONTROLLER_TYPE_STATE (player_controller_state_get_type ())
-
-#define TYPE_MPRIS_ROOT (mpris_root_get_type ())
-#define MPRIS_ROOT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_ROOT, MprisRoot))
-#define IS_MPRIS_ROOT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_ROOT))
-#define MPRIS_ROOT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MPRIS_ROOT, MprisRootIface))
-
-typedef struct _MprisRoot MprisRoot;
-typedef struct _MprisRootIface MprisRootIface;
-
-#define TYPE_MPRIS_ROOT_PROXY (mpris_root_proxy_get_type ())
-
-#define TYPE_MPRIS_PLAYER (mpris_player_get_type ())
-#define MPRIS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_PLAYER, MprisPlayer))
-#define IS_MPRIS_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_PLAYER))
-#define MPRIS_PLAYER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MPRIS_PLAYER, MprisPlayerIface))
-
-typedef struct _MprisPlayer MprisPlayer;
-typedef struct _MprisPlayerIface MprisPlayerIface;
-
-#define TYPE_MPRIS_PLAYER_PROXY (mpris_player_proxy_get_type ())
-
-#define TYPE_PLAYLIST_DETAILS (playlist_details_get_type ())
-typedef struct _PlaylistDetails PlaylistDetails;
-
-#define TYPE_ACTIVE_PLAYLIST_CONTAINER (active_playlist_container_get_type ())
-typedef struct _ActivePlaylistContainer ActivePlaylistContainer;
-
-#define TYPE_MPRIS_PLAYLISTS (mpris_playlists_get_type ())
-#define MPRIS_PLAYLISTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS_PLAYLISTS, MprisPlaylists))
-#define IS_MPRIS_PLAYLISTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS_PLAYLISTS))
-#define MPRIS_PLAYLISTS_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_MPRIS_PLAYLISTS, MprisPlaylistsIface))
-
-typedef struct _MprisPlaylists MprisPlaylists;
-typedef struct _MprisPlaylistsIface MprisPlaylistsIface;
-
-#define TYPE_MPRIS_PLAYLISTS_PROXY (mpris_playlists_proxy_get_type ())
-
-#define TYPE_MPRIS2_WATCHER (mpris2_watcher_get_type ())
-#define MPRIS2_WATCHER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS2_WATCHER, Mpris2Watcher))
-#define MPRIS2_WATCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS2_WATCHER, Mpris2WatcherClass))
-#define IS_MPRIS2_WATCHER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS2_WATCHER))
-#define IS_MPRIS2_WATCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS2_WATCHER))
-#define MPRIS2_WATCHER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS2_WATCHER, Mpris2WatcherClass))
-
-typedef struct _Mpris2Watcher Mpris2Watcher;
-typedef struct _Mpris2WatcherClass Mpris2WatcherClass;
-typedef struct _Mpris2WatcherPrivate Mpris2WatcherPrivate;
-typedef struct _Mpris2ControllerPrivate Mpris2ControllerPrivate;
-
-#define TYPE_FREE_DESKTOP_PROPERTIES (free_desktop_properties_get_type ())
-#define FREE_DESKTOP_PROPERTIES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FREE_DESKTOP_PROPERTIES, FreeDesktopProperties))
-#define IS_FREE_DESKTOP_PROPERTIES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FREE_DESKTOP_PROPERTIES))
-#define FREE_DESKTOP_PROPERTIES_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_FREE_DESKTOP_PROPERTIES, FreeDesktopPropertiesIface))
-
-typedef struct _FreeDesktopProperties FreeDesktopProperties;
-typedef struct _FreeDesktopPropertiesIface FreeDesktopPropertiesIface;
-
-#define TYPE_FREE_DESKTOP_PROPERTIES_PROXY (free_desktop_properties_proxy_get_type ())
-
-#define TYPE_SETTINGS_MANAGER (settings_manager_get_type ())
-#define SETTINGS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SETTINGS_MANAGER, SettingsManager))
-#define SETTINGS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SETTINGS_MANAGER, SettingsManagerClass))
-#define IS_SETTINGS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SETTINGS_MANAGER))
-#define IS_SETTINGS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SETTINGS_MANAGER))
-#define SETTINGS_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SETTINGS_MANAGER, SettingsManagerClass))
-
-typedef struct _SettingsManager SettingsManager;
-typedef struct _SettingsManagerClass SettingsManagerClass;
-typedef struct _SettingsManagerPrivate SettingsManagerPrivate;
-
-#define TYPE_PLAYLISTS_MENUITEM (playlists_menuitem_get_type ())
-#define PLAYLISTS_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYLISTS_MENUITEM, PlaylistsMenuitem))
-#define PLAYLISTS_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYLISTS_MENUITEM, PlaylistsMenuitemClass))
-#define IS_PLAYLISTS_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYLISTS_MENUITEM))
-#define IS_PLAYLISTS_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYLISTS_MENUITEM))
-#define PLAYLISTS_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYLISTS_MENUITEM, PlaylistsMenuitemClass))
-
-typedef struct _PlaylistsMenuitem PlaylistsMenuitem;
-typedef struct _PlaylistsMenuitemClass PlaylistsMenuitemClass;
-typedef struct _PlaylistsMenuitemPrivate PlaylistsMenuitemPrivate;
-
-#define TYPE_FREE_DESKTOP_OBJECT (free_desktop_object_get_type ())
-#define FREE_DESKTOP_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FREE_DESKTOP_OBJECT, FreeDesktopObject))
-#define IS_FREE_DESKTOP_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FREE_DESKTOP_OBJECT))
-#define FREE_DESKTOP_OBJECT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_FREE_DESKTOP_OBJECT, FreeDesktopObjectIface))
-
-typedef struct _FreeDesktopObject FreeDesktopObject;
-typedef struct _FreeDesktopObjectIface FreeDesktopObjectIface;
-
-#define TYPE_FREE_DESKTOP_OBJECT_PROXY (free_desktop_object_proxy_get_type ())
-
-#define TYPE_FREE_DESKTOP_INTROSPECTABLE (free_desktop_introspectable_get_type ())
-#define FREE_DESKTOP_INTROSPECTABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FREE_DESKTOP_INTROSPECTABLE, FreeDesktopIntrospectable))
-#define IS_FREE_DESKTOP_INTROSPECTABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FREE_DESKTOP_INTROSPECTABLE))
-#define FREE_DESKTOP_INTROSPECTABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_FREE_DESKTOP_INTROSPECTABLE, FreeDesktopIntrospectableIface))
-
-typedef struct _FreeDesktopIntrospectable FreeDesktopIntrospectable;
-typedef struct _FreeDesktopIntrospectableIface FreeDesktopIntrospectableIface;
-
-#define TYPE_FREE_DESKTOP_INTROSPECTABLE_PROXY (free_desktop_introspectable_proxy_get_type ())
-
-#define TYPE_FETCH_FILE (fetch_file_get_type ())
-#define FETCH_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FETCH_FILE, FetchFile))
-#define FETCH_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FETCH_FILE, FetchFileClass))
-#define IS_FETCH_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FETCH_FILE))
-#define IS_FETCH_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FETCH_FILE))
-#define FETCH_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FETCH_FILE, FetchFileClass))
-
-typedef struct _FetchFile FetchFile;
-typedef struct _FetchFileClass FetchFileClass;
-typedef struct _FetchFilePrivate FetchFilePrivate;
-
-struct _MusicPlayerBridge {
-	GObject parent_instance;
-	MusicPlayerBridgePrivate * priv;
-};
-
-struct _MusicPlayerBridgeClass {
-	GObjectClass parent_class;
-};
-
-struct _PlayerItem {
-	DbusmenuMenuitem parent_instance;
-	PlayerItemPrivate * priv;
-};
-
-struct _PlayerItemClass {
-	DbusmenuMenuitemClass parent_class;
-};
-
-struct _TransportMenuitem {
-	PlayerItem parent_instance;
-	TransportMenuitemPrivate * priv;
-};
-
-struct _TransportMenuitemClass {
-	PlayerItemClass parent_class;
-};
-
-struct _SpecificItemsManager {
-	GObject parent_instance;
-	SpecificItemsManagerPrivate * priv;
-};
-
-struct _SpecificItemsManagerClass {
-	GObjectClass parent_class;
-};
-
-typedef enum  {
-	SPECIFIC_ITEMS_MANAGER_CATEGORY_TRACK,
-	SPECIFIC_ITEMS_MANAGER_CATEGORY_PLAYER
-} SpecificItemsManagercategory;
-
-struct _MetadataMenuitem {
-	PlayerItem parent_instance;
-	MetadataMenuitemPrivate * priv;
-};
-
-struct _MetadataMenuitemClass {
-	PlayerItemClass parent_class;
-};
-
-struct _PlayerController {
-	GObject parent_instance;
-	PlayerControllerPrivate * priv;
-	gint current_state;
-	DbusmenuMenuitem* root_menu;
-	GeeArrayList* custom_items;
-	Mpris2Controller* mpris_bridge;
-	gboolean* use_playlists;
-};
-
-struct _PlayerControllerClass {
-	GObjectClass parent_class;
-};
-
-typedef enum  {
-	PLAYER_CONTROLLER_WIDGET_ORDER_SEPARATOR,
-	PLAYER_CONTROLLER_WIDGET_ORDER_METADATA,
-	PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT,
-	PLAYER_CONTROLLER_WIDGET_ORDER_PLAYLISTS
-} PlayerControllerwidget_order;
-
-typedef enum  {
-	PLAYER_CONTROLLER_STATE_OFFLINE,
-	PLAYER_CONTROLLER_STATE_INSTANTIATING,
-	PLAYER_CONTROLLER_STATE_READY,
-	PLAYER_CONTROLLER_STATE_CONNECTED,
-	PLAYER_CONTROLLER_STATE_DISCONNECTED
-} PlayerControllerstate;
-
-struct _MprisRootIface {
-	GTypeInterface parent_iface;
-	void (*Quit) (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*Quit_finish) (MprisRoot* self, GAsyncResult* _res_, GError** error);
-	void (*Raise) (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*Raise_finish) (MprisRoot* self, GAsyncResult* _res_, GError** error);
-	gboolean (*get_HasTracklist) (MprisRoot* self);
-	void (*set_HasTracklist) (MprisRoot* self, gboolean value);
-	gboolean (*get_CanQuit) (MprisRoot* self);
-	void (*set_CanQuit) (MprisRoot* self, gboolean value);
-	gboolean (*get_CanRaise) (MprisRoot* self);
-	void (*set_CanRaise) (MprisRoot* self, gboolean value);
-	gchar* (*get_Identity) (MprisRoot* self);
-	void (*set_Identity) (MprisRoot* self, const gchar* value);
-	gchar* (*get_DesktopEntry) (MprisRoot* self);
-	void (*set_DesktopEntry) (MprisRoot* self, const gchar* value);
-};
-
-struct _MprisPlayerIface {
-	GTypeInterface parent_iface;
-	void (*PlayPause) (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*PlayPause_finish) (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-	void (*Next) (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*Next_finish) (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-	void (*Previous) (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*Previous_finish) (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-	void (*Seek) (MprisPlayer* self, gint64 offset, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*Seek_finish) (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-	GHashTable* (*get_Metadata) (MprisPlayer* self);
-	void (*set_Metadata) (MprisPlayer* self, GHashTable* value);
-	gint32 (*get_Position) (MprisPlayer* self);
-	void (*set_Position) (MprisPlayer* self, gint32 value);
-	gchar* (*get_PlaybackStatus) (MprisPlayer* self);
-	void (*set_PlaybackStatus) (MprisPlayer* self, const gchar* value);
-};
-
-struct _PlaylistDetails {
-	char* path;
-	gchar* name;
-	gchar* icon_path;
-};
-
-struct _ActivePlaylistContainer {
-	gboolean valid;
-	PlaylistDetails* details;
-};
-
-struct _MprisPlaylistsIface {
-	GTypeInterface parent_iface;
-	void (*ActivatePlaylist) (MprisPlaylists* self, const char* playlist_id, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	void (*ActivatePlaylist_finish) (MprisPlaylists* self, GAsyncResult* _res_, GError** error);
-	void (*GetPlaylists) (MprisPlaylists* self, guint32 index, guint32 max_count, const gchar* order, gboolean reverse_order, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	PlaylistDetails* (*GetPlaylists_finish) (MprisPlaylists* self, GAsyncResult* _res_, int* result_length1, GError** error);
-	gchar** (*get_Orderings) (MprisPlaylists* self, int* result_length1);
-	void (*set_Orderings) (MprisPlaylists* self, gchar** value, int value_length1);
-	guint32 (*get_PlaylistCount) (MprisPlaylists* self);
-	void (*set_PlaylistCount) (MprisPlaylists* self, guint32 value);
-	ActivePlaylistContainer* (*get_ActivePlaylist) (MprisPlaylists* self);
-	void (*set_ActivePlaylist) (MprisPlaylists* self, ActivePlaylistContainer* value);
-};
-
-struct _Mpris2Watcher {
-	GObject parent_instance;
-	Mpris2WatcherPrivate * priv;
-};
-
-struct _Mpris2WatcherClass {
-	GObjectClass parent_class;
-};
-
-struct _Mpris2Controller {
-	GObject parent_instance;
-	Mpris2ControllerPrivate * priv;
-};
-
-struct _Mpris2ControllerClass {
-	GObjectClass parent_class;
-};
-
-struct _FreeDesktopPropertiesIface {
-	GTypeInterface parent_iface;
-};
-
-struct _SettingsManager {
-	GObject parent_instance;
-	SettingsManagerPrivate * priv;
-};
-
-struct _SettingsManagerClass {
-	GObjectClass parent_class;
-};
-
-struct _PlaylistsMenuitem {
-	PlayerItem parent_instance;
-	PlaylistsMenuitemPrivate * priv;
-	DbusmenuMenuitem* root_item;
-};
-
-struct _PlaylistsMenuitemClass {
-	PlayerItemClass parent_class;
-};
-
-struct _FreeDesktopObjectIface {
-	GTypeInterface parent_iface;
-	void (*list_names) (FreeDesktopObject* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-	gchar** (*list_names_finish) (FreeDesktopObject* self, GAsyncResult* _res_, int* result_length1, GError** error);
-};
-
-struct _FreeDesktopIntrospectableIface {
-	GTypeInterface parent_iface;
-	gchar* (*Introspect) (FreeDesktopIntrospectable* self, GError** error);
-};
-
-typedef enum  {
-	XML_ERROR_FILE_NOT_FOUND,
-	XML_ERROR_XML_DOCUMENT_EMPTY
-} XmlError;
-#define XML_ERROR xml_error_quark ()
-struct _FetchFile {
-	GObject parent_instance;
-	FetchFilePrivate * priv;
-};
-
-struct _FetchFileClass {
-	GObjectClass parent_class;
-};
-
-
-GType music_player_bridge_get_type (void) G_GNUC_CONST;
-MusicPlayerBridge* music_player_bridge_new (void);
-MusicPlayerBridge* music_player_bridge_construct (GType object_type);
-void music_player_bridge_client_has_become_available (MusicPlayerBridge* self, const gchar* desktop, const gchar* dbus_name, gboolean use_playlists);
-void music_player_bridge_client_has_vanished (MusicPlayerBridge* self, const gchar* mpris_root_interface);
-void music_player_bridge_set_root_menu_item (MusicPlayerBridge* self, DbusmenuMenuitem* menu);
-void music_player_bridge_enable_player_specific_items_for_client (MusicPlayerBridge* self, const gchar* object_path, const gchar* desktop_id);
-void music_player_bridge_enable_track_specific_items_for_client (MusicPlayerBridge* self, const gchar* object_path, const gchar* desktop_id);
-GType player_item_get_type (void) G_GNUC_CONST;
-GType transport_menuitem_get_type (void) G_GNUC_CONST;
-GType player_controller_get_type (void) G_GNUC_CONST;
-TransportMenuitem* transport_menuitem_new (PlayerController* parent);
-TransportMenuitem* transport_menuitem_construct (GType object_type, PlayerController* parent);
-void transport_menuitem_handle_cached_action (TransportMenuitem* self);
-void transport_menuitem_change_play_state (TransportMenuitem* self, TransportState update);
-GeeHashSet* transport_menuitem_attributes_format (void);
-GType specific_items_manager_get_type (void) G_GNUC_CONST;
-GType specific_items_manager_category_get_type (void) G_GNUC_CONST;
-SpecificItemsManager* specific_items_manager_new (PlayerController* controller, const gchar* path, SpecificItemsManagercategory which_type);
-SpecificItemsManager* specific_items_manager_construct (GType object_type, PlayerController* controller, const gchar* path, SpecificItemsManagercategory which_type);
-GeeArrayList* specific_items_manager_get_proxy_items (SpecificItemsManager* self);
-GType metadata_menuitem_get_type (void) G_GNUC_CONST;
-extern gchar* metadata_menuitem_album_art_cache_dir;
-#define METADATA_MENUITEM_ALBUM_ART_DIR_SUFFIX "indicator/sound/album-art-cache"
-MetadataMenuitem* metadata_menuitem_new (PlayerController* parent);
-MetadataMenuitem* metadata_menuitem_construct (GType object_type, PlayerController* parent);
-void metadata_menuitem_fetch_art (MetadataMenuitem* self, const gchar* uri, const gchar* prop);
-void metadata_menuitem_alter_label (MetadataMenuitem* self, const gchar* new_title);
-void metadata_menuitem_toggle_active_triangle (MetadataMenuitem* self, gboolean update);
-void metadata_menuitem_should_collapse (MetadataMenuitem* self, gboolean collapse);
-GeeHashSet* metadata_menuitem_attributes_format (void);
-GeeHashSet* metadata_menuitem_relevant_attributes_for_ui (void);
-GType mpris2_controller_get_type (void) G_GNUC_CONST;
-GType player_controller_widget_order_get_type (void) G_GNUC_CONST;
-GType player_controller_state_get_type (void) G_GNUC_CONST;
-#define PLAYER_CONTROLLER_WIDGET_QUANTITY 4
-PlayerController* player_controller_new (DbusmenuMenuitem* root, GAppInfo* app, const gchar* dbus_name, const gchar* icon_name, gint offset, gboolean* use_playlists, PlayerControllerstate initial_state);
-PlayerController* player_controller_construct (GType object_type, DbusmenuMenuitem* root, GAppInfo* app, const gchar* dbus_name, const gchar* icon_name, gint offset, gboolean* use_playlists, PlayerControllerstate initial_state);
-void player_controller_update_state (PlayerController* self, PlayerControllerstate new_state);
-void player_controller_activate (PlayerController* self, const gchar* dbus_name);
-void player_controller_instantiate (PlayerController* self);
-void player_controller_enable_track_specific_items (PlayerController* self, const gchar* object_path);
-void player_controller_enable_player_specific_items (PlayerController* self, const gchar* object_path);
-gint player_controller_track_specific_count (PlayerController* self);
-void player_controller_remove_from_menu (PlayerController* self);
-void player_controller_hibernate (PlayerController* self);
-void player_controller_update_layout (PlayerController* self);
-const gchar* player_controller_get_dbus_name (PlayerController* self);
-void player_controller_set_dbus_name (PlayerController* self, const gchar* value);
-GAppInfo* player_controller_get_app_info (PlayerController* self);
-void player_controller_set_app_info (PlayerController* self, GAppInfo* value);
-gint player_controller_get_menu_offset (PlayerController* self);
-void player_controller_set_menu_offset (PlayerController* self, gint value);
-const gchar* player_controller_get_icon_name (PlayerController* self);
-void player_controller_set_icon_name (PlayerController* self, const gchar* value);
-GType mpris_root_proxy_get_type (void) G_GNUC_CONST;
-guint mpris_root_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-GType mpris_root_get_type (void) G_GNUC_CONST;
-void mpris_root_Quit (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_root_Quit_finish (MprisRoot* self, GAsyncResult* _res_, GError** error);
-void mpris_root_Raise (MprisRoot* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_root_Raise_finish (MprisRoot* self, GAsyncResult* _res_, GError** error);
-gboolean mpris_root_get_HasTracklist (MprisRoot* self);
-void mpris_root_set_HasTracklist (MprisRoot* self, gboolean value);
-gboolean mpris_root_get_CanQuit (MprisRoot* self);
-void mpris_root_set_CanQuit (MprisRoot* self, gboolean value);
-gboolean mpris_root_get_CanRaise (MprisRoot* self);
-void mpris_root_set_CanRaise (MprisRoot* self, gboolean value);
-gchar* mpris_root_get_Identity (MprisRoot* self);
-void mpris_root_set_Identity (MprisRoot* self, const gchar* value);
-gchar* mpris_root_get_DesktopEntry (MprisRoot* self);
-void mpris_root_set_DesktopEntry (MprisRoot* self, const gchar* value);
-GType mpris_player_proxy_get_type (void) G_GNUC_CONST;
-guint mpris_player_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-GType mpris_player_get_type (void) G_GNUC_CONST;
-void mpris_player_PlayPause (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_player_PlayPause_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-void mpris_player_Next (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_player_Next_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-void mpris_player_Previous (MprisPlayer* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_player_Previous_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-void mpris_player_Seek (MprisPlayer* self, gint64 offset, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_player_Seek_finish (MprisPlayer* self, GAsyncResult* _res_, GError** error);
-GHashTable* mpris_player_get_Metadata (MprisPlayer* self);
-void mpris_player_set_Metadata (MprisPlayer* self, GHashTable* value);
-gint32 mpris_player_get_Position (MprisPlayer* self);
-void mpris_player_set_Position (MprisPlayer* self, gint32 value);
-gchar* mpris_player_get_PlaybackStatus (MprisPlayer* self);
-void mpris_player_set_PlaybackStatus (MprisPlayer* self, const gchar* value);
-GType playlist_details_get_type (void) G_GNUC_CONST;
-PlaylistDetails* playlist_details_dup (const PlaylistDetails* self);
-void playlist_details_free (PlaylistDetails* self);
-void playlist_details_copy (const PlaylistDetails* self, PlaylistDetails* dest);
-void playlist_details_destroy (PlaylistDetails* self);
-GType active_playlist_container_get_type (void) G_GNUC_CONST;
-ActivePlaylistContainer* active_playlist_container_dup (const ActivePlaylistContainer* self);
-void active_playlist_container_free (ActivePlaylistContainer* self);
-void active_playlist_container_copy (const ActivePlaylistContainer* self, ActivePlaylistContainer* dest);
-void active_playlist_container_destroy (ActivePlaylistContainer* self);
-GType mpris_playlists_proxy_get_type (void) G_GNUC_CONST;
-guint mpris_playlists_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-GType mpris_playlists_get_type (void) G_GNUC_CONST;
-void mpris_playlists_ActivatePlaylist (MprisPlaylists* self, const char* playlist_id, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris_playlists_ActivatePlaylist_finish (MprisPlaylists* self, GAsyncResult* _res_, GError** error);
-void mpris_playlists_GetPlaylists (MprisPlaylists* self, guint32 index, guint32 max_count, const gchar* order, gboolean reverse_order, GAsyncReadyCallback _callback_, gpointer _user_data_);
-PlaylistDetails* mpris_playlists_GetPlaylists_finish (MprisPlaylists* self, GAsyncResult* _res_, int* result_length1, GError** error);
-gchar** mpris_playlists_get_Orderings (MprisPlaylists* self, int* result_length1);
-void mpris_playlists_set_Orderings (MprisPlaylists* self, gchar** value, int value_length1);
-guint32 mpris_playlists_get_PlaylistCount (MprisPlaylists* self);
-void mpris_playlists_set_PlaylistCount (MprisPlaylists* self, guint32 value);
-ActivePlaylistContainer* mpris_playlists_get_ActivePlaylist (MprisPlaylists* self);
-void mpris_playlists_set_ActivePlaylist (MprisPlaylists* self, ActivePlaylistContainer* value);
-GType mpris2_watcher_get_type (void) G_GNUC_CONST;
-Mpris2Watcher* mpris2_watcher_new (void);
-Mpris2Watcher* mpris2_watcher_construct (GType object_type);
-void mpris2_watcher_check_for_active_clients (Mpris2Watcher* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris2_watcher_check_for_active_clients_finish (Mpris2Watcher* self, GAsyncResult* _res_);
-#define MPRIS2_CONTROLLER_MAX_PLAYLIST_COUNT 100
-Mpris2Controller* mpris2_controller_new (PlayerController* ctrl);
-Mpris2Controller* mpris2_controller_construct (GType object_type, PlayerController* ctrl);
-void mpris2_controller_property_changed_cb (Mpris2Controller* self, const gchar* interface_source, GHashTable* changed_properties, gchar** invalid, int invalid_length1);
-void mpris2_controller_initial_update (Mpris2Controller* self);
-void mpris2_controller_transport_update (Mpris2Controller* self, TransportAction command);
-gboolean mpris2_controller_connected (Mpris2Controller* self);
-void mpris2_controller_expose (Mpris2Controller* self);
-void mpris2_controller_fetch_playlists (Mpris2Controller* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void mpris2_controller_fetch_playlists_finish (Mpris2Controller* self, GAsyncResult* _res_);
-void mpris2_controller_activate_playlist (Mpris2Controller* self, const char* path);
-MprisRoot* mpris2_controller_get_mpris2_root (Mpris2Controller* self);
-MprisPlayer* mpris2_controller_get_player (Mpris2Controller* self);
-MprisPlaylists* mpris2_controller_get_playlists (Mpris2Controller* self);
-GType free_desktop_properties_get_type (void) G_GNUC_CONST;
-GType free_desktop_properties_proxy_get_type (void) G_GNUC_CONST;
-guint free_desktop_properties_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-FreeDesktopProperties* mpris2_controller_get_properties_interface (Mpris2Controller* self);
-PlayerController* mpris2_controller_get_owner (Mpris2Controller* self);
-#define PLAYER_ITEM_EMPTY (-1)
-PlayerItem* player_item_new (const gchar* type);
-PlayerItem* player_item_construct (GType object_type, const gchar* type);
-void player_item_reset (PlayerItem* self, GeeHashSet* attrs);
-void player_item_update (PlayerItem* self, GHashTable* data, GeeHashSet* attributes);
-gboolean player_item_populated (PlayerItem* self, GeeHashSet* attrs);
-PlayerController* player_item_get_owner (PlayerItem* self);
-const gchar* player_item_get_item_type (PlayerItem* self);
-GType settings_manager_get_type (void) G_GNUC_CONST;
-SettingsManager* settings_manager_new (void);
-SettingsManager* settings_manager_construct (GType object_type);
-gchar** settings_manager_fetch_blacklist (SettingsManager* self, int* result_length1);
-GeeArrayList* settings_manager_fetch_interested (SettingsManager* self);
-void settings_manager_clear_list (SettingsManager* self);
-void settings_manager_remove_interested (SettingsManager* self, const gchar* app_desktop_name);
-void settings_manager_add_interested (SettingsManager* self, const gchar* app_desktop_name);
-GType playlists_menuitem_get_type (void) G_GNUC_CONST;
-PlaylistsMenuitem* playlists_menuitem_new (PlayerController* parent);
-PlaylistsMenuitem* playlists_menuitem_construct (GType object_type, PlayerController* parent);
-void playlists_menuitem_update (PlaylistsMenuitem* self, PlaylistDetails* playlists, int playlists_length1);
-void playlists_menuitem_update_individual_playlist (PlaylistsMenuitem* self, PlaylistDetails* new_detail);
-void playlists_menuitem_active_playlist_update (PlaylistsMenuitem* self, PlaylistDetails* detail);
-GeeHashSet* playlists_menuitem_attributes_format (void);
-GType free_desktop_object_proxy_get_type (void) G_GNUC_CONST;
-guint free_desktop_object_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-GType free_desktop_object_get_type (void) G_GNUC_CONST;
-void free_desktop_object_list_names (FreeDesktopObject* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-gchar** free_desktop_object_list_names_finish (FreeDesktopObject* self, GAsyncResult* _res_, int* result_length1, GError** error);
-GType free_desktop_introspectable_proxy_get_type (void) G_GNUC_CONST;
-guint free_desktop_introspectable_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
-GType free_desktop_introspectable_get_type (void) G_GNUC_CONST;
-gchar* free_desktop_introspectable_Introspect (FreeDesktopIntrospectable* self, GError** error);
-GQuark xml_error_quark (void);
-GType fetch_file_get_type (void) G_GNUC_CONST;
-FetchFile* fetch_file_new (const gchar* uri, const gchar* prop);
-FetchFile* fetch_file_construct (GType object_type, const gchar* uri, const gchar* prop);
-void fetch_file_fetch_data (FetchFile* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
-void fetch_file_fetch_data_finish (FetchFile* self, GAsyncResult* _res_);
-const gchar* fetch_file_get_uri (FetchFile* self);
-const gchar* fetch_file_get_intended_property (FetchFile* self);
-
-
-G_END_DECLS
-
-#endif
diff -Naur indicator-sound-0.8.5.0/src/music-player-bridge.vala indicator-sound-precise/src/music-player-bridge.vala
--- indicator-sound-0.8.5.0/src/music-player-bridge.vala	2012-03-30 10:26:53.000000000 -0700
+++ indicator-sound-precise/src/music-player-bridge.vala	2012-07-26 21:03:55.488143000 -0700
@@ -40,6 +40,7 @@
     this.file_monitors = new HashMap<string, string> ();
     this.settings_manager = new SettingsManager();
     this.settings_manager.blacklist_updates.connect ( this.on_blacklist_update );
+    this.settings_manager.preferred_updates.connect ( this.on_preferred_update );
   }
   
   private void on_blacklist_update ( string[] blacklist )
@@ -58,8 +59,26 @@
     this.watcher.check_for_active_clients.begin();
   }
 
+  private void on_preferred_update ( Gee.ArrayList<string> preferred )
+  {
+    debug ("Preferred players update. Clearing current preferred players...");
+
+    foreach (var player_controller in this.registered_clients.values) {
+      player_controller.set_as_preferred (false);
+    }
+
+    foreach (var s in preferred) {
+      string key = this.determine_key (s);
+      if (this.registered_clients.has_key (key)) {
+        debug ("Setting %s as preferred player", key);
+        this.registered_clients[key].set_as_preferred (true);
+      }
+    }
+  }
+
   private void try_to_add_inactive_familiar_clients()
   {
+    var preferred_players = this.settings_manager.fetch_preferred ();
     foreach ( string desktop in this.settings_manager.fetch_interested()){
       debug ( "interested client found : %s", desktop );
       AppInfo? app_info = create_app_info ( desktop.concat( ".desktop" ) );
@@ -68,14 +87,16 @@
                    desktop );
         continue;
       }
-      var mpris_key = determine_key ( desktop );
+      bool is_preferred = desktop in preferred_players;
       PlayerController ctrl = new PlayerController ( this.root_menu, 
                                                      app_info,
                                                      null,
                                                      this.fetch_icon_name(desktop),
                                                      calculate_menu_position(),
                                                      null,
-                                                     PlayerController.state.OFFLINE );
+                                                     PlayerController.state.OFFLINE,
+                                                     is_preferred );
+      var mpris_key = determine_key ( desktop );
       this.registered_clients.set(mpris_key, ctrl);  
       this.establish_file_monitoring (app_info, mpris_key);
     }
@@ -163,7 +184,7 @@
     }
     
     var mpris_key = determine_key ( desktop );
-    // Are we sure clients will appear like this with the new registration method in place. 
+    bool is_preferred = desktop in this.settings_manager.fetch_preferred ();
     if ( this.registered_clients.has_key (mpris_key) == false ){
       debug("New client has registered that we have not seen before: %s", dbus_name );
       PlayerController ctrl = new PlayerController ( this.root_menu,
@@ -172,7 +193,8 @@
                                                      this.fetch_icon_name(desktop),                                                    
                                                      this.calculate_menu_position(),
                                                      use_playlists,
-                                                     PlayerController.state.READY );
+                                                     PlayerController.state.READY,
+                                                     is_preferred);
       this.registered_clients.set ( mpris_key, ctrl );
       debug ( "Have not seen this %s before, new controller created.", desktop );        
       this.settings_manager.add_interested ( desktop );
@@ -189,14 +211,14 @@
   
   public void client_has_vanished ( string mpris_root_interface )
   {
-    debug("MusicPlayerBridge -> client with dbus interface %s has vanished",
+    debug("\n MusicPlayerBridge -> client with dbus interface %s has vanished",
            mpris_root_interface );
     if (root_menu != null){
-      debug("attempt to remove %s", mpris_root_interface);
+      debug("\n attempt to remove %s", mpris_root_interface);
       var mpris_key = determine_key ( mpris_root_interface );
       if ( mpris_key != null && this.registered_clients.has_key(mpris_key)){
         registered_clients[mpris_key].hibernate();
-        debug("Successively offlined client %s", mpris_key);       
+        debug("\n Successively offlined client %s", mpris_key);       
       }
     }
   }
@@ -279,15 +301,21 @@
    */
   private static string? determine_key(owned string desktop_or_interface)
   {
+    // handle the special case of amarok, (kde4-amarok desktop file name) 
+    if (desktop_or_interface.contains("amarok")){
+      return "amarok";
+    }
+    
     var result = desktop_or_interface;
+
     var tokens = desktop_or_interface.split( "." );
     if (tokens != null && tokens.length > 1){
       result = tokens[tokens.length - 1];  
-    }
+    }    
     var temp = result.split("-");
     if (temp != null && temp.length > 1){
       result = temp[0];
-    }
+    }    
     return result;        
   }
   
diff -Naur indicator-sound-0.8.5.0/src/player-controller.c indicator-sound-precise/src/player-controller.c
--- indicator-sound-0.8.5.0/src/player-controller.c	2012-03-30 10:32:34.000000000 -0700
+++ indicator-sound-precise/src/player-controller.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,1082 +0,0 @@
-/* player-controller.c generated by valac 0.14.2, the Vala compiler
- * generated from player-controller.vala, do not modify */
-
-/*
-Copyright 2010 Canonical Ltd.
-
-Authors:
-    Conor Curran <conor.curran@canonical.com>
-
-This program is free software: you can redistribute it and/or modify it 
-under the terms of the GNU General Public License version 3, as published 
-by the Free Software Foundation.
-
-This program is distributed in the hope that it will be useful, but 
-WITHOUT ANY WARRANTY; without even the implied warranties of 
-MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
-PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along 
-with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libdbusmenu-glib/client.h>
-#include <libdbusmenu-glib/dbusmenu-glib.h>
-#include <libdbusmenu-glib/enum-types.h>
-#include <libdbusmenu-glib/menuitem-proxy.h>
-#include <libdbusmenu-glib/menuitem.h>
-#include <libdbusmenu-glib/server.h>
-#include <libdbusmenu-glib/types.h>
-#include <gee.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gio/gio.h>
-#include <common-defs.h>
-
-
-#define TYPE_PLAYER_CONTROLLER (player_controller_get_type ())
-#define PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONTROLLER, PlayerController))
-#define PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-#define IS_PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONTROLLER))
-#define IS_PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONTROLLER))
-#define PLAYER_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-
-typedef struct _PlayerController PlayerController;
-typedef struct _PlayerControllerClass PlayerControllerClass;
-typedef struct _PlayerControllerPrivate PlayerControllerPrivate;
-
-#define TYPE_PLAYER_ITEM (player_item_get_type ())
-#define PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_ITEM, PlayerItem))
-#define PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_ITEM, PlayerItemClass))
-#define IS_PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_ITEM))
-#define IS_PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_ITEM))
-#define PLAYER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_ITEM, PlayerItemClass))
-
-typedef struct _PlayerItem PlayerItem;
-typedef struct _PlayerItemClass PlayerItemClass;
-
-#define TYPE_MPRIS2_CONTROLLER (mpris2_controller_get_type ())
-#define MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2Controller))
-#define MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
-#define IS_MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS2_CONTROLLER))
-#define IS_MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS2_CONTROLLER))
-#define MPRIS2_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
-
-typedef struct _Mpris2Controller Mpris2Controller;
-typedef struct _Mpris2ControllerClass Mpris2ControllerClass;
-
-#define TYPE_SPECIFIC_ITEMS_MANAGER (specific_items_manager_get_type ())
-#define SPECIFIC_ITEMS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SPECIFIC_ITEMS_MANAGER, SpecificItemsManager))
-#define SPECIFIC_ITEMS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SPECIFIC_ITEMS_MANAGER, SpecificItemsManagerClass))
-#define IS_SPECIFIC_ITEMS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SPECIFIC_ITEMS_MANAGER))
-#define IS_SPECIFIC_ITEMS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SPECIFIC_ITEMS_MANAGER))
-#define SPECIFIC_ITEMS_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SPECIFIC_ITEMS_MANAGER, SpecificItemsManagerClass))
-
-typedef struct _SpecificItemsManager SpecificItemsManager;
-typedef struct _SpecificItemsManagerClass SpecificItemsManagerClass;
-
-#define PLAYER_CONTROLLER_TYPE_WIDGET_ORDER (player_controller_widget_order_get_type ())
-
-#define PLAYER_CONTROLLER_TYPE_STATE (player_controller_state_get_type ())
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
-
-#define SPECIFIC_ITEMS_MANAGER_TYPE_CATEGORY (specific_items_manager_category_get_type ())
-
-#define TYPE_PLAYLISTS_MENUITEM (playlists_menuitem_get_type ())
-#define PLAYLISTS_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYLISTS_MENUITEM, PlaylistsMenuitem))
-#define PLAYLISTS_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYLISTS_MENUITEM, PlaylistsMenuitemClass))
-#define IS_PLAYLISTS_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYLISTS_MENUITEM))
-#define IS_PLAYLISTS_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYLISTS_MENUITEM))
-#define PLAYLISTS_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYLISTS_MENUITEM, PlaylistsMenuitemClass))
-
-typedef struct _PlaylistsMenuitem PlaylistsMenuitem;
-typedef struct _PlaylistsMenuitemClass PlaylistsMenuitemClass;
-typedef struct _PlayerItemPrivate PlayerItemPrivate;
-typedef struct _PlaylistsMenuitemPrivate PlaylistsMenuitemPrivate;
-
-#define TYPE_TRANSPORT_MENUITEM (transport_menuitem_get_type ())
-#define TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitem))
-#define TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))
-#define IS_TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRANSPORT_MENUITEM))
-#define IS_TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRANSPORT_MENUITEM))
-#define TRANSPORT_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))
-
-typedef struct _TransportMenuitem TransportMenuitem;
-typedef struct _TransportMenuitemClass TransportMenuitemClass;
-
-#define TYPE_METADATA_MENUITEM (metadata_menuitem_get_type ())
-#define METADATA_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_METADATA_MENUITEM, MetadataMenuitem))
-#define METADATA_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_METADATA_MENUITEM, MetadataMenuitemClass))
-#define IS_METADATA_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_METADATA_MENUITEM))
-#define IS_METADATA_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_METADATA_MENUITEM))
-#define METADATA_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_METADATA_MENUITEM, MetadataMenuitemClass))
-
-typedef struct _MetadataMenuitem MetadataMenuitem;
-typedef struct _MetadataMenuitemClass MetadataMenuitemClass;
-
-struct _PlayerController {
-	GObject parent_instance;
-	PlayerControllerPrivate * priv;
-	gint current_state;
-	DbusmenuMenuitem* root_menu;
-	GeeArrayList* custom_items;
-	Mpris2Controller* mpris_bridge;
-	gboolean* use_playlists;
-};
-
-struct _PlayerControllerClass {
-	GObjectClass parent_class;
-};
-
-struct _PlayerControllerPrivate {
-	gchar* _dbus_name;
-	GAppInfo* _app_info;
-	gint _menu_offset;
-	gchar* _icon_name;
-	SpecificItemsManager* track_specific_mgr;
-	SpecificItemsManager* player_specific_mgr;
-};
-
-typedef enum  {
-	PLAYER_CONTROLLER_WIDGET_ORDER_SEPARATOR,
-	PLAYER_CONTROLLER_WIDGET_ORDER_METADATA,
-	PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT,
-	PLAYER_CONTROLLER_WIDGET_ORDER_PLAYLISTS
-} PlayerControllerwidget_order;
-
-typedef enum  {
-	PLAYER_CONTROLLER_STATE_OFFLINE,
-	PLAYER_CONTROLLER_STATE_INSTANTIATING,
-	PLAYER_CONTROLLER_STATE_READY,
-	PLAYER_CONTROLLER_STATE_CONNECTED,
-	PLAYER_CONTROLLER_STATE_DISCONNECTED
-} PlayerControllerstate;
-
-typedef enum  {
-	SPECIFIC_ITEMS_MANAGER_CATEGORY_TRACK,
-	SPECIFIC_ITEMS_MANAGER_CATEGORY_PLAYER
-} SpecificItemsManagercategory;
-
-struct _PlayerItem {
-	DbusmenuMenuitem parent_instance;
-	PlayerItemPrivate * priv;
-};
-
-struct _PlayerItemClass {
-	DbusmenuMenuitemClass parent_class;
-};
-
-struct _PlaylistsMenuitem {
-	PlayerItem parent_instance;
-	PlaylistsMenuitemPrivate * priv;
-	DbusmenuMenuitem* root_item;
-};
-
-struct _PlaylistsMenuitemClass {
-	PlayerItemClass parent_class;
-};
-
-
-static gpointer player_controller_parent_class = NULL;
-
-GType player_controller_get_type (void) G_GNUC_CONST;
-GType player_item_get_type (void) G_GNUC_CONST;
-GType mpris2_controller_get_type (void) G_GNUC_CONST;
-GType specific_items_manager_get_type (void) G_GNUC_CONST;
-#define PLAYER_CONTROLLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PLAYER_CONTROLLER, PlayerControllerPrivate))
-enum  {
-	PLAYER_CONTROLLER_DUMMY_PROPERTY,
-	PLAYER_CONTROLLER_DBUS_NAME,
-	PLAYER_CONTROLLER_APP_INFO,
-	PLAYER_CONTROLLER_MENU_OFFSET,
-	PLAYER_CONTROLLER_ICON_NAME
-};
-GType player_controller_widget_order_get_type (void) G_GNUC_CONST;
-GType player_controller_state_get_type (void) G_GNUC_CONST;
-#define PLAYER_CONTROLLER_WIDGET_QUANTITY 4
-PlayerController* player_controller_new (DbusmenuMenuitem* root, GAppInfo* app, const gchar* dbus_name, const gchar* icon_name, gint offset, gboolean* use_playlists, PlayerControllerstate initial_state);
-PlayerController* player_controller_construct (GType object_type, DbusmenuMenuitem* root, GAppInfo* app, const gchar* dbus_name, const gchar* icon_name, gint offset, gboolean* use_playlists, PlayerControllerstate initial_state);
-static gboolean* _bool_dup (gboolean* self);
-void player_controller_set_app_info (PlayerController* self, GAppInfo* value);
-void player_controller_set_dbus_name (PlayerController* self, const gchar* value);
-void player_controller_set_icon_name (PlayerController* self, const gchar* value);
-void player_controller_set_menu_offset (PlayerController* self, gint value);
-static void player_controller_construct_widgets (PlayerController* self);
-static void player_controller_establish_mpris_connection (PlayerController* self);
-void player_controller_update_layout (PlayerController* self);
-GAppInfo* player_controller_get_app_info (PlayerController* self);
-const gchar* player_controller_get_icon_name (PlayerController* self);
-void player_controller_update_state (PlayerController* self, PlayerControllerstate new_state);
-void player_controller_activate (PlayerController* self, const gchar* dbus_name);
-void player_controller_instantiate (PlayerController* self);
-void player_controller_enable_track_specific_items (PlayerController* self, const gchar* object_path);
-GType specific_items_manager_category_get_type (void) G_GNUC_CONST;
-SpecificItemsManager* specific_items_manager_new (PlayerController* controller, const gchar* path, SpecificItemsManagercategory which_type);
-SpecificItemsManager* specific_items_manager_construct (GType object_type, PlayerController* controller, const gchar* path, SpecificItemsManagercategory which_type);
-void player_controller_enable_player_specific_items (PlayerController* self, const gchar* object_path);
-gint player_controller_track_specific_count (PlayerController* self);
-GeeArrayList* specific_items_manager_get_proxy_items (SpecificItemsManager* self);
-const gchar* player_controller_get_dbus_name (PlayerController* self);
-Mpris2Controller* mpris2_controller_new (PlayerController* ctrl);
-Mpris2Controller* mpris2_controller_construct (GType object_type, PlayerController* ctrl);
-static void player_controller_determine_state (PlayerController* self);
-void player_controller_remove_from_menu (PlayerController* self);
-static gboolean _bool_equal (const gboolean* s1, const gboolean* s2);
-GType playlists_menuitem_get_type (void) G_GNUC_CONST;
-void player_controller_hibernate (PlayerController* self);
-GType transport_menuitem_get_type (void) G_GNUC_CONST;
-void transport_menuitem_change_play_state (TransportMenuitem* self, TransportState update);
-void player_item_reset (PlayerItem* self, GeeHashSet* attrs);
-GeeHashSet* metadata_menuitem_relevant_attributes_for_ui (void);
-GType metadata_menuitem_get_type (void) G_GNUC_CONST;
-void metadata_menuitem_toggle_active_triangle (MetadataMenuitem* self, gboolean update);
-void metadata_menuitem_should_collapse (MetadataMenuitem* self, gboolean collapse);
-gboolean player_item_populated (PlayerItem* self, GeeHashSet* attrs);
-void transport_menuitem_handle_cached_action (TransportMenuitem* self);
-PlayerItem* player_item_new (const gchar* type);
-PlayerItem* player_item_construct (GType object_type, const gchar* type);
-MetadataMenuitem* metadata_menuitem_new (PlayerController* parent);
-MetadataMenuitem* metadata_menuitem_construct (GType object_type, PlayerController* parent);
-TransportMenuitem* transport_menuitem_new (PlayerController* parent);
-TransportMenuitem* transport_menuitem_construct (GType object_type, PlayerController* parent);
-PlaylistsMenuitem* playlists_menuitem_new (PlayerController* parent);
-PlaylistsMenuitem* playlists_menuitem_construct (GType object_type, PlayerController* parent);
-gint player_controller_get_menu_offset (PlayerController* self);
-gboolean mpris2_controller_connected (Mpris2Controller* self);
-void mpris2_controller_initial_update (Mpris2Controller* self);
-static void player_controller_finalize (GObject* obj);
-static void _vala_player_controller_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
-static void _vala_player_controller_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
-
-
-GType player_controller_widget_order_get_type (void) {
-	static volatile gsize player_controller_widget_order_type_id__volatile = 0;
-	if (g_once_init_enter (&player_controller_widget_order_type_id__volatile)) {
-		static const GEnumValue values[] = {{PLAYER_CONTROLLER_WIDGET_ORDER_SEPARATOR, "PLAYER_CONTROLLER_WIDGET_ORDER_SEPARATOR", "separator"}, {PLAYER_CONTROLLER_WIDGET_ORDER_METADATA, "PLAYER_CONTROLLER_WIDGET_ORDER_METADATA", "metadata"}, {PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT, "PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT", "transport"}, {PLAYER_CONTROLLER_WIDGET_ORDER_PLAYLISTS, "PLAYER_CONTROLLER_WIDGET_ORDER_PLAYLISTS", "playlists"}, {0, NULL, NULL}};
-		GType player_controller_widget_order_type_id;
-		player_controller_widget_order_type_id = g_enum_register_static ("PlayerControllerwidget_order", values);
-		g_once_init_leave (&player_controller_widget_order_type_id__volatile, player_controller_widget_order_type_id);
-	}
-	return player_controller_widget_order_type_id__volatile;
-}
-
-
-GType player_controller_state_get_type (void) {
-	static volatile gsize player_controller_state_type_id__volatile = 0;
-	if (g_once_init_enter (&player_controller_state_type_id__volatile)) {
-		static const GEnumValue values[] = {{PLAYER_CONTROLLER_STATE_OFFLINE, "PLAYER_CONTROLLER_STATE_OFFLINE", "offline"}, {PLAYER_CONTROLLER_STATE_INSTANTIATING, "PLAYER_CONTROLLER_STATE_INSTANTIATING", "instantiating"}, {PLAYER_CONTROLLER_STATE_READY, "PLAYER_CONTROLLER_STATE_READY", "ready"}, {PLAYER_CONTROLLER_STATE_CONNECTED, "PLAYER_CONTROLLER_STATE_CONNECTED", "connected"}, {PLAYER_CONTROLLER_STATE_DISCONNECTED, "PLAYER_CONTROLLER_STATE_DISCONNECTED", "disconnected"}, {0, NULL, NULL}};
-		GType player_controller_state_type_id;
-		player_controller_state_type_id = g_enum_register_static ("PlayerControllerstate", values);
-		g_once_init_leave (&player_controller_state_type_id__volatile, player_controller_state_type_id);
-	}
-	return player_controller_state_type_id__volatile;
-}
-
-
-static gboolean* _bool_dup (gboolean* self) {
-	gboolean* dup;
-	dup = g_new0 (gboolean, 1);
-	memcpy (dup, self, sizeof (gboolean));
-	return dup;
-}
-
-
-static gpointer __bool_dup0 (gpointer self) {
-	return self ? _bool_dup (self) : NULL;
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-PlayerController* player_controller_construct (GType object_type, DbusmenuMenuitem* root, GAppInfo* app, const gchar* dbus_name, const gchar* icon_name, gint offset, gboolean* use_playlists, PlayerControllerstate initial_state) {
-	PlayerController * self = NULL;
-	gboolean* _tmp0_;
-	gboolean* _tmp1_;
-	DbusmenuMenuitem* _tmp2_;
-	DbusmenuMenuitem* _tmp3_;
-	GAppInfo* _tmp4_;
-	const gchar* _tmp5_;
-	const gchar* _tmp6_;
-	GeeArrayList* _tmp7_;
-	PlayerControllerstate _tmp8_;
-	gint _tmp9_;
-	GAppInfo* _tmp10_;
-	const gchar* _tmp11_ = NULL;
-	const gchar* _tmp12_;
-	g_return_val_if_fail (root != NULL, NULL);
-	g_return_val_if_fail (app != NULL, NULL);
-	g_return_val_if_fail (icon_name != NULL, NULL);
-	self = (PlayerController*) g_object_new (object_type, NULL);
-	_tmp0_ = use_playlists;
-	_tmp1_ = __bool_dup0 (_tmp0_);
-	_g_free0 (self->use_playlists);
-	self->use_playlists = _tmp1_;
-	_tmp2_ = root;
-	_tmp3_ = _g_object_ref0 (_tmp2_);
-	_g_object_unref0 (self->root_menu);
-	self->root_menu = _tmp3_;
-	_tmp4_ = app;
-	player_controller_set_app_info (self, _tmp4_);
-	_tmp5_ = dbus_name;
-	player_controller_set_dbus_name (self, _tmp5_);
-	_tmp6_ = icon_name;
-	player_controller_set_icon_name (self, _tmp6_);
-	_tmp7_ = gee_array_list_new (TYPE_PLAYER_ITEM, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
-	_g_object_unref0 (self->custom_items);
-	self->custom_items = _tmp7_;
-	_tmp8_ = initial_state;
-	self->current_state = (gint) _tmp8_;
-	_tmp9_ = offset;
-	player_controller_set_menu_offset (self, _tmp9_);
-	player_controller_construct_widgets (self);
-	player_controller_establish_mpris_connection (self);
-	player_controller_update_layout (self);
-	_tmp10_ = self->priv->_app_info;
-	_tmp11_ = g_app_info_get_name (_tmp10_);
-	_tmp12_ = self->priv->_icon_name;
-	g_debug ("player-controller.vala:74: New player controller  for %s with icon nam" \
-"e %s", _tmp11_, _tmp12_);
-	return self;
-}
-
-
-PlayerController* player_controller_new (DbusmenuMenuitem* root, GAppInfo* app, const gchar* dbus_name, const gchar* icon_name, gint offset, gboolean* use_playlists, PlayerControllerstate initial_state) {
-	return player_controller_construct (TYPE_PLAYER_CONTROLLER, root, app, dbus_name, icon_name, offset, use_playlists, initial_state);
-}
-
-
-void player_controller_update_state (PlayerController* self, PlayerControllerstate new_state) {
-	GAppInfo* _tmp0_;
-	const gchar* _tmp1_ = NULL;
-	PlayerControllerstate _tmp2_;
-	PlayerControllerstate _tmp3_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = self->priv->_app_info;
-	_tmp1_ = g_app_info_get_name (_tmp0_);
-	_tmp2_ = new_state;
-	g_debug ("player-controller.vala:79: update_state - player controller %s : new s" \
-"tate %i", _tmp1_, (gint) _tmp2_);
-	_tmp3_ = new_state;
-	self->current_state = (gint) _tmp3_;
-	player_controller_update_layout (self);
-}
-
-
-void player_controller_activate (PlayerController* self, const gchar* dbus_name) {
-	const gchar* _tmp0_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (dbus_name != NULL);
-	_tmp0_ = dbus_name;
-	player_controller_set_dbus_name (self, _tmp0_);
-	player_controller_establish_mpris_connection (self);
-}
-
-
-void player_controller_instantiate (PlayerController* self) {
-	GAppInfo* _tmp0_;
-	const gchar* _tmp1_ = NULL;
-	GError * _inner_error_ = NULL;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = self->priv->_app_info;
-	_tmp1_ = g_app_info_get_name (_tmp0_);
-	g_debug ("player-controller.vala:99: instantiate in player controller for %s", _tmp1_);
-	{
-		GAppInfo* _tmp2_;
-		_tmp2_ = self->priv->_app_info;
-		g_app_info_launch (_tmp2_, NULL, NULL, &_inner_error_);
-		if (_inner_error_ != NULL) {
-			goto __catch7_g_error;
-		}
-		player_controller_update_state (self, PLAYER_CONTROLLER_STATE_INSTANTIATING);
-	}
-	goto __finally7;
-	__catch7_g_error:
-	{
-		GError* _error_ = NULL;
-		GAppInfo* _tmp3_;
-		const gchar* _tmp4_ = NULL;
-		GError* _tmp5_;
-		const gchar* _tmp6_;
-		_error_ = _inner_error_;
-		_inner_error_ = NULL;
-		_tmp3_ = self->priv->_app_info;
-		_tmp4_ = g_app_info_get_name (_tmp3_);
-		_tmp5_ = _error_;
-		_tmp6_ = _tmp5_->message;
-		g_warning ("player-controller.vala:105: Failed to launch app %s with error message" \
-": %s", _tmp4_, _tmp6_);
-		_g_error_free0 (_error_);
-	}
-	__finally7:
-	if (_inner_error_ != NULL) {
-		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
-		g_clear_error (&_inner_error_);
-		return;
-	}
-}
-
-
-void player_controller_enable_track_specific_items (PlayerController* self, const gchar* object_path) {
-	SpecificItemsManager* _tmp0_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (object_path != NULL);
-	_tmp0_ = self->priv->track_specific_mgr;
-	if (_tmp0_ == NULL) {
-		const gchar* _tmp1_;
-		SpecificItemsManager* _tmp2_;
-		_tmp1_ = object_path;
-		_tmp2_ = specific_items_manager_new (self, _tmp1_, SPECIFIC_ITEMS_MANAGER_CATEGORY_TRACK);
-		_g_object_unref0 (self->priv->track_specific_mgr);
-		self->priv->track_specific_mgr = _tmp2_;
-	}
-}
-
-
-void player_controller_enable_player_specific_items (PlayerController* self, const gchar* object_path) {
-	SpecificItemsManager* _tmp0_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (object_path != NULL);
-	_tmp0_ = self->priv->player_specific_mgr;
-	if (_tmp0_ == NULL) {
-		const gchar* _tmp1_;
-		SpecificItemsManager* _tmp2_;
-		_tmp1_ = object_path;
-		_tmp2_ = specific_items_manager_new (self, _tmp1_, SPECIFIC_ITEMS_MANAGER_CATEGORY_PLAYER);
-		_g_object_unref0 (self->priv->player_specific_mgr);
-		self->priv->player_specific_mgr = _tmp2_;
-	}
-}
-
-
-gint player_controller_track_specific_count (PlayerController* self) {
-	gint result = 0;
-	SpecificItemsManager* _tmp0_;
-	SpecificItemsManager* _tmp1_;
-	GeeArrayList* _tmp2_;
-	GeeArrayList* _tmp3_;
-	gint _tmp4_;
-	gint _tmp5_;
-	g_return_val_if_fail (self != NULL, 0);
-	_tmp0_ = self->priv->track_specific_mgr;
-	if (_tmp0_ == NULL) {
-		result = 0;
-		return result;
-	}
-	_tmp1_ = self->priv->track_specific_mgr;
-	_tmp2_ = specific_items_manager_get_proxy_items (_tmp1_);
-	_tmp3_ = _tmp2_;
-	_tmp4_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp3_);
-	_tmp5_ = _tmp4_;
-	result = _tmp5_;
-	return result;
-}
-
-
-static gchar* bool_to_string (gboolean self) {
-	gchar* result = NULL;
-	if (self) {
-		gchar* _tmp0_;
-		_tmp0_ = g_strdup ("true");
-		result = _tmp0_;
-		return result;
-	} else {
-		gchar* _tmp1_;
-		_tmp1_ = g_strdup ("false");
-		result = _tmp1_;
-		return result;
-	}
-}
-
-
-static void player_controller_establish_mpris_connection (PlayerController* self) {
-	gboolean _tmp0_ = FALSE;
-	gint _tmp1_;
-	gboolean _tmp3_;
-	gboolean* _tmp4_;
-	gchar* _tmp5_ = NULL;
-	gchar* _tmp6_;
-	Mpris2Controller* _tmp7_;
-	g_return_if_fail (self != NULL);
-	_tmp1_ = self->current_state;
-	if (_tmp1_ != ((gint) PLAYER_CONTROLLER_STATE_READY)) {
-		_tmp0_ = TRUE;
-	} else {
-		const gchar* _tmp2_;
-		_tmp2_ = self->priv->_dbus_name;
-		_tmp0_ = _tmp2_ == NULL;
-	}
-	_tmp3_ = _tmp0_;
-	if (_tmp3_) {
-		g_debug ("player-controller.vala:139: establish_mpris_connection - Not ready to " \
-"connect");
-		return;
-	}
-	_tmp4_ = self->use_playlists;
-	_tmp5_ = bool_to_string (*_tmp4_);
-	_tmp6_ = _tmp5_;
-	g_debug ("player-controller.vala:142:  establish mpris connection - use playlist" \
-"s value = %s ", _tmp6_);
-	_g_free0 (_tmp6_);
-	_tmp7_ = mpris2_controller_new (self);
-	_g_object_unref0 (self->mpris_bridge);
-	self->mpris_bridge = _tmp7_;
-	player_controller_determine_state (self);
-}
-
-
-static gboolean _bool_equal (const gboolean* s1, const gboolean* s2) {
-	if (s1 == s2) {
-		return TRUE;
-	}
-	if (s1 == NULL) {
-		return FALSE;
-	}
-	if (s2 == NULL) {
-		return FALSE;
-	}
-	return (*s1) == (*s2);
-}
-
-
-void player_controller_remove_from_menu (PlayerController* self) {
-	gboolean* _tmp13_;
-	gboolean _tmp14_;
-	g_return_if_fail (self != NULL);
-	{
-		GeeArrayList* _tmp0_;
-		GeeArrayList* _tmp1_;
-		GeeArrayList* _item_list;
-		GeeArrayList* _tmp2_;
-		gint _tmp3_;
-		gint _tmp4_;
-		gint _item_size;
-		gint _item_index;
-		_tmp0_ = self->custom_items;
-		_tmp1_ = _g_object_ref0 (_tmp0_);
-		_item_list = _tmp1_;
-		_tmp2_ = _item_list;
-		_tmp3_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp2_);
-		_tmp4_ = _tmp3_;
-		_item_size = _tmp4_;
-		_item_index = -1;
-		while (TRUE) {
-			gint _tmp5_;
-			gint _tmp6_;
-			gint _tmp7_;
-			GeeArrayList* _tmp8_;
-			gint _tmp9_;
-			gpointer _tmp10_ = NULL;
-			PlayerItem* item;
-			DbusmenuMenuitem* _tmp11_;
-			PlayerItem* _tmp12_;
-			_tmp5_ = _item_index;
-			_item_index = _tmp5_ + 1;
-			_tmp6_ = _item_index;
-			_tmp7_ = _item_size;
-			if (!(_tmp6_ < _tmp7_)) {
-				break;
-			}
-			_tmp8_ = _item_list;
-			_tmp9_ = _item_index;
-			_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, _tmp9_);
-			item = (PlayerItem*) _tmp10_;
-			_tmp11_ = self->root_menu;
-			_tmp12_ = item;
-			dbusmenu_menuitem_child_delete (_tmp11_, (DbusmenuMenuitem*) _tmp12_);
-			_g_object_unref0 (item);
-		}
-		_g_object_unref0 (_item_list);
-	}
-	_tmp13_ = self->use_playlists;
-	_tmp14_ = TRUE;
-	if (_bool_equal (_tmp13_, &_tmp14_) == TRUE) {
-		GeeArrayList* _tmp15_;
-		gpointer _tmp16_ = NULL;
-		PlaylistsMenuitem* playlists_menuitem;
-		DbusmenuMenuitem* _tmp17_;
-		PlaylistsMenuitem* _tmp18_;
-		DbusmenuMenuitem* _tmp19_;
-		_tmp15_ = self->custom_items;
-		_tmp16_ = gee_abstract_list_get ((GeeAbstractList*) _tmp15_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_PLAYLISTS);
-		playlists_menuitem = IS_PLAYLISTS_MENUITEM ((PlayerItem*) _tmp16_) ? ((PlaylistsMenuitem*) ((PlayerItem*) _tmp16_)) : NULL;
-		_tmp17_ = self->root_menu;
-		_tmp18_ = playlists_menuitem;
-		_tmp19_ = _tmp18_->root_item;
-		dbusmenu_menuitem_child_delete (_tmp17_, _tmp19_);
-		_g_object_unref0 (playlists_menuitem);
-	}
-}
-
-
-void player_controller_hibernate (PlayerController* self) {
-	GeeArrayList* _tmp0_;
-	gpointer _tmp1_ = NULL;
-	TransportMenuitem* transport;
-	GeeArrayList* _tmp2_;
-	gpointer _tmp3_ = NULL;
-	PlayerItem* _tmp4_;
-	GeeHashSet* _tmp5_ = NULL;
-	GeeHashSet* _tmp6_;
-	GeeArrayList* _tmp7_;
-	gpointer _tmp8_ = NULL;
-	MetadataMenuitem* md;
-	g_return_if_fail (self != NULL);
-	player_controller_update_state (self, PLAYER_CONTROLLER_STATE_OFFLINE);
-	_tmp0_ = self->custom_items;
-	_tmp1_ = gee_abstract_list_get ((GeeAbstractList*) _tmp0_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT);
-	transport = IS_TRANSPORT_MENUITEM ((PlayerItem*) _tmp1_) ? ((TransportMenuitem*) ((PlayerItem*) _tmp1_)) : NULL;
-	transport_menuitem_change_play_state (transport, TRANSPORT_STATE_PAUSED);
-	_tmp2_ = self->custom_items;
-	_tmp3_ = gee_abstract_list_get ((GeeAbstractList*) _tmp2_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA);
-	_tmp4_ = (PlayerItem*) _tmp3_;
-	_tmp5_ = metadata_menuitem_relevant_attributes_for_ui ();
-	_tmp6_ = _tmp5_;
-	player_item_reset (_tmp4_, _tmp6_);
-	_g_object_unref0 (_tmp6_);
-	_g_object_unref0 (_tmp4_);
-	_tmp7_ = self->custom_items;
-	_tmp8_ = gee_abstract_list_get ((GeeAbstractList*) _tmp7_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA);
-	md = IS_METADATA_MENUITEM ((PlayerItem*) _tmp8_) ? ((MetadataMenuitem*) ((PlayerItem*) _tmp8_)) : NULL;
-	metadata_menuitem_toggle_active_triangle (md, FALSE);
-	_g_object_unref0 (self->mpris_bridge);
-	self->mpris_bridge = NULL;
-	_g_object_unref0 (md);
-	_g_object_unref0 (transport);
-}
-
-
-void player_controller_update_layout (PlayerController* self) {
-	GeeArrayList* _tmp0_;
-	gpointer _tmp1_ = NULL;
-	PlaylistsMenuitem* playlists_menuitem;
-	GeeArrayList* _tmp2_;
-	gpointer _tmp3_ = NULL;
-	MetadataMenuitem* metadata_menuitem;
-	gint _tmp4_;
-	MetadataMenuitem* _tmp13_;
-	GeeArrayList* _tmp14_;
-	gpointer _tmp15_ = NULL;
-	PlayerItem* _tmp16_;
-	GeeHashSet* _tmp17_ = NULL;
-	GeeHashSet* _tmp18_;
-	gboolean _tmp19_ = FALSE;
-	GAppInfo* _tmp20_;
-	const gchar* _tmp21_ = NULL;
-	PlaylistsMenuitem* _tmp28_;
-	DbusmenuMenuitem* _tmp29_;
-	gboolean* _tmp30_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = self->custom_items;
-	_tmp1_ = gee_abstract_list_get ((GeeAbstractList*) _tmp0_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_PLAYLISTS);
-	playlists_menuitem = IS_PLAYLISTS_MENUITEM ((PlayerItem*) _tmp1_) ? ((PlaylistsMenuitem*) ((PlayerItem*) _tmp1_)) : NULL;
-	_tmp2_ = self->custom_items;
-	_tmp3_ = gee_abstract_list_get ((GeeAbstractList*) _tmp2_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA);
-	metadata_menuitem = IS_METADATA_MENUITEM ((PlayerItem*) _tmp3_) ? ((MetadataMenuitem*) ((PlayerItem*) _tmp3_)) : NULL;
-	_tmp4_ = self->current_state;
-	if (_tmp4_ != ((gint) PLAYER_CONTROLLER_STATE_CONNECTED)) {
-		MetadataMenuitem* _tmp5_;
-		PlaylistsMenuitem* _tmp6_;
-		DbusmenuMenuitem* _tmp7_;
-		GeeArrayList* _tmp8_;
-		gpointer _tmp9_ = NULL;
-		PlayerItem* _tmp10_;
-		GAppInfo* _tmp11_;
-		const gchar* _tmp12_ = NULL;
-		_tmp5_ = metadata_menuitem;
-		metadata_menuitem_should_collapse (_tmp5_, TRUE);
-		_tmp6_ = playlists_menuitem;
-		_tmp7_ = _tmp6_->root_item;
-		dbusmenu_menuitem_property_set_bool (_tmp7_, DBUSMENU_MENUITEM_PROP_VISIBLE, FALSE);
-		_tmp8_ = self->custom_items;
-		_tmp9_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT);
-		_tmp10_ = (PlayerItem*) _tmp9_;
-		_tmp11_ = self->priv->_app_info;
-		_tmp12_ = g_app_info_get_id (_tmp11_);
-		dbusmenu_menuitem_property_set_bool ((DbusmenuMenuitem*) _tmp10_, DBUSMENU_MENUITEM_PROP_VISIBLE, g_strcmp0 (_tmp12_, "rhythmbox.desktop") == 0);
-		_g_object_unref0 (_tmp10_);
-		_g_object_unref0 (metadata_menuitem);
-		_g_object_unref0 (playlists_menuitem);
-		return;
-	}
-	_tmp13_ = metadata_menuitem;
-	_tmp14_ = self->custom_items;
-	_tmp15_ = gee_abstract_list_get ((GeeAbstractList*) _tmp14_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA);
-	_tmp16_ = (PlayerItem*) _tmp15_;
-	_tmp17_ = metadata_menuitem_relevant_attributes_for_ui ();
-	_tmp18_ = _tmp17_;
-	_tmp19_ = player_item_populated (_tmp16_, _tmp18_);
-	metadata_menuitem_should_collapse (_tmp13_, !_tmp19_);
-	_g_object_unref0 (_tmp18_);
-	_g_object_unref0 (_tmp16_);
-	_tmp20_ = self->priv->_app_info;
-	_tmp21_ = g_app_info_get_id (_tmp20_);
-	if (g_strcmp0 (_tmp21_, "rhythmbox.desktop") == 0) {
-		GeeArrayList* _tmp22_;
-		gpointer _tmp23_ = NULL;
-		TransportMenuitem* transport;
-		TransportMenuitem* _tmp24_;
-		_tmp22_ = self->custom_items;
-		_tmp23_ = gee_abstract_list_get ((GeeAbstractList*) _tmp22_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT);
-		transport = IS_TRANSPORT_MENUITEM ((PlayerItem*) _tmp23_) ? ((TransportMenuitem*) ((PlayerItem*) _tmp23_)) : NULL;
-		_tmp24_ = transport;
-		transport_menuitem_handle_cached_action (_tmp24_);
-		_g_object_unref0 (transport);
-	} else {
-		GeeArrayList* _tmp25_;
-		gpointer _tmp26_ = NULL;
-		PlayerItem* _tmp27_;
-		_tmp25_ = self->custom_items;
-		_tmp26_ = gee_abstract_list_get ((GeeAbstractList*) _tmp25_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_TRANSPORT);
-		_tmp27_ = (PlayerItem*) _tmp26_;
-		dbusmenu_menuitem_property_set_bool ((DbusmenuMenuitem*) _tmp27_, DBUSMENU_MENUITEM_PROP_VISIBLE, TRUE);
-		_g_object_unref0 (_tmp27_);
-	}
-	_tmp28_ = playlists_menuitem;
-	_tmp29_ = _tmp28_->root_item;
-	_tmp30_ = self->use_playlists;
-	dbusmenu_menuitem_property_set_bool (_tmp29_, DBUSMENU_MENUITEM_PROP_VISIBLE, *_tmp30_);
-	_g_object_unref0 (metadata_menuitem);
-	_g_object_unref0 (playlists_menuitem);
-}
-
-
-static void player_controller_construct_widgets (PlayerController* self) {
-	GeeArrayList* _tmp0_;
-	PlayerItem* _tmp1_;
-	PlayerItem* _tmp2_;
-	MetadataMenuitem* _tmp3_;
-	MetadataMenuitem* metadata_item;
-	GeeArrayList* _tmp4_;
-	MetadataMenuitem* _tmp5_;
-	TransportMenuitem* _tmp6_;
-	TransportMenuitem* transport_item;
-	GeeArrayList* _tmp7_;
-	TransportMenuitem* _tmp8_;
-	PlaylistsMenuitem* _tmp9_;
-	PlaylistsMenuitem* playlist_menuitem;
-	GeeArrayList* _tmp10_;
-	PlaylistsMenuitem* _tmp11_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = self->custom_items;
-	_tmp1_ = player_item_new (DBUSMENU_CLIENT_TYPES_SEPARATOR);
-	_tmp2_ = _tmp1_;
-	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp0_, _tmp2_);
-	_g_object_unref0 (_tmp2_);
-	_tmp3_ = metadata_menuitem_new (self);
-	metadata_item = _tmp3_;
-	_tmp4_ = self->custom_items;
-	_tmp5_ = metadata_item;
-	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp4_, (PlayerItem*) _tmp5_);
-	_tmp6_ = transport_menuitem_new (self);
-	transport_item = _tmp6_;
-	_tmp7_ = self->custom_items;
-	_tmp8_ = transport_item;
-	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp7_, (PlayerItem*) _tmp8_);
-	_tmp9_ = playlists_menuitem_new (self);
-	playlist_menuitem = _tmp9_;
-	_tmp10_ = self->custom_items;
-	_tmp11_ = playlist_menuitem;
-	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp10_, (PlayerItem*) _tmp11_);
-	{
-		GeeArrayList* _tmp12_;
-		GeeArrayList* _tmp13_;
-		GeeArrayList* _item_list;
-		GeeArrayList* _tmp14_;
-		gint _tmp15_;
-		gint _tmp16_;
-		gint _item_size;
-		gint _item_index;
-		_tmp12_ = self->custom_items;
-		_tmp13_ = _g_object_ref0 (_tmp12_);
-		_item_list = _tmp13_;
-		_tmp14_ = _item_list;
-		_tmp15_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp14_);
-		_tmp16_ = _tmp15_;
-		_item_size = _tmp16_;
-		_item_index = -1;
-		while (TRUE) {
-			gint _tmp17_;
-			gint _tmp18_;
-			gint _tmp19_;
-			GeeArrayList* _tmp20_;
-			gint _tmp21_;
-			gpointer _tmp22_ = NULL;
-			PlayerItem* item;
-			GeeArrayList* _tmp23_;
-			PlayerItem* _tmp24_;
-			gint _tmp25_ = 0;
-			_tmp17_ = _item_index;
-			_item_index = _tmp17_ + 1;
-			_tmp18_ = _item_index;
-			_tmp19_ = _item_size;
-			if (!(_tmp18_ < _tmp19_)) {
-				break;
-			}
-			_tmp20_ = _item_list;
-			_tmp21_ = _item_index;
-			_tmp22_ = gee_abstract_list_get ((GeeAbstractList*) _tmp20_, _tmp21_);
-			item = (PlayerItem*) _tmp22_;
-			_tmp23_ = self->custom_items;
-			_tmp24_ = item;
-			_tmp25_ = gee_abstract_list_index_of ((GeeAbstractList*) _tmp23_, _tmp24_);
-			if (_tmp25_ == (PLAYER_CONTROLLER_WIDGET_QUANTITY - 1)) {
-				PlayerItem* _tmp26_;
-				PlaylistsMenuitem* _tmp27_;
-				PlaylistsMenuitem* playlists_menuitem;
-				DbusmenuMenuitem* _tmp28_;
-				PlaylistsMenuitem* _tmp29_;
-				DbusmenuMenuitem* _tmp30_;
-				gint _tmp31_;
-				GeeArrayList* _tmp32_;
-				PlayerItem* _tmp33_;
-				gint _tmp34_ = 0;
-				_tmp26_ = item;
-				_tmp27_ = _g_object_ref0 (IS_PLAYLISTS_MENUITEM (_tmp26_) ? ((PlaylistsMenuitem*) _tmp26_) : NULL);
-				playlists_menuitem = _tmp27_;
-				_tmp28_ = self->root_menu;
-				_tmp29_ = playlists_menuitem;
-				_tmp30_ = _tmp29_->root_item;
-				_tmp31_ = self->priv->_menu_offset;
-				_tmp32_ = self->custom_items;
-				_tmp33_ = item;
-				_tmp34_ = gee_abstract_list_index_of ((GeeAbstractList*) _tmp32_, _tmp33_);
-				dbusmenu_menuitem_child_add_position (_tmp28_, _tmp30_, (guint) (_tmp31_ + _tmp34_));
-				_g_object_unref0 (playlists_menuitem);
-			} else {
-				DbusmenuMenuitem* _tmp35_;
-				PlayerItem* _tmp36_;
-				gint _tmp37_;
-				GeeArrayList* _tmp38_;
-				PlayerItem* _tmp39_;
-				gint _tmp40_ = 0;
-				_tmp35_ = self->root_menu;
-				_tmp36_ = item;
-				_tmp37_ = self->priv->_menu_offset;
-				_tmp38_ = self->custom_items;
-				_tmp39_ = item;
-				_tmp40_ = gee_abstract_list_index_of ((GeeAbstractList*) _tmp38_, _tmp39_);
-				dbusmenu_menuitem_child_add_position (_tmp35_, (DbusmenuMenuitem*) _tmp36_, (guint) (_tmp37_ + _tmp40_));
-			}
-			_g_object_unref0 (item);
-		}
-		_g_object_unref0 (_item_list);
-	}
-	_g_object_unref0 (playlist_menuitem);
-	_g_object_unref0 (transport_item);
-	_g_object_unref0 (metadata_item);
-}
-
-
-static void player_controller_determine_state (PlayerController* self) {
-	Mpris2Controller* _tmp0_;
-	gboolean _tmp1_ = FALSE;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = self->mpris_bridge;
-	_tmp1_ = mpris2_controller_connected (_tmp0_);
-	if (_tmp1_ == TRUE) {
-		GeeArrayList* _tmp2_;
-		gpointer _tmp3_ = NULL;
-		MetadataMenuitem* md;
-		MetadataMenuitem* _tmp4_;
-		Mpris2Controller* _tmp5_;
-		player_controller_update_state (self, PLAYER_CONTROLLER_STATE_CONNECTED);
-		_tmp2_ = self->custom_items;
-		_tmp3_ = gee_abstract_list_get ((GeeAbstractList*) _tmp2_, (gint) PLAYER_CONTROLLER_WIDGET_ORDER_METADATA);
-		md = IS_METADATA_MENUITEM ((PlayerItem*) _tmp3_) ? ((MetadataMenuitem*) ((PlayerItem*) _tmp3_)) : NULL;
-		_tmp4_ = md;
-		metadata_menuitem_toggle_active_triangle (_tmp4_, TRUE);
-		_tmp5_ = self->mpris_bridge;
-		mpris2_controller_initial_update (_tmp5_);
-		_g_object_unref0 (md);
-	} else {
-		player_controller_update_state (self, PLAYER_CONTROLLER_STATE_DISCONNECTED);
-	}
-}
-
-
-const gchar* player_controller_get_dbus_name (PlayerController* self) {
-	const gchar* result;
-	const gchar* _tmp0_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = self->priv->_dbus_name;
-	result = _tmp0_;
-	return result;
-}
-
-
-void player_controller_set_dbus_name (PlayerController* self, const gchar* value) {
-	const gchar* _tmp0_;
-	gchar* _tmp1_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = value;
-	_tmp1_ = g_strdup (_tmp0_);
-	_g_free0 (self->priv->_dbus_name);
-	self->priv->_dbus_name = _tmp1_;
-	g_object_notify ((GObject *) self, "dbus-name");
-}
-
-
-GAppInfo* player_controller_get_app_info (PlayerController* self) {
-	GAppInfo* result;
-	GAppInfo* _tmp0_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = self->priv->_app_info;
-	result = _tmp0_;
-	return result;
-}
-
-
-void player_controller_set_app_info (PlayerController* self, GAppInfo* value) {
-	GAppInfo* _tmp0_;
-	GAppInfo* _tmp1_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = value;
-	_tmp1_ = _g_object_ref0 (_tmp0_);
-	_g_object_unref0 (self->priv->_app_info);
-	self->priv->_app_info = _tmp1_;
-	g_object_notify ((GObject *) self, "app-info");
-}
-
-
-gint player_controller_get_menu_offset (PlayerController* self) {
-	gint result;
-	gint _tmp0_;
-	g_return_val_if_fail (self != NULL, 0);
-	_tmp0_ = self->priv->_menu_offset;
-	result = _tmp0_;
-	return result;
-}
-
-
-void player_controller_set_menu_offset (PlayerController* self, gint value) {
-	gint _tmp0_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = value;
-	self->priv->_menu_offset = _tmp0_;
-	g_object_notify ((GObject *) self, "menu-offset");
-}
-
-
-const gchar* player_controller_get_icon_name (PlayerController* self) {
-	const gchar* result;
-	const gchar* _tmp0_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = self->priv->_icon_name;
-	result = _tmp0_;
-	return result;
-}
-
-
-void player_controller_set_icon_name (PlayerController* self, const gchar* value) {
-	const gchar* _tmp0_;
-	gchar* _tmp1_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = value;
-	_tmp1_ = g_strdup (_tmp0_);
-	_g_free0 (self->priv->_icon_name);
-	self->priv->_icon_name = _tmp1_;
-	g_object_notify ((GObject *) self, "icon-name");
-}
-
-
-static void player_controller_class_init (PlayerControllerClass * klass) {
-	player_controller_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (PlayerControllerPrivate));
-	G_OBJECT_CLASS (klass)->get_property = _vala_player_controller_get_property;
-	G_OBJECT_CLASS (klass)->set_property = _vala_player_controller_set_property;
-	G_OBJECT_CLASS (klass)->finalize = player_controller_finalize;
-	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_CONTROLLER_DBUS_NAME, g_param_spec_string ("dbus-name", "dbus-name", "dbus-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_CONTROLLER_APP_INFO, g_param_spec_object ("app-info", "app-info", "app-info", G_TYPE_APP_INFO, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_CONTROLLER_MENU_OFFSET, g_param_spec_int ("menu-offset", "menu-offset", "menu-offset", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_CONTROLLER_ICON_NAME, g_param_spec_string ("icon-name", "icon-name", "icon-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
-}
-
-
-static void player_controller_instance_init (PlayerController * self) {
-	self->priv = PLAYER_CONTROLLER_GET_PRIVATE (self);
-	self->current_state = (gint) PLAYER_CONTROLLER_STATE_OFFLINE;
-}
-
-
-static void player_controller_finalize (GObject* obj) {
-	PlayerController * self;
-	self = PLAYER_CONTROLLER (obj);
-	_g_object_unref0 (self->root_menu);
-	_g_free0 (self->priv->_dbus_name);
-	_g_object_unref0 (self->custom_items);
-	_g_object_unref0 (self->mpris_bridge);
-	_g_object_unref0 (self->priv->_app_info);
-	_g_free0 (self->priv->_icon_name);
-	_g_free0 (self->use_playlists);
-	_g_object_unref0 (self->priv->track_specific_mgr);
-	_g_object_unref0 (self->priv->player_specific_mgr);
-	G_OBJECT_CLASS (player_controller_parent_class)->finalize (obj);
-}
-
-
-GType player_controller_get_type (void) {
-	static volatile gsize player_controller_type_id__volatile = 0;
-	if (g_once_init_enter (&player_controller_type_id__volatile)) {
-		static const GTypeInfo g_define_type_info = { sizeof (PlayerControllerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) player_controller_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlayerController), 0, (GInstanceInitFunc) player_controller_instance_init, NULL };
-		GType player_controller_type_id;
-		player_controller_type_id = g_type_register_static (G_TYPE_OBJECT, "PlayerController", &g_define_type_info, 0);
-		g_once_init_leave (&player_controller_type_id__volatile, player_controller_type_id);
-	}
-	return player_controller_type_id__volatile;
-}
-
-
-static void _vala_player_controller_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
-	PlayerController * self;
-	self = PLAYER_CONTROLLER (object);
-	switch (property_id) {
-		case PLAYER_CONTROLLER_DBUS_NAME:
-		g_value_set_string (value, player_controller_get_dbus_name (self));
-		break;
-		case PLAYER_CONTROLLER_APP_INFO:
-		g_value_set_object (value, player_controller_get_app_info (self));
-		break;
-		case PLAYER_CONTROLLER_MENU_OFFSET:
-		g_value_set_int (value, player_controller_get_menu_offset (self));
-		break;
-		case PLAYER_CONTROLLER_ICON_NAME:
-		g_value_set_string (value, player_controller_get_icon_name (self));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void _vala_player_controller_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
-	PlayerController * self;
-	self = PLAYER_CONTROLLER (object);
-	switch (property_id) {
-		case PLAYER_CONTROLLER_DBUS_NAME:
-		player_controller_set_dbus_name (self, g_value_get_string (value));
-		break;
-		case PLAYER_CONTROLLER_APP_INFO:
-		player_controller_set_app_info (self, g_value_get_object (value));
-		break;
-		case PLAYER_CONTROLLER_MENU_OFFSET:
-		player_controller_set_menu_offset (self, g_value_get_int (value));
-		break;
-		case PLAYER_CONTROLLER_ICON_NAME:
-		player_controller_set_icon_name (self, g_value_get_string (value));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-
diff -Naur indicator-sound-0.8.5.0/src/player-controller.vala indicator-sound-precise/src/player-controller.vala
--- indicator-sound-0.8.5.0/src/player-controller.vala	2012-03-30 10:26:53.000000000 -0700
+++ indicator-sound-precise/src/player-controller.vala	2012-07-26 21:03:55.488143000 -0700
@@ -40,7 +40,7 @@
   }
   
   public int current_state = state.OFFLINE;
-    
+
   public Dbusmenu.Menuitem root_menu;
   public string dbus_name { get; set;}
   public ArrayList<PlayerItem> custom_items;
@@ -49,6 +49,7 @@
   public int menu_offset { get; set;}
   public string icon_name { get; set; }
   public bool? use_playlists;
+  public bool is_preferred { get; private set; }
   private SpecificItemsManager track_specific_mgr;
   private SpecificItemsManager player_specific_mgr;
   
@@ -58,7 +59,8 @@
                           string icon_name,
                           int offset,
                           bool? use_playlists,
-                          state initial_state)
+                          state initial_state,
+                          bool is_preferred)
   {
     this.use_playlists = use_playlists;
     this.root_menu = root;
@@ -68,6 +70,8 @@
     this.custom_items = new ArrayList<PlayerItem>();
     this.current_state = initial_state;
     this.menu_offset = offset;
+    this.is_preferred = is_preferred;
+
     this.construct_widgets();
     this.establish_mpris_connection();
     this.update_layout();
@@ -156,6 +160,11 @@
     }
   }
 
+  public void set_as_preferred (bool val) {
+  	this.is_preferred = val;
+  	this.update_layout();
+  }
+
   public void hibernate()
   {
     update_state(PlayerController.state.OFFLINE);
@@ -175,12 +184,14 @@
       metadata_menuitem.should_collapse (true);
       playlists_menuitem.root_item.property_set_bool (MENUITEM_PROP_VISIBLE,
                                                       false);
-      this.custom_items[widget_order.TRANSPORT].property_set_bool (MENUITEM_PROP_VISIBLE,
-                                                                   this.app_info.get_id() == "rhythmbox.desktop");         
+      this.custom_items[widget_order.TRANSPORT].property_set_bool (MENUITEM_PROP_VISIBLE, is_preferred);        
       return; 
     }
-    metadata_menuitem.should_collapse (!this.custom_items[widget_order.METADATA].populated (MetadataMenuitem.relevant_attributes_for_ui()) );
-    if (this.app_info.get_id() == "rhythmbox.desktop"){
+
+    bool should_collapse = !this.custom_items[widget_order.METADATA].populated (MetadataMenuitem.relevant_attributes_for_ui());
+    metadata_menuitem.should_collapse (should_collapse);
+
+    if (is_preferred){
       TransportMenuitem transport = this.custom_items[widget_order.TRANSPORT] as TransportMenuitem;
       transport.handle_cached_action();
     }
diff -Naur indicator-sound-0.8.5.0/src/player-item.c indicator-sound-precise/src/player-item.c
--- indicator-sound-0.8.5.0/src/player-item.c	2012-03-30 10:32:34.000000000 -0700
+++ indicator-sound-precise/src/player-item.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,598 +0,0 @@
-/* player-item.c generated by valac 0.14.2, the Vala compiler
- * generated from player-item.vala, do not modify */
-
-/*
-Copyright 2010 Canonical Ltd.
-
-Authors:
-    Conor Curran <conor.curran@canonical.com>
-
-This program is free software: you can redistribute it and/or modify it 
-under the terms of the GNU General Public License version 3, as published 
-by the Free Software Foundation.
-
-This program is distributed in the hope that it will be useful, but 
-WITHOUT ANY WARRANTY; without even the implied warranties of 
-MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
-PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along 
-with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libdbusmenu-glib/client.h>
-#include <libdbusmenu-glib/dbusmenu-glib.h>
-#include <libdbusmenu-glib/enum-types.h>
-#include <libdbusmenu-glib/menuitem-proxy.h>
-#include <libdbusmenu-glib/menuitem.h>
-#include <libdbusmenu-glib/server.h>
-#include <libdbusmenu-glib/types.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-
-
-#define TYPE_PLAYER_ITEM (player_item_get_type ())
-#define PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_ITEM, PlayerItem))
-#define PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_ITEM, PlayerItemClass))
-#define IS_PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_ITEM))
-#define IS_PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_ITEM))
-#define PLAYER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_ITEM, PlayerItemClass))
-
-typedef struct _PlayerItem PlayerItem;
-typedef struct _PlayerItemClass PlayerItemClass;
-typedef struct _PlayerItemPrivate PlayerItemPrivate;
-
-#define TYPE_PLAYER_CONTROLLER (player_controller_get_type ())
-#define PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONTROLLER, PlayerController))
-#define PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-#define IS_PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONTROLLER))
-#define IS_PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONTROLLER))
-#define PLAYER_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-
-typedef struct _PlayerController PlayerController;
-typedef struct _PlayerControllerClass PlayerControllerClass;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
-
-#define TYPE_METADATA_MENUITEM (metadata_menuitem_get_type ())
-#define METADATA_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_METADATA_MENUITEM, MetadataMenuitem))
-#define METADATA_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_METADATA_MENUITEM, MetadataMenuitemClass))
-#define IS_METADATA_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_METADATA_MENUITEM))
-#define IS_METADATA_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_METADATA_MENUITEM))
-#define METADATA_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_METADATA_MENUITEM, MetadataMenuitemClass))
-
-typedef struct _MetadataMenuitem MetadataMenuitem;
-typedef struct _MetadataMenuitemClass MetadataMenuitemClass;
-
-struct _PlayerItem {
-	DbusmenuMenuitem parent_instance;
-	PlayerItemPrivate * priv;
-};
-
-struct _PlayerItemClass {
-	DbusmenuMenuitemClass parent_class;
-};
-
-struct _PlayerItemPrivate {
-	PlayerController* _owner;
-	gchar* _item_type;
-};
-
-
-static gpointer player_item_parent_class = NULL;
-
-GType player_item_get_type (void) G_GNUC_CONST;
-GType player_controller_get_type (void) G_GNUC_CONST;
-#define PLAYER_ITEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PLAYER_ITEM, PlayerItemPrivate))
-enum  {
-	PLAYER_ITEM_DUMMY_PROPERTY,
-	PLAYER_ITEM_OWNER,
-	PLAYER_ITEM_ITEM_TYPE
-};
-#define PLAYER_ITEM_EMPTY (-1)
-PlayerItem* player_item_new (const gchar* type);
-PlayerItem* player_item_construct (GType object_type, const gchar* type);
-void player_item_reset (PlayerItem* self, GeeHashSet* attrs);
-void player_item_update (PlayerItem* self, GHashTable* data, GeeHashSet* attributes);
-GType metadata_menuitem_get_type (void) G_GNUC_CONST;
-void metadata_menuitem_fetch_art (MetadataMenuitem* self, const gchar* uri, const gchar* prop);
-gboolean player_item_populated (PlayerItem* self, GeeHashSet* attrs);
-PlayerController* player_item_get_owner (PlayerItem* self);
-static void player_item_set_owner (PlayerItem* self, PlayerController* value);
-const gchar* player_item_get_item_type (PlayerItem* self);
-static void player_item_set_item_type (PlayerItem* self, const gchar* value);
-static GObject * player_item_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
-static void player_item_finalize (GObject* obj);
-static void _vala_player_item_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
-static void _vala_player_item_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static gint _vala_array_length (gpointer array);
-
-
-PlayerItem* player_item_construct (GType object_type, const gchar* type) {
-	PlayerItem * self = NULL;
-	const gchar* _tmp0_;
-	g_return_val_if_fail (type != NULL, NULL);
-	_tmp0_ = type;
-	self = (PlayerItem*) g_object_new (object_type, "item-type", _tmp0_, NULL);
-	return self;
-}
-
-
-PlayerItem* player_item_new (const gchar* type) {
-	return player_item_construct (TYPE_PLAYER_ITEM, type);
-}
-
-
-void player_item_reset (PlayerItem* self, GeeHashSet* attrs) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (attrs != NULL);
-	{
-		GeeHashSet* _tmp0_;
-		GeeIterator* _tmp1_ = NULL;
-		GeeIterator* _s_it;
-		_tmp0_ = attrs;
-		_tmp1_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp0_);
-		_s_it = _tmp1_;
-		while (TRUE) {
-			GeeIterator* _tmp2_;
-			gboolean _tmp3_ = FALSE;
-			GeeIterator* _tmp4_;
-			gpointer _tmp5_ = NULL;
-			gchar* s;
-			const gchar* _tmp6_;
-			_tmp2_ = _s_it;
-			_tmp3_ = gee_iterator_next (_tmp2_);
-			if (!_tmp3_) {
-				break;
-			}
-			_tmp4_ = _s_it;
-			_tmp5_ = gee_iterator_get (_tmp4_);
-			s = (gchar*) _tmp5_;
-			_tmp6_ = s;
-			dbusmenu_menuitem_property_set_int ((DbusmenuMenuitem*) self, _tmp6_, PLAYER_ITEM_EMPTY);
-			_g_free0 (s);
-		}
-		_g_object_unref0 (_s_it);
-	}
-}
-
-
-/**
-   * update()
-   * Base update method for playeritems, takes the attributes and the incoming updates
-   * and attmepts to update the appropriate props on the object. 
-   * Album art is handled separately to deal with remote and local file paths.
-   */
-static gpointer _g_variant_ref0 (gpointer self) {
-	return self ? g_variant_ref (self) : NULL;
-}
-
-
-static gchar* string_strip (const gchar* self) {
-	gchar* result = NULL;
-	gchar* _tmp0_ = NULL;
-	gchar* _result_;
-	const gchar* _tmp1_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = g_strdup (self);
-	_result_ = _tmp0_;
-	_tmp1_ = _result_;
-	g_strstrip (_tmp1_);
-	result = _result_;
-	return result;
-}
-
-
-static gboolean string_contains (const gchar* self, const gchar* needle) {
-	gboolean result = FALSE;
-	const gchar* _tmp0_;
-	gchar* _tmp1_ = NULL;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (needle != NULL, FALSE);
-	_tmp0_ = needle;
-	_tmp1_ = strstr ((gchar*) self, (gchar*) _tmp0_);
-	result = _tmp1_ != NULL;
-	return result;
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-void player_item_update (PlayerItem* self, GHashTable* data, GeeHashSet* attributes) {
-	GHashTable* _tmp0_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (data != NULL);
-	g_return_if_fail (attributes != NULL);
-	_tmp0_ = data;
-	if (_tmp0_ == NULL) {
-		g_warning ("player-item.vala:54: PlayerItem::Update -> The hashtable was null - ju" \
-"st leave it!");
-		return;
-	}
-	{
-		GeeHashSet* _tmp1_;
-		GeeIterator* _tmp2_ = NULL;
-		GeeIterator* _property_it;
-		_tmp1_ = attributes;
-		_tmp2_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp1_);
-		_property_it = _tmp2_;
-		while (TRUE) {
-			GeeIterator* _tmp3_;
-			gboolean _tmp4_ = FALSE;
-			GeeIterator* _tmp5_;
-			gpointer _tmp6_ = NULL;
-			gchar* property;
-			const gchar* _tmp7_;
-			gchar** _tmp8_;
-			gchar** _tmp9_ = NULL;
-			gchar** input_keys;
-			gint input_keys_length1;
-			gint _input_keys_size_;
-			gchar** _tmp10_;
-			gint _tmp10__length1;
-			gchar** _tmp11_;
-			gint _tmp11__length1;
-			gchar** _tmp12_;
-			gint _tmp12__length1;
-			const gchar* _tmp13_;
-			gchar* _tmp14_;
-			gchar* search_key;
-			GHashTable* _tmp15_;
-			const gchar* _tmp16_;
-			gconstpointer _tmp17_ = NULL;
-			GVariant* _tmp18_;
-			GVariant* v;
-			GVariant* _tmp19_;
-			GVariant* _tmp20_;
-			const GVariantType* _tmp21_;
-			gboolean _tmp22_ = FALSE;
-			_tmp3_ = _property_it;
-			_tmp4_ = gee_iterator_next (_tmp3_);
-			if (!_tmp4_) {
-				break;
-			}
-			_tmp5_ = _property_it;
-			_tmp6_ = gee_iterator_get (_tmp5_);
-			property = (gchar*) _tmp6_;
-			_tmp7_ = property;
-			_tmp9_ = _tmp8_ = g_strsplit (_tmp7_, "-", 0);
-			input_keys = _tmp9_;
-			input_keys_length1 = _vala_array_length (_tmp8_);
-			_input_keys_size_ = input_keys_length1;
-			_tmp10_ = input_keys;
-			_tmp10__length1 = input_keys_length1;
-			_tmp11_ = input_keys;
-			_tmp11__length1 = input_keys_length1;
-			_tmp12_ = input_keys;
-			_tmp12__length1 = input_keys_length1;
-			_tmp13_ = (_tmp10_ + (_tmp11__length1 - 1))[0];
-			_tmp14_ = g_strdup (_tmp13_);
-			search_key = _tmp14_;
-			_tmp15_ = data;
-			_tmp16_ = search_key;
-			_tmp17_ = g_hash_table_lookup (_tmp15_, _tmp16_);
-			_tmp18_ = _g_variant_ref0 ((GVariant*) _tmp17_);
-			v = _tmp18_;
-			_tmp19_ = v;
-			if (_tmp19_ == NULL) {
-				_g_variant_unref0 (v);
-				_g_free0 (search_key);
-				input_keys = (_vala_array_free (input_keys, input_keys_length1, (GDestroyNotify) g_free), NULL);
-				_g_free0 (property);
-				continue;
-			}
-			_tmp20_ = v;
-			_tmp21_ = G_VARIANT_TYPE_STRING;
-			_tmp22_ = g_variant_is_of_type (_tmp20_, _tmp21_);
-			if (_tmp22_) {
-				GVariant* _tmp23_;
-				const gchar* _tmp24_ = NULL;
-				gchar* _tmp25_ = NULL;
-				gchar* update;
-				const gchar* _tmp26_;
-				gboolean _tmp27_ = FALSE;
-				const gchar* _tmp32_;
-				const gchar* _tmp33_;
-				_tmp23_ = v;
-				_tmp24_ = g_variant_get_string (_tmp23_, NULL);
-				_tmp25_ = string_strip (_tmp24_);
-				update = _tmp25_;
-				_tmp26_ = property;
-				_tmp27_ = string_contains (_tmp26_, "mpris:artUrl");
-				if (_tmp27_) {
-					MetadataMenuitem* _tmp28_;
-					MetadataMenuitem* metadata;
-					MetadataMenuitem* _tmp29_;
-					const gchar* _tmp30_;
-					const gchar* _tmp31_;
-					_tmp28_ = _g_object_ref0 (IS_METADATA_MENUITEM (self) ? ((MetadataMenuitem*) self) : NULL);
-					metadata = _tmp28_;
-					_tmp29_ = metadata;
-					_tmp30_ = update;
-					_tmp31_ = property;
-					metadata_menuitem_fetch_art (_tmp29_, _tmp30_, _tmp31_);
-					_g_object_unref0 (metadata);
-					_g_free0 (update);
-					_g_variant_unref0 (v);
-					_g_free0 (search_key);
-					input_keys = (_vala_array_free (input_keys, input_keys_length1, (GDestroyNotify) g_free), NULL);
-					_g_free0 (property);
-					continue;
-				}
-				_tmp32_ = property;
-				_tmp33_ = update;
-				dbusmenu_menuitem_property_set ((DbusmenuMenuitem*) self, _tmp32_, _tmp33_);
-				_g_free0 (update);
-			} else {
-				GVariant* _tmp34_;
-				const GVariantType* _tmp35_;
-				gboolean _tmp36_ = FALSE;
-				_tmp34_ = v;
-				_tmp35_ = G_VARIANT_TYPE_INT32;
-				_tmp36_ = g_variant_is_of_type (_tmp34_, _tmp35_);
-				if (_tmp36_) {
-					const gchar* _tmp37_;
-					GVariant* _tmp38_;
-					gint32 _tmp39_ = 0;
-					_tmp37_ = property;
-					_tmp38_ = v;
-					_tmp39_ = g_variant_get_int32 (_tmp38_);
-					dbusmenu_menuitem_property_set_int ((DbusmenuMenuitem*) self, _tmp37_, (gint) _tmp39_);
-				} else {
-					GVariant* _tmp40_;
-					const GVariantType* _tmp41_;
-					gboolean _tmp42_ = FALSE;
-					_tmp40_ = v;
-					_tmp41_ = G_VARIANT_TYPE_INT64;
-					_tmp42_ = g_variant_is_of_type (_tmp40_, _tmp41_);
-					if (_tmp42_) {
-						const gchar* _tmp43_;
-						GVariant* _tmp44_;
-						gint64 _tmp45_ = 0LL;
-						_tmp43_ = property;
-						_tmp44_ = v;
-						_tmp45_ = g_variant_get_int64 (_tmp44_);
-						dbusmenu_menuitem_property_set_int ((DbusmenuMenuitem*) self, _tmp43_, (gint) _tmp45_);
-					} else {
-						GVariant* _tmp46_;
-						const GVariantType* _tmp47_;
-						gboolean _tmp48_ = FALSE;
-						_tmp46_ = v;
-						_tmp47_ = G_VARIANT_TYPE_BOOLEAN;
-						_tmp48_ = g_variant_is_of_type (_tmp46_, _tmp47_);
-						if (_tmp48_) {
-							const gchar* _tmp49_;
-							GVariant* _tmp50_;
-							gboolean _tmp51_ = FALSE;
-							_tmp49_ = property;
-							_tmp50_ = v;
-							_tmp51_ = g_variant_get_boolean (_tmp50_);
-							dbusmenu_menuitem_property_set_bool ((DbusmenuMenuitem*) self, _tmp49_, _tmp51_);
-						}
-					}
-				}
-			}
-			_g_variant_unref0 (v);
-			_g_free0 (search_key);
-			input_keys = (_vala_array_free (input_keys, input_keys_length1, (GDestroyNotify) g_free), NULL);
-			_g_free0 (property);
-		}
-		_g_object_unref0 (_property_it);
-	}
-}
-
-
-gboolean player_item_populated (PlayerItem* self, GeeHashSet* attrs) {
-	gboolean result = FALSE;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (attrs != NULL, FALSE);
-	{
-		GeeHashSet* _tmp0_;
-		GeeIterator* _tmp1_ = NULL;
-		GeeIterator* _prop_it;
-		_tmp0_ = attrs;
-		_tmp1_ = gee_abstract_collection_iterator ((GeeAbstractCollection*) _tmp0_);
-		_prop_it = _tmp1_;
-		while (TRUE) {
-			GeeIterator* _tmp2_;
-			gboolean _tmp3_ = FALSE;
-			GeeIterator* _tmp4_;
-			gpointer _tmp5_ = NULL;
-			gchar* prop;
-			const gchar* _tmp6_;
-			gint _tmp7_ = 0;
-			_tmp2_ = _prop_it;
-			_tmp3_ = gee_iterator_next (_tmp2_);
-			if (!_tmp3_) {
-				break;
-			}
-			_tmp4_ = _prop_it;
-			_tmp5_ = gee_iterator_get (_tmp4_);
-			prop = (gchar*) _tmp5_;
-			_tmp6_ = prop;
-			_tmp7_ = dbusmenu_menuitem_property_get_int ((DbusmenuMenuitem*) self, _tmp6_);
-			if (_tmp7_ != PLAYER_ITEM_EMPTY) {
-				result = TRUE;
-				_g_free0 (prop);
-				_g_object_unref0 (_prop_it);
-				return result;
-			}
-			_g_free0 (prop);
-		}
-		_g_object_unref0 (_prop_it);
-	}
-	result = FALSE;
-	return result;
-}
-
-
-PlayerController* player_item_get_owner (PlayerItem* self) {
-	PlayerController* result;
-	PlayerController* _tmp0_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = self->priv->_owner;
-	result = _tmp0_;
-	return result;
-}
-
-
-static void player_item_set_owner (PlayerItem* self, PlayerController* value) {
-	PlayerController* _tmp0_;
-	PlayerController* _tmp1_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = value;
-	_tmp1_ = _g_object_ref0 (_tmp0_);
-	_g_object_unref0 (self->priv->_owner);
-	self->priv->_owner = _tmp1_;
-	g_object_notify ((GObject *) self, "owner");
-}
-
-
-const gchar* player_item_get_item_type (PlayerItem* self) {
-	const gchar* result;
-	const gchar* _tmp0_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = self->priv->_item_type;
-	result = _tmp0_;
-	return result;
-}
-
-
-static void player_item_set_item_type (PlayerItem* self, const gchar* value) {
-	const gchar* _tmp0_;
-	gchar* _tmp1_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = value;
-	_tmp1_ = g_strdup (_tmp0_);
-	_g_free0 (self->priv->_item_type);
-	self->priv->_item_type = _tmp1_;
-	g_object_notify ((GObject *) self, "item-type");
-}
-
-
-static GObject * player_item_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
-	GObject * obj;
-	GObjectClass * parent_class;
-	PlayerItem * self;
-	const gchar* _tmp0_;
-	parent_class = G_OBJECT_CLASS (player_item_parent_class);
-	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
-	self = PLAYER_ITEM (obj);
-	_tmp0_ = self->priv->_item_type;
-	dbusmenu_menuitem_property_set ((DbusmenuMenuitem*) self, DBUSMENU_MENUITEM_PROP_TYPE, _tmp0_);
-	return obj;
-}
-
-
-static void player_item_class_init (PlayerItemClass * klass) {
-	player_item_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (PlayerItemPrivate));
-	G_OBJECT_CLASS (klass)->get_property = _vala_player_item_get_property;
-	G_OBJECT_CLASS (klass)->set_property = _vala_player_item_set_property;
-	G_OBJECT_CLASS (klass)->constructor = player_item_constructor;
-	G_OBJECT_CLASS (klass)->finalize = player_item_finalize;
-	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_ITEM_OWNER, g_param_spec_object ("owner", "owner", "owner", TYPE_PLAYER_CONTROLLER, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
-	g_object_class_install_property (G_OBJECT_CLASS (klass), PLAYER_ITEM_ITEM_TYPE, g_param_spec_string ("item-type", "item-type", "item-type", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
-}
-
-
-static void player_item_instance_init (PlayerItem * self) {
-	self->priv = PLAYER_ITEM_GET_PRIVATE (self);
-}
-
-
-static void player_item_finalize (GObject* obj) {
-	PlayerItem * self;
-	self = PLAYER_ITEM (obj);
-	_g_object_unref0 (self->priv->_owner);
-	_g_free0 (self->priv->_item_type);
-	G_OBJECT_CLASS (player_item_parent_class)->finalize (obj);
-}
-
-
-GType player_item_get_type (void) {
-	static volatile gsize player_item_type_id__volatile = 0;
-	if (g_once_init_enter (&player_item_type_id__volatile)) {
-		static const GTypeInfo g_define_type_info = { sizeof (PlayerItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) player_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlayerItem), 0, (GInstanceInitFunc) player_item_instance_init, NULL };
-		GType player_item_type_id;
-		player_item_type_id = g_type_register_static (dbusmenu_menuitem_get_type (), "PlayerItem", &g_define_type_info, 0);
-		g_once_init_leave (&player_item_type_id__volatile, player_item_type_id);
-	}
-	return player_item_type_id__volatile;
-}
-
-
-static void _vala_player_item_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
-	PlayerItem * self;
-	self = PLAYER_ITEM (object);
-	switch (property_id) {
-		case PLAYER_ITEM_OWNER:
-		g_value_set_object (value, player_item_get_owner (self));
-		break;
-		case PLAYER_ITEM_ITEM_TYPE:
-		g_value_set_string (value, player_item_get_item_type (self));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void _vala_player_item_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
-	PlayerItem * self;
-	self = PLAYER_ITEM (object);
-	switch (property_id) {
-		case PLAYER_ITEM_OWNER:
-		player_item_set_owner (self, g_value_get_object (value));
-		break;
-		case PLAYER_ITEM_ITEM_TYPE:
-		player_item_set_item_type (self, g_value_get_string (value));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-static gint _vala_array_length (gpointer array) {
-	int length;
-	length = 0;
-	if (array) {
-		while (((gpointer*) array)[length]) {
-			length++;
-		}
-	}
-	return length;
-}
-
-
-
diff -Naur indicator-sound-0.8.5.0/src/playlists-menu-item.c indicator-sound-precise/src/playlists-menu-item.c
--- indicator-sound-0.8.5.0/src/playlists-menu-item.c	2012-03-30 10:32:34.000000000 -0700
+++ indicator-sound-precise/src/playlists-menu-item.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,873 +0,0 @@
-/* playlists-menu-item.c generated by valac 0.14.2, the Vala compiler
- * generated from playlists-menu-item.vala, do not modify */
-
-/*
-Copyright 2010 Canonical Ltd.
-
-Authors:
-    Conor Curran <conor.curran@canonical.com>
-
-This program is free software: you can redistribute it and/or modify it 
-under the terms of the GNU General Public License version 3, as published 
-by the Free Software Foundation.
-
-This program is distributed in the hope that it will be useful, but 
-WITHOUT ANY WARRANTY; without even the implied warranties of 
-MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
-PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along 
-with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libdbusmenu-glib/client.h>
-#include <libdbusmenu-glib/dbusmenu-glib.h>
-#include <libdbusmenu-glib/enum-types.h>
-#include <libdbusmenu-glib/menuitem-proxy.h>
-#include <libdbusmenu-glib/menuitem.h>
-#include <libdbusmenu-glib/server.h>
-#include <libdbusmenu-glib/types.h>
-#include <gee.h>
-#include <common-defs.h>
-#include <stdlib.h>
-#include <string.h>
-#include <glib/gi18n-lib.h>
-
-
-#define TYPE_PLAYER_ITEM (player_item_get_type ())
-#define PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_ITEM, PlayerItem))
-#define PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_ITEM, PlayerItemClass))
-#define IS_PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_ITEM))
-#define IS_PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_ITEM))
-#define PLAYER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_ITEM, PlayerItemClass))
-
-typedef struct _PlayerItem PlayerItem;
-typedef struct _PlayerItemClass PlayerItemClass;
-typedef struct _PlayerItemPrivate PlayerItemPrivate;
-
-#define TYPE_PLAYLISTS_MENUITEM (playlists_menuitem_get_type ())
-#define PLAYLISTS_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYLISTS_MENUITEM, PlaylistsMenuitem))
-#define PLAYLISTS_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYLISTS_MENUITEM, PlaylistsMenuitemClass))
-#define IS_PLAYLISTS_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYLISTS_MENUITEM))
-#define IS_PLAYLISTS_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYLISTS_MENUITEM))
-#define PLAYLISTS_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYLISTS_MENUITEM, PlaylistsMenuitemClass))
-
-typedef struct _PlaylistsMenuitem PlaylistsMenuitem;
-typedef struct _PlaylistsMenuitemClass PlaylistsMenuitemClass;
-typedef struct _PlaylistsMenuitemPrivate PlaylistsMenuitemPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define TYPE_PLAYER_CONTROLLER (player_controller_get_type ())
-#define PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONTROLLER, PlayerController))
-#define PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-#define IS_PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONTROLLER))
-#define IS_PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONTROLLER))
-#define PLAYER_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-
-typedef struct _PlayerController PlayerController;
-typedef struct _PlayerControllerClass PlayerControllerClass;
-
-#define TYPE_PLAYLIST_DETAILS (playlist_details_get_type ())
-typedef struct _PlaylistDetails PlaylistDetails;
-typedef struct _Block2Data Block2Data;
-#define _g_free0(var) (var = (g_free (var), NULL))
-typedef struct _PlayerControllerPrivate PlayerControllerPrivate;
-
-#define TYPE_MPRIS2_CONTROLLER (mpris2_controller_get_type ())
-#define MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2Controller))
-#define MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
-#define IS_MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS2_CONTROLLER))
-#define IS_MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS2_CONTROLLER))
-#define MPRIS2_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
-
-typedef struct _Mpris2Controller Mpris2Controller;
-typedef struct _Mpris2ControllerClass Mpris2ControllerClass;
-
-struct _PlayerItem {
-	DbusmenuMenuitem parent_instance;
-	PlayerItemPrivate * priv;
-};
-
-struct _PlayerItemClass {
-	DbusmenuMenuitemClass parent_class;
-};
-
-struct _PlaylistsMenuitem {
-	PlayerItem parent_instance;
-	PlaylistsMenuitemPrivate * priv;
-	DbusmenuMenuitem* root_item;
-};
-
-struct _PlaylistsMenuitemClass {
-	PlayerItemClass parent_class;
-};
-
-struct _PlaylistsMenuitemPrivate {
-	GeeHashMap* current_playlists;
-};
-
-struct _PlaylistDetails {
-	char* path;
-	gchar* name;
-	gchar* icon_path;
-};
-
-struct _Block2Data {
-	int _ref_count_;
-	PlaylistsMenuitem * self;
-	DbusmenuMenuitem* menuitem;
-};
-
-struct _PlayerController {
-	GObject parent_instance;
-	PlayerControllerPrivate * priv;
-	gint current_state;
-	DbusmenuMenuitem* root_menu;
-	GeeArrayList* custom_items;
-	Mpris2Controller* mpris_bridge;
-	gboolean* use_playlists;
-};
-
-struct _PlayerControllerClass {
-	GObjectClass parent_class;
-};
-
-
-static gpointer playlists_menuitem_parent_class = NULL;
-
-GType player_item_get_type (void) G_GNUC_CONST;
-GType playlists_menuitem_get_type (void) G_GNUC_CONST;
-#define PLAYLISTS_MENUITEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PLAYLISTS_MENUITEM, PlaylistsMenuitemPrivate))
-enum  {
-	PLAYLISTS_MENUITEM_DUMMY_PROPERTY
-};
-GType player_controller_get_type (void) G_GNUC_CONST;
-PlaylistsMenuitem* playlists_menuitem_new (PlayerController* parent);
-PlaylistsMenuitem* playlists_menuitem_construct (GType object_type, PlayerController* parent);
-GType playlist_details_get_type (void) G_GNUC_CONST;
-PlaylistDetails* playlist_details_dup (const PlaylistDetails* self);
-void playlist_details_free (PlaylistDetails* self);
-void playlist_details_copy (const PlaylistDetails* self, PlaylistDetails* dest);
-void playlist_details_destroy (PlaylistDetails* self);
-void playlists_menuitem_update (PlaylistsMenuitem* self, PlaylistDetails* playlists, int playlists_length1);
-static Block2Data* block2_data_ref (Block2Data* _data2_);
-static void block2_data_unref (Block2Data* _data2_);
-static gboolean playlists_menuitem_already_observed (PlaylistsMenuitem* self, PlaylistDetails* new_detail);
-static gboolean playlists_menuitem_is_video_related (PlaylistsMenuitem* self, PlaylistDetails* new_detail);
-static gchar* playlists_menuitem_truncate_item_label_if_needs_be (PlaylistsMenuitem* self, const gchar* item_label);
-static void ____lambda1_ (Block2Data* _data2_);
-static void playlists_menuitem_submenu_item_activated (PlaylistsMenuitem* self, gint menu_item_id);
-static void _____lambda1__dbusmenu_menuitem_item_activated (DbusmenuMenuitem* _sender, guint object, gpointer self);
-void playlists_menuitem_update_individual_playlist (PlaylistsMenuitem* self, PlaylistDetails* new_detail);
-void playlists_menuitem_active_playlist_update (PlaylistsMenuitem* self, PlaylistDetails* detail);
-PlayerController* player_item_get_owner (PlayerItem* self);
-GType mpris2_controller_get_type (void) G_GNUC_CONST;
-void mpris2_controller_activate_playlist (Mpris2Controller* self, const char* path);
-GeeHashSet* playlists_menuitem_attributes_format (void);
-static GObject * playlists_menuitem_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
-static void playlists_menuitem_finalize (GObject* obj);
-
-
-PlaylistsMenuitem* playlists_menuitem_construct (GType object_type, PlayerController* parent) {
-	PlaylistsMenuitem * self = NULL;
-	PlayerController* _tmp0_;
-	g_return_val_if_fail (parent != NULL, NULL);
-	_tmp0_ = parent;
-	self = (PlaylistsMenuitem*) g_object_new (object_type, "item-type", DBUSMENU_PLAYLISTS_MENUITEM_TYPE, "owner", _tmp0_, NULL);
-	return self;
-}
-
-
-PlaylistsMenuitem* playlists_menuitem_new (PlayerController* parent) {
-	return playlists_menuitem_construct (TYPE_PLAYLISTS_MENUITEM, parent);
-}
-
-
-static Block2Data* block2_data_ref (Block2Data* _data2_) {
-	g_atomic_int_inc (&_data2_->_ref_count_);
-	return _data2_;
-}
-
-
-static void block2_data_unref (Block2Data* _data2_) {
-	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
-		_g_object_unref0 (_data2_->self);
-		_g_object_unref0 (_data2_->menuitem);
-		g_slice_free (Block2Data, _data2_);
-	}
-}
-
-
-static void ____lambda1_ (Block2Data* _data2_) {
-	PlaylistsMenuitem * self;
-	DbusmenuMenuitem* _tmp0_;
-	gint _tmp1_;
-	gint _tmp2_;
-	self = _data2_->self;
-	_tmp0_ = _data2_->menuitem;
-	_tmp1_ = dbusmenu_menuitem_get_id (_tmp0_);
-	_tmp2_ = _tmp1_;
-	playlists_menuitem_submenu_item_activated (self, _tmp2_);
-}
-
-
-static void _____lambda1__dbusmenu_menuitem_item_activated (DbusmenuMenuitem* _sender, guint object, gpointer self) {
-	____lambda1_ (self);
-}
-
-
-void playlists_menuitem_update (PlaylistsMenuitem* self, PlaylistDetails* playlists, int playlists_length1) {
-	PlaylistDetails* _tmp0_;
-	gint _tmp0__length1;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = playlists;
-	_tmp0__length1 = playlists_length1;
-	{
-		PlaylistDetails* detail_collection = NULL;
-		gint detail_collection_length1 = 0;
-		gint _detail_collection_size_ = 0;
-		gint detail_it = 0;
-		detail_collection = _tmp0_;
-		detail_collection_length1 = _tmp0__length1;
-		for (detail_it = 0; detail_it < _tmp0__length1; detail_it = detail_it + 1) {
-			PlaylistDetails _tmp1_ = {0};
-			PlaylistDetails detail = {0};
-			playlist_details_copy (&detail_collection[detail_it], &_tmp1_);
-			detail = _tmp1_;
-			{
-				Block2Data* _data2_;
-				gboolean _tmp2_ = FALSE;
-				PlaylistDetails _tmp3_;
-				gboolean _tmp4_ = FALSE;
-				gboolean _tmp7_;
-				DbusmenuMenuitem* _tmp8_;
-				DbusmenuMenuitem* _tmp9_;
-				PlaylistDetails _tmp10_;
-				const gchar* _tmp11_;
-				gchar* _tmp12_ = NULL;
-				gchar* _tmp13_;
-				DbusmenuMenuitem* _tmp14_;
-				DbusmenuMenuitem* _tmp15_;
-				PlaylistDetails _tmp16_;
-				const char* _tmp17_;
-				DbusmenuMenuitem* _tmp18_;
-				DbusmenuMenuitem* _tmp19_;
-				DbusmenuMenuitem* _tmp20_;
-				GeeHashMap* _tmp21_;
-				DbusmenuMenuitem* _tmp22_;
-				gint _tmp23_;
-				gint _tmp24_;
-				DbusmenuMenuitem* _tmp25_;
-				DbusmenuMenuitem* _tmp26_;
-				DbusmenuMenuitem* _tmp27_;
-				PlaylistDetails _tmp28_;
-				const gchar* _tmp29_;
-				_data2_ = g_slice_new0 (Block2Data);
-				_data2_->_ref_count_ = 1;
-				_data2_->self = g_object_ref (self);
-				_tmp3_ = detail;
-				_tmp4_ = playlists_menuitem_already_observed (self, &_tmp3_);
-				if (_tmp4_) {
-					_tmp2_ = TRUE;
-				} else {
-					PlaylistDetails _tmp5_;
-					gboolean _tmp6_ = FALSE;
-					_tmp5_ = detail;
-					_tmp6_ = playlists_menuitem_is_video_related (self, &_tmp5_);
-					_tmp2_ = _tmp6_;
-				}
-				_tmp7_ = _tmp2_;
-				if (_tmp7_) {
-					playlist_details_destroy (&detail);
-					block2_data_unref (_data2_);
-					_data2_ = NULL;
-					continue;
-				}
-				_tmp8_ = dbusmenu_menuitem_new ();
-				_data2_->menuitem = _tmp8_;
-				_tmp9_ = _data2_->menuitem;
-				_tmp10_ = detail;
-				_tmp11_ = _tmp10_.name;
-				_tmp12_ = playlists_menuitem_truncate_item_label_if_needs_be (self, _tmp11_);
-				_tmp13_ = _tmp12_;
-				dbusmenu_menuitem_property_set (_tmp9_, DBUSMENU_MENUITEM_PROP_LABEL, _tmp13_);
-				_g_free0 (_tmp13_);
-				_tmp14_ = _data2_->menuitem;
-				dbusmenu_menuitem_property_set (_tmp14_, DBUSMENU_MENUITEM_PROP_ICON_NAME, "playlist-symbolic");
-				_tmp15_ = _data2_->menuitem;
-				_tmp16_ = detail;
-				_tmp17_ = _tmp16_.path;
-				dbusmenu_menuitem_property_set (_tmp15_, DBUSMENU_PLAYLIST_MENUITEM_PATH, (const gchar*) _tmp17_);
-				_tmp18_ = _data2_->menuitem;
-				dbusmenu_menuitem_property_set_bool (_tmp18_, DBUSMENU_MENUITEM_PROP_VISIBLE, TRUE);
-				_tmp19_ = _data2_->menuitem;
-				dbusmenu_menuitem_property_set_bool (_tmp19_, DBUSMENU_MENUITEM_PROP_ENABLED, TRUE);
-				_tmp20_ = _data2_->menuitem;
-				g_signal_connect_data (_tmp20_, "item-activated", (GCallback) _____lambda1__dbusmenu_menuitem_item_activated, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
-				_tmp21_ = self->priv->current_playlists;
-				_tmp22_ = _data2_->menuitem;
-				_tmp23_ = dbusmenu_menuitem_get_id (_tmp22_);
-				_tmp24_ = _tmp23_;
-				_tmp25_ = _data2_->menuitem;
-				gee_abstract_map_set ((GeeAbstractMap*) _tmp21_, GINT_TO_POINTER (_tmp24_), _tmp25_);
-				_tmp26_ = self->root_item;
-				_tmp27_ = _data2_->menuitem;
-				dbusmenu_menuitem_child_append (_tmp26_, _tmp27_);
-				_tmp28_ = detail;
-				_tmp29_ = _tmp28_.name;
-				g_debug ("playlists-menu-item.vala:66: populating valid playlists %s", _tmp29_);
-				playlist_details_destroy (&detail);
-				block2_data_unref (_data2_);
-				_data2_ = NULL;
-			}
-		}
-	}
-	{
-		GeeHashMap* _tmp30_;
-		GeeCollection* _tmp31_;
-		GeeCollection* _tmp32_;
-		GeeCollection* _tmp33_;
-		GeeIterator* _tmp34_ = NULL;
-		GeeIterator* _tmp35_;
-		GeeIterator* _item_it;
-		_tmp30_ = self->priv->current_playlists;
-		_tmp31_ = gee_abstract_map_get_values ((GeeMap*) _tmp30_);
-		_tmp32_ = _tmp31_;
-		_tmp33_ = _tmp32_;
-		_tmp34_ = gee_iterable_iterator ((GeeIterable*) _tmp33_);
-		_tmp35_ = _tmp34_;
-		_g_object_unref0 (_tmp33_);
-		_item_it = _tmp35_;
-		while (TRUE) {
-			GeeIterator* _tmp36_;
-			gboolean _tmp37_ = FALSE;
-			GeeIterator* _tmp38_;
-			gpointer _tmp39_ = NULL;
-			DbusmenuMenuitem* item;
-			gboolean within;
-			PlaylistDetails* _tmp40_;
-			gint _tmp40__length1;
-			gboolean _tmp46_;
-			_tmp36_ = _item_it;
-			_tmp37_ = gee_iterator_next (_tmp36_);
-			if (!_tmp37_) {
-				break;
-			}
-			_tmp38_ = _item_it;
-			_tmp39_ = gee_iterator_get (_tmp38_);
-			item = (DbusmenuMenuitem*) _tmp39_;
-			within = FALSE;
-			_tmp40_ = playlists;
-			_tmp40__length1 = playlists_length1;
-			{
-				PlaylistDetails* detail_collection = NULL;
-				gint detail_collection_length1 = 0;
-				gint _detail_collection_size_ = 0;
-				gint detail_it = 0;
-				detail_collection = _tmp40_;
-				detail_collection_length1 = _tmp40__length1;
-				for (detail_it = 0; detail_it < _tmp40__length1; detail_it = detail_it + 1) {
-					PlaylistDetails _tmp41_ = {0};
-					PlaylistDetails detail = {0};
-					playlist_details_copy (&detail_collection[detail_it], &_tmp41_);
-					detail = _tmp41_;
-					{
-						PlaylistDetails _tmp42_;
-						const char* _tmp43_;
-						DbusmenuMenuitem* _tmp44_;
-						const gchar* _tmp45_ = NULL;
-						_tmp42_ = detail;
-						_tmp43_ = _tmp42_.path;
-						_tmp44_ = item;
-						_tmp45_ = dbusmenu_menuitem_property_get (_tmp44_, DBUSMENU_PLAYLIST_MENUITEM_PATH);
-						if (g_strcmp0 (_tmp43_, _tmp45_) == 0) {
-							within = TRUE;
-							playlist_details_destroy (&detail);
-							break;
-						}
-						playlist_details_destroy (&detail);
-					}
-				}
-			}
-			_tmp46_ = within;
-			if (_tmp46_ == FALSE) {
-				DbusmenuMenuitem* _tmp47_;
-				const gchar* _tmp48_ = NULL;
-				DbusmenuMenuitem* _tmp49_;
-				const gchar* _tmp50_ = NULL;
-				DbusmenuMenuitem* _tmp53_;
-				DbusmenuMenuitem* _tmp54_;
-				_tmp47_ = self->root_item;
-				_tmp48_ = dbusmenu_menuitem_property_get (_tmp47_, DBUSMENU_PLAYLIST_MENUITEM_PATH);
-				_tmp49_ = item;
-				_tmp50_ = dbusmenu_menuitem_property_get (_tmp49_, DBUSMENU_PLAYLIST_MENUITEM_PATH);
-				if (g_strcmp0 (_tmp48_, _tmp50_) == 0) {
-					DbusmenuMenuitem* _tmp51_;
-					const gchar* _tmp52_ = NULL;
-					_tmp51_ = self->root_item;
-					_tmp52_ = _ ("Choose Playlist");
-					dbusmenu_menuitem_property_set (_tmp51_, DBUSMENU_MENUITEM_PROP_LABEL, _tmp52_);
-				}
-				_tmp53_ = self->root_item;
-				_tmp54_ = item;
-				dbusmenu_menuitem_child_delete (_tmp53_, _tmp54_);
-			}
-			_g_object_unref0 (item);
-		}
-		_g_object_unref0 (_item_it);
-	}
-}
-
-
-void playlists_menuitem_update_individual_playlist (PlaylistsMenuitem* self, PlaylistDetails* new_detail) {
-	DbusmenuMenuitem* _tmp19_;
-	const gchar* _tmp20_ = NULL;
-	PlaylistDetails _tmp21_;
-	const char* _tmp22_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (new_detail != NULL);
-	{
-		GeeHashMap* _tmp0_;
-		GeeCollection* _tmp1_;
-		GeeCollection* _tmp2_;
-		GeeCollection* _tmp3_;
-		GeeIterator* _tmp4_ = NULL;
-		GeeIterator* _tmp5_;
-		GeeIterator* _item_it;
-		_tmp0_ = self->priv->current_playlists;
-		_tmp1_ = gee_abstract_map_get_values ((GeeMap*) _tmp0_);
-		_tmp2_ = _tmp1_;
-		_tmp3_ = _tmp2_;
-		_tmp4_ = gee_iterable_iterator ((GeeIterable*) _tmp3_);
-		_tmp5_ = _tmp4_;
-		_g_object_unref0 (_tmp3_);
-		_item_it = _tmp5_;
-		while (TRUE) {
-			GeeIterator* _tmp6_;
-			gboolean _tmp7_ = FALSE;
-			GeeIterator* _tmp8_;
-			gpointer _tmp9_ = NULL;
-			DbusmenuMenuitem* item;
-			PlaylistDetails _tmp10_;
-			const char* _tmp11_;
-			DbusmenuMenuitem* _tmp12_;
-			const gchar* _tmp13_ = NULL;
-			_tmp6_ = _item_it;
-			_tmp7_ = gee_iterator_next (_tmp6_);
-			if (!_tmp7_) {
-				break;
-			}
-			_tmp8_ = _item_it;
-			_tmp9_ = gee_iterator_get (_tmp8_);
-			item = (DbusmenuMenuitem*) _tmp9_;
-			_tmp10_ = *new_detail;
-			_tmp11_ = _tmp10_.path;
-			_tmp12_ = item;
-			_tmp13_ = dbusmenu_menuitem_property_get (_tmp12_, DBUSMENU_PLAYLIST_MENUITEM_PATH);
-			if (g_strcmp0 (_tmp11_, _tmp13_) == 0) {
-				DbusmenuMenuitem* _tmp14_;
-				PlaylistDetails _tmp15_;
-				const gchar* _tmp16_;
-				gchar* _tmp17_ = NULL;
-				gchar* _tmp18_;
-				_tmp14_ = item;
-				_tmp15_ = *new_detail;
-				_tmp16_ = _tmp15_.name;
-				_tmp17_ = playlists_menuitem_truncate_item_label_if_needs_be (self, _tmp16_);
-				_tmp18_ = _tmp17_;
-				dbusmenu_menuitem_property_set (_tmp14_, DBUSMENU_MENUITEM_PROP_LABEL, _tmp18_);
-				_g_free0 (_tmp18_);
-			}
-			_g_object_unref0 (item);
-		}
-		_g_object_unref0 (_item_it);
-	}
-	_tmp19_ = self->root_item;
-	_tmp20_ = dbusmenu_menuitem_property_get (_tmp19_, DBUSMENU_PLAYLIST_MENUITEM_PATH);
-	_tmp21_ = *new_detail;
-	_tmp22_ = _tmp21_.path;
-	if (g_strcmp0 (_tmp20_, _tmp22_) == 0) {
-		DbusmenuMenuitem* _tmp23_;
-		PlaylistDetails _tmp24_;
-		const gchar* _tmp25_;
-		gchar* _tmp26_ = NULL;
-		gchar* _tmp27_;
-		_tmp23_ = self->root_item;
-		_tmp24_ = *new_detail;
-		_tmp25_ = _tmp24_.name;
-		_tmp26_ = playlists_menuitem_truncate_item_label_if_needs_be (self, _tmp25_);
-		_tmp27_ = _tmp26_;
-		dbusmenu_menuitem_property_set (_tmp23_, DBUSMENU_MENUITEM_PROP_LABEL, _tmp27_);
-		_g_free0 (_tmp27_);
-	}
-}
-
-
-static gboolean playlists_menuitem_already_observed (PlaylistsMenuitem* self, PlaylistDetails* new_detail) {
-	gboolean result = FALSE;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (new_detail != NULL, FALSE);
-	{
-		GeeHashMap* _tmp0_;
-		GeeCollection* _tmp1_;
-		GeeCollection* _tmp2_;
-		GeeCollection* _tmp3_;
-		GeeIterator* _tmp4_ = NULL;
-		GeeIterator* _tmp5_;
-		GeeIterator* _item_it;
-		_tmp0_ = self->priv->current_playlists;
-		_tmp1_ = gee_abstract_map_get_values ((GeeMap*) _tmp0_);
-		_tmp2_ = _tmp1_;
-		_tmp3_ = _tmp2_;
-		_tmp4_ = gee_iterable_iterator ((GeeIterable*) _tmp3_);
-		_tmp5_ = _tmp4_;
-		_g_object_unref0 (_tmp3_);
-		_item_it = _tmp5_;
-		while (TRUE) {
-			GeeIterator* _tmp6_;
-			gboolean _tmp7_ = FALSE;
-			GeeIterator* _tmp8_;
-			gpointer _tmp9_ = NULL;
-			DbusmenuMenuitem* item;
-			DbusmenuMenuitem* _tmp10_;
-			const gchar* _tmp11_ = NULL;
-			gchar* _tmp12_;
-			gchar* path;
-			PlaylistDetails _tmp13_;
-			const char* _tmp14_;
-			const gchar* _tmp15_;
-			_tmp6_ = _item_it;
-			_tmp7_ = gee_iterator_next (_tmp6_);
-			if (!_tmp7_) {
-				break;
-			}
-			_tmp8_ = _item_it;
-			_tmp9_ = gee_iterator_get (_tmp8_);
-			item = (DbusmenuMenuitem*) _tmp9_;
-			_tmp10_ = item;
-			_tmp11_ = dbusmenu_menuitem_property_get (_tmp10_, DBUSMENU_PLAYLIST_MENUITEM_PATH);
-			_tmp12_ = g_strdup (_tmp11_);
-			path = _tmp12_;
-			_tmp13_ = *new_detail;
-			_tmp14_ = _tmp13_.path;
-			_tmp15_ = path;
-			if (g_strcmp0 (_tmp14_, _tmp15_) == 0) {
-				result = TRUE;
-				_g_free0 (path);
-				_g_object_unref0 (item);
-				_g_object_unref0 (_item_it);
-				return result;
-			}
-			_g_free0 (path);
-			_g_object_unref0 (item);
-		}
-		_g_object_unref0 (_item_it);
-	}
-	result = FALSE;
-	return result;
-}
-
-
-static gboolean string_contains (const gchar* self, const gchar* needle) {
-	gboolean result = FALSE;
-	const gchar* _tmp0_;
-	gchar* _tmp1_ = NULL;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (needle != NULL, FALSE);
-	_tmp0_ = needle;
-	_tmp1_ = strstr ((gchar*) self, (gchar*) _tmp0_);
-	result = _tmp1_ != NULL;
-	return result;
-}
-
-
-static gboolean playlists_menuitem_is_video_related (PlaylistsMenuitem* self, PlaylistDetails* new_detail) {
-	gboolean result = FALSE;
-	PlaylistDetails _tmp0_;
-	const char* _tmp1_;
-	gchar* _tmp2_;
-	gchar* location;
-	const gchar* _tmp3_;
-	gboolean _tmp4_ = FALSE;
-	g_return_val_if_fail (self != NULL, FALSE);
-	g_return_val_if_fail (new_detail != NULL, FALSE);
-	_tmp0_ = *new_detail;
-	_tmp1_ = _tmp0_.path;
-	_tmp2_ = g_strdup ((const gchar*) _tmp1_);
-	location = _tmp2_;
-	_tmp3_ = location;
-	_tmp4_ = string_contains (_tmp3_, "/VideoLibrarySource/");
-	if (_tmp4_) {
-		result = TRUE;
-		_g_free0 (location);
-		return result;
-	}
-	result = FALSE;
-	_g_free0 (location);
-	return result;
-}
-
-
-void playlists_menuitem_active_playlist_update (PlaylistsMenuitem* self, PlaylistDetails* detail) {
-	PlaylistDetails _tmp0_;
-	const gchar* _tmp1_;
-	gchar* _tmp2_;
-	gchar* update;
-	const gchar* _tmp3_;
-	DbusmenuMenuitem* _tmp6_;
-	const gchar* _tmp7_;
-	gchar* _tmp8_ = NULL;
-	gchar* _tmp9_;
-	DbusmenuMenuitem* _tmp10_;
-	PlaylistDetails _tmp11_;
-	const char* _tmp12_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (detail != NULL);
-	_tmp0_ = *detail;
-	_tmp1_ = _tmp0_.name;
-	_tmp2_ = g_strdup (_tmp1_);
-	update = _tmp2_;
-	_tmp3_ = update;
-	if (g_strcmp0 (_tmp3_, "") == 0) {
-		const gchar* _tmp4_ = NULL;
-		gchar* _tmp5_;
-		_tmp4_ = _ ("Choose Playlist");
-		_tmp5_ = g_strdup (_tmp4_);
-		_g_free0 (update);
-		update = _tmp5_;
-	}
-	_tmp6_ = self->root_item;
-	_tmp7_ = update;
-	_tmp8_ = playlists_menuitem_truncate_item_label_if_needs_be (self, _tmp7_);
-	_tmp9_ = _tmp8_;
-	dbusmenu_menuitem_property_set (_tmp6_, DBUSMENU_MENUITEM_PROP_LABEL, _tmp9_);
-	_g_free0 (_tmp9_);
-	_tmp10_ = self->root_item;
-	_tmp11_ = *detail;
-	_tmp12_ = _tmp11_.path;
-	dbusmenu_menuitem_property_set (_tmp10_, DBUSMENU_PLAYLIST_MENUITEM_PATH, (const gchar*) _tmp12_);
-	_g_free0 (update);
-}
-
-
-static void playlists_menuitem_submenu_item_activated (PlaylistsMenuitem* self, gint menu_item_id) {
-	GeeHashMap* _tmp0_;
-	gint _tmp1_;
-	gboolean _tmp2_ = FALSE;
-	PlayerController* _tmp4_;
-	PlayerController* _tmp5_;
-	Mpris2Controller* _tmp6_;
-	GeeHashMap* _tmp7_;
-	gint _tmp8_;
-	gpointer _tmp9_ = NULL;
-	DbusmenuMenuitem* _tmp10_;
-	const gchar* _tmp11_ = NULL;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = self->priv->current_playlists;
-	_tmp1_ = menu_item_id;
-	_tmp2_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp0_, GINT_TO_POINTER (_tmp1_));
-	if (!_tmp2_) {
-		gint _tmp3_;
-		_tmp3_ = menu_item_id;
-		g_warning ("playlists-menu-item.vala:129: item %i was activated but we don't have " \
-"a corresponding playlist", _tmp3_);
-		return;
-	}
-	_tmp4_ = player_item_get_owner ((PlayerItem*) self);
-	_tmp5_ = _tmp4_;
-	_tmp6_ = _tmp5_->mpris_bridge;
-	_tmp7_ = self->priv->current_playlists;
-	_tmp8_ = menu_item_id;
-	_tmp9_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp7_, GINT_TO_POINTER (_tmp8_));
-	_tmp10_ = (DbusmenuMenuitem*) _tmp9_;
-	_tmp11_ = dbusmenu_menuitem_property_get (_tmp10_, DBUSMENU_PLAYLIST_MENUITEM_PATH);
-	mpris2_controller_activate_playlist (_tmp6_, (const char*) _tmp11_);
-	_g_object_unref0 (_tmp10_);
-}
-
-
-static gchar* string_slice (const gchar* self, glong start, glong end) {
-	gchar* result = NULL;
-	gint _tmp0_;
-	gint _tmp1_;
-	glong string_length;
-	glong _tmp2_;
-	glong _tmp5_;
-	gboolean _tmp8_ = FALSE;
-	glong _tmp9_;
-	gboolean _tmp12_;
-	gboolean _tmp13_ = FALSE;
-	glong _tmp14_;
-	gboolean _tmp17_;
-	glong _tmp18_;
-	glong _tmp19_;
-	glong _tmp20_;
-	glong _tmp21_;
-	glong _tmp22_;
-	gchar* _tmp23_ = NULL;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = strlen (self);
-	_tmp1_ = _tmp0_;
-	string_length = (glong) _tmp1_;
-	_tmp2_ = start;
-	if (_tmp2_ < ((glong) 0)) {
-		glong _tmp3_;
-		glong _tmp4_;
-		_tmp3_ = string_length;
-		_tmp4_ = start;
-		start = _tmp3_ + _tmp4_;
-	}
-	_tmp5_ = end;
-	if (_tmp5_ < ((glong) 0)) {
-		glong _tmp6_;
-		glong _tmp7_;
-		_tmp6_ = string_length;
-		_tmp7_ = end;
-		end = _tmp6_ + _tmp7_;
-	}
-	_tmp9_ = start;
-	if (_tmp9_ >= ((glong) 0)) {
-		glong _tmp10_;
-		glong _tmp11_;
-		_tmp10_ = start;
-		_tmp11_ = string_length;
-		_tmp8_ = _tmp10_ <= _tmp11_;
-	} else {
-		_tmp8_ = FALSE;
-	}
-	_tmp12_ = _tmp8_;
-	g_return_val_if_fail (_tmp12_, NULL);
-	_tmp14_ = end;
-	if (_tmp14_ >= ((glong) 0)) {
-		glong _tmp15_;
-		glong _tmp16_;
-		_tmp15_ = end;
-		_tmp16_ = string_length;
-		_tmp13_ = _tmp15_ <= _tmp16_;
-	} else {
-		_tmp13_ = FALSE;
-	}
-	_tmp17_ = _tmp13_;
-	g_return_val_if_fail (_tmp17_, NULL);
-	_tmp18_ = start;
-	_tmp19_ = end;
-	g_return_val_if_fail (_tmp18_ <= _tmp19_, NULL);
-	_tmp20_ = start;
-	_tmp21_ = end;
-	_tmp22_ = start;
-	_tmp23_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) (_tmp21_ - _tmp22_));
-	result = _tmp23_;
-	return result;
-}
-
-
-static gchar* playlists_menuitem_truncate_item_label_if_needs_be (PlaylistsMenuitem* self, const gchar* item_label) {
-	gchar* result = NULL;
-	const gchar* _tmp0_;
-	gchar* _tmp1_;
-	gchar* _result_;
-	const gchar* _tmp2_;
-	gint _tmp3_ = 0;
-	g_return_val_if_fail (self != NULL, NULL);
-	g_return_val_if_fail (item_label != NULL, NULL);
-	_tmp0_ = item_label;
-	_tmp1_ = g_strdup (_tmp0_);
-	_result_ = _tmp1_;
-	_tmp2_ = item_label;
-	_tmp3_ = g_utf8_strlen (_tmp2_, (gssize) (-1));
-	if (_tmp3_ > 17) {
-		const gchar* _tmp4_;
-		gchar* _tmp5_ = NULL;
-		const gchar* _tmp6_;
-		gchar* _tmp7_;
-		_tmp4_ = item_label;
-		_tmp5_ = string_slice (_tmp4_, (glong) 0, (glong) 15);
-		_g_free0 (_result_);
-		_result_ = _tmp5_;
-		_tmp6_ = _result_;
-		_tmp7_ = g_strconcat (_tmp6_, "…", NULL);
-		_g_free0 (_result_);
-		_result_ = _tmp7_;
-	}
-	result = _result_;
-	return result;
-}
-
-
-GeeHashSet* playlists_menuitem_attributes_format (void) {
-	GeeHashSet* result = NULL;
-	GeeHashSet* _tmp0_;
-	GeeHashSet* attrs;
-	_tmp0_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL);
-	attrs = _tmp0_;
-	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_PLAYLISTS_MENUITEM_TITLE);
-	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_PLAYLISTS_MENUITEM_PLAYLISTS);
-	result = attrs;
-	return result;
-}
-
-
-static GObject * playlists_menuitem_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
-	GObject * obj;
-	GObjectClass * parent_class;
-	PlaylistsMenuitem * self;
-	GeeHashMap* _tmp0_;
-	DbusmenuMenuitem* _tmp1_;
-	DbusmenuMenuitem* _tmp2_;
-	const gchar* _tmp3_ = NULL;
-	DbusmenuMenuitem* _tmp4_;
-	parent_class = G_OBJECT_CLASS (playlists_menuitem_parent_class);
-	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
-	self = PLAYLISTS_MENUITEM (obj);
-	_tmp0_ = gee_hash_map_new (G_TYPE_INT, NULL, NULL, dbusmenu_menuitem_get_type (), (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
-	_g_object_unref0 (self->priv->current_playlists);
-	self->priv->current_playlists = _tmp0_;
-	_tmp1_ = dbusmenu_menuitem_new ();
-	_g_object_unref0 (self->root_item);
-	self->root_item = _tmp1_;
-	_tmp2_ = self->root_item;
-	_tmp3_ = _ ("Choose Playlist");
-	dbusmenu_menuitem_property_set (_tmp2_, DBUSMENU_MENUITEM_PROP_LABEL, _tmp3_);
-	_tmp4_ = self->root_item;
-	dbusmenu_menuitem_property_set (_tmp4_, DBUSMENU_PLAYLIST_MENUITEM_PATH, "");
-	return obj;
-}
-
-
-static void playlists_menuitem_class_init (PlaylistsMenuitemClass * klass) {
-	playlists_menuitem_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (PlaylistsMenuitemPrivate));
-	G_OBJECT_CLASS (klass)->constructor = playlists_menuitem_constructor;
-	G_OBJECT_CLASS (klass)->finalize = playlists_menuitem_finalize;
-}
-
-
-static void playlists_menuitem_instance_init (PlaylistsMenuitem * self) {
-	self->priv = PLAYLISTS_MENUITEM_GET_PRIVATE (self);
-}
-
-
-static void playlists_menuitem_finalize (GObject* obj) {
-	PlaylistsMenuitem * self;
-	self = PLAYLISTS_MENUITEM (obj);
-	_g_object_unref0 (self->priv->current_playlists);
-	_g_object_unref0 (self->root_item);
-	G_OBJECT_CLASS (playlists_menuitem_parent_class)->finalize (obj);
-}
-
-
-GType playlists_menuitem_get_type (void) {
-	static volatile gsize playlists_menuitem_type_id__volatile = 0;
-	if (g_once_init_enter (&playlists_menuitem_type_id__volatile)) {
-		static const GTypeInfo g_define_type_info = { sizeof (PlaylistsMenuitemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) playlists_menuitem_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlaylistsMenuitem), 0, (GInstanceInitFunc) playlists_menuitem_instance_init, NULL };
-		GType playlists_menuitem_type_id;
-		playlists_menuitem_type_id = g_type_register_static (TYPE_PLAYER_ITEM, "PlaylistsMenuitem", &g_define_type_info, 0);
-		g_once_init_leave (&playlists_menuitem_type_id__volatile, playlists_menuitem_type_id);
-	}
-	return playlists_menuitem_type_id__volatile;
-}
-
-
-
diff -Naur indicator-sound-0.8.5.0/src/settings-manager.c indicator-sound-precise/src/settings-manager.c
--- indicator-sound-0.8.5.0/src/settings-manager.c	2012-03-30 10:32:34.000000000 -0700
+++ indicator-sound-precise/src/settings-manager.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,491 +0,0 @@
-/* settings-manager.c generated by valac 0.14.2, the Vala compiler
- * generated from settings-manager.vala, do not modify */
-
-/*
-Copyright 2010 Canonical Ltd.
-
-Authors:
-    Conor Curran <conor.curran@canonical.com>
-
-This program is free software: you can redistribute it and/or modify it 
-under the terms of the GNU General Public License version 3, as published 
-by the Free Software Foundation.
-
-This program is distributed in the hope that it will be useful, but 
-WITHOUT ANY WARRANTY; without even the implied warranties of 
-MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
-PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along 
-with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <glib.h>
-#include <glib-object.h>
-#include <gio/gio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gee.h>
-
-
-#define TYPE_SETTINGS_MANAGER (settings_manager_get_type ())
-#define SETTINGS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SETTINGS_MANAGER, SettingsManager))
-#define SETTINGS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SETTINGS_MANAGER, SettingsManagerClass))
-#define IS_SETTINGS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SETTINGS_MANAGER))
-#define IS_SETTINGS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SETTINGS_MANAGER))
-#define SETTINGS_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SETTINGS_MANAGER, SettingsManagerClass))
-
-typedef struct _SettingsManager SettingsManager;
-typedef struct _SettingsManagerClass SettingsManagerClass;
-typedef struct _SettingsManagerPrivate SettingsManagerPrivate;
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-#define _g_variant_type_free0(var) ((var == NULL) ? NULL : (var = (g_variant_type_free (var), NULL)))
-#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
-#define _g_variant_builder_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_builder_unref (var), NULL)))
-
-struct _SettingsManager {
-	GObject parent_instance;
-	SettingsManagerPrivate * priv;
-};
-
-struct _SettingsManagerClass {
-	GObjectClass parent_class;
-};
-
-struct _SettingsManagerPrivate {
-	GSettings* settings;
-};
-
-
-static gpointer settings_manager_parent_class = NULL;
-
-GType settings_manager_get_type (void) G_GNUC_CONST;
-#define SETTINGS_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SETTINGS_MANAGER, SettingsManagerPrivate))
-enum  {
-	SETTINGS_MANAGER_DUMMY_PROPERTY
-};
-SettingsManager* settings_manager_new (void);
-SettingsManager* settings_manager_construct (GType object_type);
-gchar** settings_manager_fetch_blacklist (SettingsManager* self, int* result_length1);
-GeeArrayList* settings_manager_fetch_interested (SettingsManager* self);
-static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle);
-void settings_manager_clear_list (SettingsManager* self);
-void settings_manager_remove_interested (SettingsManager* self, const gchar* app_desktop_name);
-void settings_manager_add_interested (SettingsManager* self, const gchar* app_desktop_name);
-static void settings_manager_on_blacklist_event (SettingsManager* self);
-static void g_cclosure_user_marshal_VOID__BOXED_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
-static GObject * settings_manager_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
-static void _settings_manager_on_blacklist_event_g_settings_changed (GSettings* _sender, const gchar* key, gpointer self);
-static void settings_manager_finalize (GObject* obj);
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
-static gint _vala_array_length (gpointer array);
-
-
-SettingsManager* settings_manager_construct (GType object_type) {
-	SettingsManager * self = NULL;
-	self = (SettingsManager*) g_object_new (object_type, NULL);
-	return self;
-}
-
-
-SettingsManager* settings_manager_new (void) {
-	return settings_manager_construct (TYPE_SETTINGS_MANAGER);
-}
-
-
-gchar** settings_manager_fetch_blacklist (SettingsManager* self, int* result_length1) {
-	gchar** result = NULL;
-	GSettings* _tmp0_;
-	gchar** _tmp1_;
-	gchar** _tmp2_ = NULL;
-	gchar** _tmp3_;
-	gint _tmp3__length1;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = self->priv->settings;
-	_tmp2_ = _tmp1_ = g_settings_get_strv (_tmp0_, "blacklisted-media-players");
-	_tmp3_ = _tmp2_;
-	_tmp3__length1 = _vala_array_length (_tmp1_);
-	if (result_length1) {
-		*result_length1 = _tmp3__length1;
-	}
-	result = _tmp3_;
-	return result;
-}
-
-
-static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle) {
-	int i;
-	for (i = 0; i < stack_length; i++) {
-		if (g_strcmp0 (stack[i], needle) == 0) {
-			return TRUE;
-		}
-	}
-	return FALSE;
-}
-
-
-GeeArrayList* settings_manager_fetch_interested (SettingsManager* self) {
-	GeeArrayList* result = NULL;
-	GSettings* _tmp0_;
-	gchar** _tmp1_;
-	gchar** _tmp2_ = NULL;
-	gchar** blacklisted;
-	gint blacklisted_length1;
-	gint _blacklisted_size_;
-	GSettings* _tmp3_;
-	gchar** _tmp4_;
-	gchar** _tmp5_ = NULL;
-	gchar** interested;
-	gint interested_length1;
-	gint _interested_size_;
-	GeeArrayList* _tmp6_;
-	GeeArrayList* list;
-	gchar** _tmp7_;
-	gint _tmp7__length1;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = self->priv->settings;
-	_tmp2_ = _tmp1_ = g_settings_get_strv (_tmp0_, "blacklisted-media-players");
-	blacklisted = _tmp2_;
-	blacklisted_length1 = _vala_array_length (_tmp1_);
-	_blacklisted_size_ = blacklisted_length1;
-	_tmp3_ = self->priv->settings;
-	_tmp5_ = _tmp4_ = g_settings_get_strv (_tmp3_, "interested-media-players");
-	interested = _tmp5_;
-	interested_length1 = _vala_array_length (_tmp4_);
-	_interested_size_ = interested_length1;
-	_tmp6_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
-	list = _tmp6_;
-	_tmp7_ = interested;
-	_tmp7__length1 = interested_length1;
-	{
-		gchar** s_collection = NULL;
-		gint s_collection_length1 = 0;
-		gint _s_collection_size_ = 0;
-		gint s_it = 0;
-		s_collection = _tmp7_;
-		s_collection_length1 = _tmp7__length1;
-		for (s_it = 0; s_it < _tmp7__length1; s_it = s_it + 1) {
-			gchar* _tmp8_;
-			gchar* s = NULL;
-			_tmp8_ = g_strdup (s_collection[s_it]);
-			s = _tmp8_;
-			{
-				const gchar* _tmp9_;
-				GeeArrayList* _tmp11_;
-				const gchar* _tmp12_;
-				gboolean _tmp13_ = FALSE;
-				const gchar* _tmp14_;
-				gchar** _tmp15_;
-				gint _tmp15__length1;
-				GeeArrayList* _tmp16_;
-				const gchar* _tmp17_;
-				_tmp9_ = s;
-				if (g_strcmp0 (_tmp9_, "banshee-1") == 0) {
-					gchar* _tmp10_;
-					_tmp10_ = g_strdup ("banshee");
-					_g_free0 (s);
-					s = _tmp10_;
-				}
-				_tmp11_ = list;
-				_tmp12_ = s;
-				_tmp13_ = gee_abstract_collection_contains ((GeeAbstractCollection*) _tmp11_, _tmp12_);
-				if (_tmp13_) {
-					_g_free0 (s);
-					continue;
-				}
-				_tmp14_ = s;
-				_tmp15_ = blacklisted;
-				_tmp15__length1 = blacklisted_length1;
-				if (_vala_string_array_contains (_tmp15_, _tmp15__length1, _tmp14_)) {
-					_g_free0 (s);
-					continue;
-				}
-				_tmp16_ = list;
-				_tmp17_ = s;
-				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp16_, _tmp17_);
-				_g_free0 (s);
-			}
-		}
-	}
-	result = list;
-	interested = (_vala_array_free (interested, interested_length1, (GDestroyNotify) g_free), NULL);
-	blacklisted = (_vala_array_free (blacklisted, blacklisted_length1, (GDestroyNotify) g_free), NULL);
-	return result;
-}
-
-
-void settings_manager_clear_list (SettingsManager* self) {
-	GSettings* _tmp0_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = self->priv->settings;
-	g_settings_reset (_tmp0_, "interested-media-players");
-}
-
-
-void settings_manager_remove_interested (SettingsManager* self, const gchar* app_desktop_name) {
-	static const char key[] = "interested-media-players";
-	GVariantType* _tmp0_;
-	GVariantType* _tmp1_;
-	GVariantBuilder* _tmp2_;
-	GVariantBuilder* _tmp3_;
-	GVariantBuilder* players;
-	GSettings* _tmp4_;
-	gchar** _tmp5_;
-	gchar** _tmp6_ = NULL;
-	GSettings* _tmp12_;
-	GVariantBuilder* _tmp13_;
-	GVariant* _tmp14_ = NULL;
-	GVariant* _tmp15_;
-	GSettings* _tmp16_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (app_desktop_name != NULL);
-	_tmp0_ = g_variant_type_new ("as");
-	_tmp1_ = _tmp0_;
-	_tmp2_ = g_variant_builder_new (_tmp1_);
-	_tmp3_ = _tmp2_;
-	_g_variant_type_free0 (_tmp1_);
-	players = _tmp3_;
-	_tmp4_ = self->priv->settings;
-	_tmp6_ = _tmp5_ = g_settings_get_strv (_tmp4_, key);
-	{
-		gchar** player_collection = NULL;
-		gint player_collection_length1 = 0;
-		gint _player_collection_size_ = 0;
-		gint player_it = 0;
-		player_collection = _tmp6_;
-		player_collection_length1 = _vala_array_length (_tmp5_);
-		for (player_it = 0; player_it < _vala_array_length (_tmp5_); player_it = player_it + 1) {
-			gchar* _tmp7_;
-			gchar* player = NULL;
-			_tmp7_ = g_strdup (player_collection[player_it]);
-			player = _tmp7_;
-			{
-				const gchar* _tmp8_;
-				const gchar* _tmp9_;
-				_tmp8_ = player;
-				_tmp9_ = app_desktop_name;
-				if (g_strcmp0 (_tmp8_, _tmp9_) != 0) {
-					GVariantBuilder* _tmp10_;
-					const gchar* _tmp11_;
-					_tmp10_ = players;
-					_tmp11_ = player;
-					g_variant_builder_add (_tmp10_, "s", _tmp11_, NULL);
-				}
-				_g_free0 (player);
-			}
-		}
-		player_collection = (_vala_array_free (player_collection, player_collection_length1, (GDestroyNotify) g_free), NULL);
-	}
-	_tmp12_ = self->priv->settings;
-	_tmp13_ = players;
-	_tmp14_ = g_variant_builder_end (_tmp13_);
-	_tmp15_ = g_variant_ref_sink (_tmp14_);
-	g_settings_set_value (_tmp12_, key, _tmp15_);
-	_g_variant_unref0 (_tmp15_);
-	_tmp16_ = self->priv->settings;
-	g_settings_apply (_tmp16_);
-	_g_variant_builder_unref0 (players);
-}
-
-
-void settings_manager_add_interested (SettingsManager* self, const gchar* app_desktop_name) {
-	static const char key[] = "interested-media-players";
-	GVariantType* _tmp0_;
-	GVariantType* _tmp1_;
-	GVariantBuilder* _tmp2_;
-	GVariantBuilder* _tmp3_;
-	GVariantBuilder* players;
-	GSettings* _tmp4_;
-	gchar** _tmp5_;
-	gchar** _tmp6_ = NULL;
-	GVariantBuilder* _tmp12_;
-	const gchar* _tmp13_;
-	GSettings* _tmp14_;
-	GVariantBuilder* _tmp15_;
-	GVariant* _tmp16_ = NULL;
-	GVariant* _tmp17_;
-	GSettings* _tmp18_;
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (app_desktop_name != NULL);
-	_tmp0_ = g_variant_type_new ("as");
-	_tmp1_ = _tmp0_;
-	_tmp2_ = g_variant_builder_new (_tmp1_);
-	_tmp3_ = _tmp2_;
-	_g_variant_type_free0 (_tmp1_);
-	players = _tmp3_;
-	_tmp4_ = self->priv->settings;
-	_tmp6_ = _tmp5_ = g_settings_get_strv (_tmp4_, key);
-	{
-		gchar** player_collection = NULL;
-		gint player_collection_length1 = 0;
-		gint _player_collection_size_ = 0;
-		gint player_it = 0;
-		player_collection = _tmp6_;
-		player_collection_length1 = _vala_array_length (_tmp5_);
-		for (player_it = 0; player_it < _vala_array_length (_tmp5_); player_it = player_it + 1) {
-			gchar* _tmp7_;
-			gchar* player = NULL;
-			_tmp7_ = g_strdup (player_collection[player_it]);
-			player = _tmp7_;
-			{
-				const gchar* _tmp8_;
-				const gchar* _tmp9_;
-				GVariantBuilder* _tmp10_;
-				const gchar* _tmp11_;
-				_tmp8_ = player;
-				_tmp9_ = app_desktop_name;
-				if (g_strcmp0 (_tmp8_, _tmp9_) == 0) {
-					_g_free0 (player);
-					player_collection = (_vala_array_free (player_collection, player_collection_length1, (GDestroyNotify) g_free), NULL);
-					_g_variant_builder_unref0 (players);
-					return;
-				}
-				_tmp10_ = players;
-				_tmp11_ = player;
-				g_variant_builder_add (_tmp10_, "s", _tmp11_, NULL);
-				_g_free0 (player);
-			}
-		}
-		player_collection = (_vala_array_free (player_collection, player_collection_length1, (GDestroyNotify) g_free), NULL);
-	}
-	_tmp12_ = players;
-	_tmp13_ = app_desktop_name;
-	g_variant_builder_add (_tmp12_, "s", _tmp13_, NULL);
-	_tmp14_ = self->priv->settings;
-	_tmp15_ = players;
-	_tmp16_ = g_variant_builder_end (_tmp15_);
-	_tmp17_ = g_variant_ref_sink (_tmp16_);
-	g_settings_set_value (_tmp14_, key, _tmp17_);
-	_g_variant_unref0 (_tmp17_);
-	_tmp18_ = self->priv->settings;
-	g_settings_apply (_tmp18_);
-	_g_variant_builder_unref0 (players);
-}
-
-
-static void settings_manager_on_blacklist_event (SettingsManager* self) {
-	GSettings* _tmp0_;
-	gchar** _tmp1_;
-	gchar** _tmp2_ = NULL;
-	gchar** _tmp3_;
-	gint _tmp3__length1;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = self->priv->settings;
-	_tmp2_ = _tmp1_ = g_settings_get_strv (_tmp0_, "blacklisted-media-players");
-	_tmp3_ = _tmp2_;
-	_tmp3__length1 = _vala_array_length (_tmp1_);
-	g_signal_emit_by_name (self, "blacklist-updates", _tmp3_, _vala_array_length (_tmp1_));
-	_tmp3_ = (_vala_array_free (_tmp3_, _tmp3__length1, (GDestroyNotify) g_free), NULL);
-}
-
-
-static void g_cclosure_user_marshal_VOID__BOXED_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
-	typedef void (*GMarshalFunc_VOID__BOXED_INT) (gpointer data1, gpointer arg_1, gint arg_2, gpointer data2);
-	register GMarshalFunc_VOID__BOXED_INT callback;
-	register GCClosure * cc;
-	register gpointer data1;
-	register gpointer data2;
-	cc = (GCClosure *) closure;
-	g_return_if_fail (n_param_values == 3);
-	if (G_CCLOSURE_SWAP_DATA (closure)) {
-		data1 = closure->data;
-		data2 = param_values->data[0].v_pointer;
-	} else {
-		data1 = param_values->data[0].v_pointer;
-		data2 = closure->data;
-	}
-	callback = (GMarshalFunc_VOID__BOXED_INT) (marshal_data ? marshal_data : cc->callback);
-	callback (data1, g_value_get_boxed (param_values + 1), g_value_get_int (param_values + 2), data2);
-}
-
-
-static void _settings_manager_on_blacklist_event_g_settings_changed (GSettings* _sender, const gchar* key, gpointer self) {
-	settings_manager_on_blacklist_event (self);
-}
-
-
-static GObject * settings_manager_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
-	GObject * obj;
-	GObjectClass * parent_class;
-	SettingsManager * self;
-	GSettings* _tmp0_;
-	GSettings* _tmp1_;
-	parent_class = G_OBJECT_CLASS (settings_manager_parent_class);
-	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
-	self = SETTINGS_MANAGER (obj);
-	_tmp0_ = g_settings_new ("com.canonical.indicator.sound");
-	_g_object_unref0 (self->priv->settings);
-	self->priv->settings = _tmp0_;
-	_tmp1_ = self->priv->settings;
-	g_signal_connect_object (_tmp1_, "changed::blacklisted-media-players", (GCallback) _settings_manager_on_blacklist_event_g_settings_changed, self, 0);
-	return obj;
-}
-
-
-static void settings_manager_class_init (SettingsManagerClass * klass) {
-	settings_manager_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (SettingsManagerPrivate));
-	G_OBJECT_CLASS (klass)->constructor = settings_manager_constructor;
-	G_OBJECT_CLASS (klass)->finalize = settings_manager_finalize;
-	g_signal_new ("blacklist_updates", TYPE_SETTINGS_MANAGER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__BOXED_INT, G_TYPE_NONE, 2, G_TYPE_STRV, G_TYPE_INT);
-}
-
-
-static void settings_manager_instance_init (SettingsManager * self) {
-	self->priv = SETTINGS_MANAGER_GET_PRIVATE (self);
-}
-
-
-static void settings_manager_finalize (GObject* obj) {
-	SettingsManager * self;
-	self = SETTINGS_MANAGER (obj);
-	_g_object_unref0 (self->priv->settings);
-	G_OBJECT_CLASS (settings_manager_parent_class)->finalize (obj);
-}
-
-
-GType settings_manager_get_type (void) {
-	static volatile gsize settings_manager_type_id__volatile = 0;
-	if (g_once_init_enter (&settings_manager_type_id__volatile)) {
-		static const GTypeInfo g_define_type_info = { sizeof (SettingsManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) settings_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SettingsManager), 0, (GInstanceInitFunc) settings_manager_instance_init, NULL };
-		GType settings_manager_type_id;
-		settings_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "SettingsManager", &g_define_type_info, 0);
-		g_once_init_leave (&settings_manager_type_id__volatile, settings_manager_type_id);
-	}
-	return settings_manager_type_id__volatile;
-}
-
-
-static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	if ((array != NULL) && (destroy_func != NULL)) {
-		int i;
-		for (i = 0; i < array_length; i = i + 1) {
-			if (((gpointer*) array)[i] != NULL) {
-				destroy_func (((gpointer*) array)[i]);
-			}
-		}
-	}
-}
-
-
-static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
-	_vala_array_destroy (array, array_length, destroy_func);
-	g_free (array);
-}
-
-
-static gint _vala_array_length (gpointer array) {
-	int length;
-	length = 0;
-	if (array) {
-		while (((gpointer*) array)[length]) {
-			length++;
-		}
-	}
-	return length;
-}
-
-
-
diff -Naur indicator-sound-0.8.5.0/src/settings-manager.vala indicator-sound-precise/src/settings-manager.vala
--- indicator-sound-0.8.5.0/src/settings-manager.vala	2012-03-30 10:26:53.000000000 -0700
+++ indicator-sound-precise/src/settings-manager.vala	2012-07-26 21:03:55.488143000 -0700
@@ -22,12 +22,14 @@
 {
   private Settings settings;
   public signal void blacklist_updates ( string[] new_blacklist );
+  public signal void preferred_updates (Gee.ArrayList<string> new_preferred);
   
   public SettingsManager ( ){
   }
   construct{
     this.settings = new Settings ("com.canonical.indicator.sound");
-    this.settings.changed["blacklisted-media-players"].connect (on_blacklist_event);    
+    this.settings.changed["blacklisted-media-players"].connect (on_blacklist_event);
+    this.settings.changed["preferred-media-players"].connect (on_preferred_event);
   }
    
   public string[] fetch_blacklist()
@@ -35,9 +37,24 @@
     return this.settings.get_strv ("blacklisted-media-players");
   }
 
+  public ArrayList<string> fetch_preferred()
+  {
+    var list = new ArrayList<string>();
+
+    var preferred = this.settings.get_strv ("preferred-media-players");
+    var interested = fetch_interested ();
+
+    foreach (var s in preferred) {
+      if (!(s in list) && interested.contains (s))
+        list.add (s);
+    }
+
+    return list;
+  }
+
   public ArrayList<string> fetch_interested()
   {
-    var blacklisted = this.settings.get_strv ("blacklisted-media-players");
+    var blacklisted = fetch_blacklist ();
     var interested = this.settings.get_strv ("interested-media-players");
     var list = new ArrayList<string>();
     foreach(var s in interested){
@@ -91,6 +108,11 @@
     this.blacklist_updates(this.settings.get_strv ("blacklisted-media-players"));        
   }
 
+  private void on_preferred_event()
+  {
+    this.preferred_updates (this.fetch_preferred());
+  }
+
   // Convenient debug method inorder to provide visability over 
   // the contents of both interested and blacklisted containers in its gsettings
 /**
diff -Naur indicator-sound-0.8.5.0/src/sound-service-dbus.c indicator-sound-precise/src/sound-service-dbus.c
--- indicator-sound-0.8.5.0/src/sound-service-dbus.c	2012-03-30 10:26:53.000000000 -0700
+++ indicator-sound-precise/src/sound-service-dbus.c	2012-07-26 21:03:55.488143000 -0700
@@ -79,8 +79,10 @@
 static void sound_service_dbus_dispose    (GObject *object);
 static void sound_service_dbus_finalize   (GObject *object);
 
+#ifdef HAVE_SETTINGS_MENU_ITEM
 static void show_sound_settings_dialog (DbusmenuMenuitem *mi,
                                         gpointer user_data);
+#endif
 static gboolean sound_service_dbus_blacklist_player (SoundServiceDbus* self,
                                                      const gchar* player_name,
                                                      gboolean blacklist); 
@@ -195,6 +197,7 @@
   dbusmenu_menuitem_child_add_position (priv->root_menuitem, slider_item, 1);
   dbusmenu_menuitem_child_add_position (priv->root_menuitem, voip_input_menu_item, 2);
 
+#ifdef HAVE_SETTINGS_MENU_ITEM
   if (!priv->greeter_mode) {
     // Separator
     DbusmenuMenuitem* separator = dbusmenu_menuitem_new();
@@ -216,8 +219,10 @@
     g_signal_connect(G_OBJECT(settings_mi), DBUSMENU_MENUITEM_SIGNAL_ITEM_ACTIVATED,
                      G_CALLBACK(show_sound_settings_dialog), NULL);  
   }
+#endif
 }
 
+#ifdef HAVE_SETTINGS_MENU_ITEM
 /**
 show_sound_settings_dialog:
 Bring up the gnome volume preferences dialog
@@ -235,6 +240,7 @@
     g_error_free(error);
   }
 }
+#endif
 
 static void
 sound_service_dbus_dispose (GObject *object)
diff -Naur indicator-sound-0.8.5.0/src/specific-items-manager.c indicator-sound-precise/src/specific-items-manager.c
--- indicator-sound-0.8.5.0/src/specific-items-manager.c	2012-03-30 10:32:34.000000000 -0700
+++ indicator-sound-precise/src/specific-items-manager.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,598 +0,0 @@
-/* specific-items-manager.c generated by valac 0.14.2, the Vala compiler
- * generated from specific-items-manager.vala, do not modify */
-
-/*
-Copyright 2011 Canonical Ltd.
-
-Authors:
-    Conor Curran <conor.curran@canonical.com>
-
-This program is free software: you can redistribute it and/or modify it 
-under the terms of the GNU General Public License version 3, as published 
-by the Free Software Foundation.
-
-This program is distributed in the hope that it will be useful, but 
-WITHOUT ANY WARRANTY; without even the implied warranties of 
-MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
-PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along 
-with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <glib.h>
-#include <glib-object.h>
-#include <stdlib.h>
-#include <string.h>
-#include <libdbusmenu-glib/client.h>
-#include <libdbusmenu-glib/dbusmenu-glib.h>
-#include <libdbusmenu-glib/enum-types.h>
-#include <libdbusmenu-glib/menuitem-proxy.h>
-#include <libdbusmenu-glib/menuitem.h>
-#include <libdbusmenu-glib/server.h>
-#include <libdbusmenu-glib/types.h>
-#include <gee.h>
-
-
-#define TYPE_SPECIFIC_ITEMS_MANAGER (specific_items_manager_get_type ())
-#define SPECIFIC_ITEMS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SPECIFIC_ITEMS_MANAGER, SpecificItemsManager))
-#define SPECIFIC_ITEMS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SPECIFIC_ITEMS_MANAGER, SpecificItemsManagerClass))
-#define IS_SPECIFIC_ITEMS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SPECIFIC_ITEMS_MANAGER))
-#define IS_SPECIFIC_ITEMS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SPECIFIC_ITEMS_MANAGER))
-#define SPECIFIC_ITEMS_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SPECIFIC_ITEMS_MANAGER, SpecificItemsManagerClass))
-
-typedef struct _SpecificItemsManager SpecificItemsManager;
-typedef struct _SpecificItemsManagerClass SpecificItemsManagerClass;
-typedef struct _SpecificItemsManagerPrivate SpecificItemsManagerPrivate;
-
-#define TYPE_PLAYER_CONTROLLER (player_controller_get_type ())
-#define PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONTROLLER, PlayerController))
-#define PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-#define IS_PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONTROLLER))
-#define IS_PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONTROLLER))
-#define PLAYER_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-
-typedef struct _PlayerController PlayerController;
-typedef struct _PlayerControllerClass PlayerControllerClass;
-
-#define SPECIFIC_ITEMS_MANAGER_TYPE_CATEGORY (specific_items_manager_category_get_type ())
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-#define _g_free0(var) (var = (g_free (var), NULL))
-typedef struct _PlayerControllerPrivate PlayerControllerPrivate;
-
-#define TYPE_PLAYER_ITEM (player_item_get_type ())
-#define PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_ITEM, PlayerItem))
-#define PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_ITEM, PlayerItemClass))
-#define IS_PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_ITEM))
-#define IS_PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_ITEM))
-#define PLAYER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_ITEM, PlayerItemClass))
-
-typedef struct _PlayerItem PlayerItem;
-typedef struct _PlayerItemClass PlayerItemClass;
-
-#define TYPE_MPRIS2_CONTROLLER (mpris2_controller_get_type ())
-#define MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2Controller))
-#define MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
-#define IS_MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS2_CONTROLLER))
-#define IS_MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS2_CONTROLLER))
-#define MPRIS2_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
-
-typedef struct _Mpris2Controller Mpris2Controller;
-typedef struct _Mpris2ControllerClass Mpris2ControllerClass;
-#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
-
-struct _SpecificItemsManager {
-	GObject parent_instance;
-	SpecificItemsManagerPrivate * priv;
-};
-
-struct _SpecificItemsManagerClass {
-	GObjectClass parent_class;
-};
-
-struct _SpecificItemsManagerPrivate {
-	PlayerController* _owner;
-	gchar* dbus_path;
-	DbusmenuClient* client;
-	GeeArrayList* _proxy_items;
-	gint of_type;
-};
-
-typedef enum  {
-	SPECIFIC_ITEMS_MANAGER_CATEGORY_TRACK,
-	SPECIFIC_ITEMS_MANAGER_CATEGORY_PLAYER
-} SpecificItemsManagercategory;
-
-struct _PlayerController {
-	GObject parent_instance;
-	PlayerControllerPrivate * priv;
-	gint current_state;
-	DbusmenuMenuitem* root_menu;
-	GeeArrayList* custom_items;
-	Mpris2Controller* mpris_bridge;
-	gboolean* use_playlists;
-};
-
-struct _PlayerControllerClass {
-	GObjectClass parent_class;
-};
-
-
-static gpointer specific_items_manager_parent_class = NULL;
-
-GType specific_items_manager_get_type (void) G_GNUC_CONST;
-GType player_controller_get_type (void) G_GNUC_CONST;
-#define SPECIFIC_ITEMS_MANAGER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SPECIFIC_ITEMS_MANAGER, SpecificItemsManagerPrivate))
-enum  {
-	SPECIFIC_ITEMS_MANAGER_DUMMY_PROPERTY,
-	SPECIFIC_ITEMS_MANAGER_PROXY_ITEMS
-};
-GType specific_items_manager_category_get_type (void) G_GNUC_CONST;
-SpecificItemsManager* specific_items_manager_new (PlayerController* controller, const gchar* path, SpecificItemsManagercategory which_type);
-SpecificItemsManager* specific_items_manager_construct (GType object_type, PlayerController* controller, const gchar* path, SpecificItemsManagercategory which_type);
-static void specific_items_manager_set_owner (SpecificItemsManager* self, PlayerController* value);
-static PlayerController* specific_items_manager_get_owner (SpecificItemsManager* self);
-const gchar* player_controller_get_dbus_name (PlayerController* self);
-static void specific_items_manager_on_root_changed (SpecificItemsManager* self, GObject* newroot);
-static void _specific_items_manager_on_root_changed_dbusmenu_client_root_changed (DbusmenuClient* _sender, GObject* object, gpointer self);
-static gint specific_items_manager_figure_out_positioning (SpecificItemsManager* self);
-gint player_controller_get_menu_offset (PlayerController* self);
-#define PLAYER_CONTROLLER_WIDGET_QUANTITY 4
-GeeArrayList* specific_items_manager_get_proxy_items (SpecificItemsManager* self);
-gint player_controller_track_specific_count (PlayerController* self);
-GType player_item_get_type (void) G_GNUC_CONST;
-GType mpris2_controller_get_type (void) G_GNUC_CONST;
-static gboolean _bool_equal (const gboolean* s1, const gboolean* s2);
-static void specific_items_manager_on_child_added (SpecificItemsManager* self, GObject* child, guint position);
-static void _specific_items_manager_on_child_added_dbusmenu_menuitem_child_added (DbusmenuMenuitem* _sender, GObject* position, guint p0, gpointer self);
-static void specific_items_manager_on_child_removed (SpecificItemsManager* self, GObject* child);
-static void _specific_items_manager_on_child_removed_dbusmenu_menuitem_child_removed (DbusmenuMenuitem* _sender, GObject* object, gpointer self);
-static void specific_items_manager_set_proxy_items (SpecificItemsManager* self, GeeArrayList* value);
-static GObject * specific_items_manager_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
-static void specific_items_manager_finalize (GObject* obj);
-static void _vala_specific_items_manager_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
-static void _vala_specific_items_manager_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
-
-
-GType specific_items_manager_category_get_type (void) {
-	static volatile gsize specific_items_manager_category_type_id__volatile = 0;
-	if (g_once_init_enter (&specific_items_manager_category_type_id__volatile)) {
-		static const GEnumValue values[] = {{SPECIFIC_ITEMS_MANAGER_CATEGORY_TRACK, "SPECIFIC_ITEMS_MANAGER_CATEGORY_TRACK", "track"}, {SPECIFIC_ITEMS_MANAGER_CATEGORY_PLAYER, "SPECIFIC_ITEMS_MANAGER_CATEGORY_PLAYER", "player"}, {0, NULL, NULL}};
-		GType specific_items_manager_category_type_id;
-		specific_items_manager_category_type_id = g_enum_register_static ("SpecificItemsManagercategory", values);
-		g_once_init_leave (&specific_items_manager_category_type_id__volatile, specific_items_manager_category_type_id);
-	}
-	return specific_items_manager_category_type_id__volatile;
-}
-
-
-static void _specific_items_manager_on_root_changed_dbusmenu_client_root_changed (DbusmenuClient* _sender, GObject* object, gpointer self) {
-	specific_items_manager_on_root_changed (self, object);
-}
-
-
-SpecificItemsManager* specific_items_manager_construct (GType object_type, PlayerController* controller, const gchar* path, SpecificItemsManagercategory which_type) {
-	SpecificItemsManager * self = NULL;
-	SpecificItemsManagercategory _tmp0_;
-	PlayerController* _tmp1_;
-	const gchar* _tmp2_;
-	gchar* _tmp3_;
-	PlayerController* _tmp4_;
-	const gchar* _tmp5_;
-	const gchar* _tmp6_;
-	const gchar* _tmp7_;
-	DbusmenuClient* _tmp8_;
-	DbusmenuClient* _tmp9_;
-	g_return_val_if_fail (controller != NULL, NULL);
-	g_return_val_if_fail (path != NULL, NULL);
-	self = (SpecificItemsManager*) g_object_new (object_type, NULL);
-	_tmp0_ = which_type;
-	self->priv->of_type = (gint) _tmp0_;
-	_tmp1_ = controller;
-	specific_items_manager_set_owner (self, _tmp1_);
-	_tmp2_ = path;
-	_tmp3_ = g_strdup (_tmp2_);
-	_g_free0 (self->priv->dbus_path);
-	self->priv->dbus_path = _tmp3_;
-	_tmp4_ = self->priv->_owner;
-	_tmp5_ = player_controller_get_dbus_name (_tmp4_);
-	_tmp6_ = _tmp5_;
-	_tmp7_ = self->priv->dbus_path;
-	_tmp8_ = dbusmenu_client_new (_tmp6_, _tmp7_);
-	_g_object_unref0 (self->priv->client);
-	self->priv->client = _tmp8_;
-	_tmp9_ = self->priv->client;
-	g_signal_connect_object (_tmp9_, "root-changed", (GCallback) _specific_items_manager_on_root_changed_dbusmenu_client_root_changed, self, 0);
-	return self;
-}
-
-
-SpecificItemsManager* specific_items_manager_new (PlayerController* controller, const gchar* path, SpecificItemsManagercategory which_type) {
-	return specific_items_manager_construct (TYPE_SPECIFIC_ITEMS_MANAGER, controller, path, which_type);
-}
-
-
-static gboolean _bool_equal (const gboolean* s1, const gboolean* s2) {
-	if (s1 == s2) {
-		return TRUE;
-	}
-	if (s1 == NULL) {
-		return FALSE;
-	}
-	if (s2 == NULL) {
-		return FALSE;
-	}
-	return (*s1) == (*s2);
-}
-
-
-static gint specific_items_manager_figure_out_positioning (SpecificItemsManager* self) {
-	gint result = 0;
-	gint _result_;
-	gint _tmp0_;
-	gint _tmp22_;
-	gint _tmp23_;
-	g_return_val_if_fail (self != NULL, 0);
-	_result_ = 0;
-	_tmp0_ = self->priv->of_type;
-	if (_tmp0_ == ((gint) SPECIFIC_ITEMS_MANAGER_CATEGORY_TRACK)) {
-		PlayerController* _tmp1_;
-		gint _tmp2_;
-		gint _tmp3_;
-		PlayerController* _tmp4_;
-		GeeArrayList* _tmp5_;
-		gint _tmp6_;
-		gint _tmp7_;
-		_tmp1_ = self->priv->_owner;
-		_tmp2_ = player_controller_get_menu_offset (_tmp1_);
-		_tmp3_ = _tmp2_;
-		_tmp4_ = self->priv->_owner;
-		_tmp5_ = self->priv->_proxy_items;
-		_tmp6_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp5_);
-		_tmp7_ = _tmp6_;
-		_result_ = (_tmp3_ + PLAYER_CONTROLLER_WIDGET_QUANTITY) + _tmp7_;
-	} else {
-		gint _tmp8_;
-		_tmp8_ = self->priv->of_type;
-		if (_tmp8_ == ((gint) SPECIFIC_ITEMS_MANAGER_CATEGORY_PLAYER)) {
-			PlayerController* _tmp9_;
-			gint _tmp10_;
-			gint _tmp11_;
-			PlayerController* _tmp12_;
-			PlayerController* _tmp13_;
-			gint _tmp14_ = 0;
-			gint pos;
-			gint _tmp15_ = 0;
-			PlayerController* _tmp16_;
-			gboolean* _tmp17_;
-			gboolean _tmp18_;
-			gint _tmp19_;
-			gint _tmp20_;
-			gint _tmp21_;
-			_tmp9_ = self->priv->_owner;
-			_tmp10_ = player_controller_get_menu_offset (_tmp9_);
-			_tmp11_ = _tmp10_;
-			_tmp12_ = self->priv->_owner;
-			_tmp13_ = self->priv->_owner;
-			_tmp14_ = player_controller_track_specific_count (_tmp13_);
-			pos = (_tmp11_ + PLAYER_CONTROLLER_WIDGET_QUANTITY) + _tmp14_;
-			_tmp16_ = self->priv->_owner;
-			_tmp17_ = _tmp16_->use_playlists;
-			_tmp18_ = TRUE;
-			if (_bool_equal (_tmp17_, &_tmp18_) == TRUE) {
-				_tmp15_ = 1;
-			} else {
-				_tmp15_ = 0;
-			}
-			_tmp19_ = pos;
-			_tmp20_ = _tmp15_;
-			pos = _tmp19_ + _tmp20_;
-			_tmp21_ = pos;
-			_result_ = _tmp21_;
-		}
-	}
-	_tmp22_ = self->priv->of_type;
-	_tmp23_ = _result_;
-	g_debug ("specific-items-manager.vala:63: !!!!! Menu pos of type %i is = %i", _tmp22_, _tmp23_);
-	result = _result_;
-	return result;
-}
-
-
-static gpointer _g_object_ref0 (gpointer self) {
-	return self ? g_object_ref (self) : NULL;
-}
-
-
-static void _specific_items_manager_on_child_added_dbusmenu_menuitem_child_added (DbusmenuMenuitem* _sender, GObject* position, guint p0, gpointer self) {
-	specific_items_manager_on_child_added (self, position, p0);
-}
-
-
-static void _specific_items_manager_on_child_removed_dbusmenu_menuitem_child_removed (DbusmenuMenuitem* _sender, GObject* object, gpointer self) {
-	specific_items_manager_on_child_removed (self, object);
-}
-
-
-static void specific_items_manager_on_root_changed (SpecificItemsManager* self, GObject* newroot) {
-	GObject* _tmp0_;
-	DbusmenuClient* _tmp19_;
-	DbusmenuMenuitem* _tmp20_ = NULL;
-	DbusmenuMenuitem* _tmp21_;
-	DbusmenuMenuitem* root;
-	DbusmenuMenuitem* _tmp22_;
-	DbusmenuMenuitem* _tmp23_;
-	DbusmenuMenuitem* _tmp24_;
-	GList* _tmp25_ = NULL;
-	GList* _tmp26_ = NULL;
-	GList* children;
-	GList* _tmp27_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = newroot;
-	if (_tmp0_ == NULL) {
-		GeeArrayList* _tmp15_;
-		GeeArrayList* _tmp16_;
-		gint _tmp17_;
-		gint _tmp18_;
-		g_debug ("specific-items-manager.vala:70: root disappeared -remove proxyitems");
-		{
-			GeeArrayList* _tmp1_;
-			GeeArrayList* _tmp2_;
-			GeeArrayList* _p_list;
-			GeeArrayList* _tmp3_;
-			gint _tmp4_;
-			gint _tmp5_;
-			gint _p_size;
-			gint _p_index;
-			_tmp1_ = self->priv->_proxy_items;
-			_tmp2_ = _g_object_ref0 (_tmp1_);
-			_p_list = _tmp2_;
-			_tmp3_ = _p_list;
-			_tmp4_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp3_);
-			_tmp5_ = _tmp4_;
-			_p_size = _tmp5_;
-			_p_index = -1;
-			while (TRUE) {
-				gint _tmp6_;
-				gint _tmp7_;
-				gint _tmp8_;
-				GeeArrayList* _tmp9_;
-				gint _tmp10_;
-				gpointer _tmp11_ = NULL;
-				DbusmenuMenuitemProxy* p;
-				PlayerController* _tmp12_;
-				DbusmenuMenuitem* _tmp13_;
-				DbusmenuMenuitemProxy* _tmp14_;
-				_tmp6_ = _p_index;
-				_p_index = _tmp6_ + 1;
-				_tmp7_ = _p_index;
-				_tmp8_ = _p_size;
-				if (!(_tmp7_ < _tmp8_)) {
-					break;
-				}
-				_tmp9_ = _p_list;
-				_tmp10_ = _p_index;
-				_tmp11_ = gee_abstract_list_get ((GeeAbstractList*) _tmp9_, _tmp10_);
-				p = (DbusmenuMenuitemProxy*) _tmp11_;
-				_tmp12_ = self->priv->_owner;
-				_tmp13_ = _tmp12_->root_menu;
-				_tmp14_ = p;
-				dbusmenu_menuitem_child_delete (_tmp13_, (DbusmenuMenuitem*) _tmp14_);
-				_g_object_unref0 (p);
-			}
-			_g_object_unref0 (_p_list);
-		}
-		_tmp15_ = self->priv->_proxy_items;
-		gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp15_);
-		_tmp16_ = self->priv->_proxy_items;
-		_tmp17_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp16_);
-		_tmp18_ = _tmp17_;
-		g_debug ("specific-items-manager.vala:75: array list size is now %i", _tmp18_);
-		return;
-	}
-	_tmp19_ = self->priv->client;
-	_tmp20_ = dbusmenu_client_get_root (_tmp19_);
-	_tmp21_ = _g_object_ref0 (_tmp20_);
-	root = _tmp21_;
-	_tmp22_ = root;
-	g_signal_connect_object (_tmp22_, "child-added", (GCallback) _specific_items_manager_on_child_added_dbusmenu_menuitem_child_added, self, 0);
-	_tmp23_ = root;
-	g_signal_connect_object (_tmp23_, "child-removed", (GCallback) _specific_items_manager_on_child_removed_dbusmenu_menuitem_child_removed, self, 0);
-	_tmp24_ = root;
-	_tmp25_ = dbusmenu_menuitem_get_children (_tmp24_);
-	_tmp26_ = g_list_copy (_tmp25_);
-	children = _tmp26_;
-	_tmp27_ = children;
-	{
-		GList* child_collection = NULL;
-		GList* child_it = NULL;
-		child_collection = _tmp27_;
-		for (child_it = child_collection; child_it != NULL; child_it = child_it->next) {
-			void* child = NULL;
-			child = child_it->data;
-			{
-				gint _tmp28_ = 0;
-				gint pos;
-				void* _tmp29_;
-				DbusmenuMenuitem* item;
-				DbusmenuMenuitem* _tmp30_;
-				DbusmenuMenuitemProxy* _tmp31_;
-				DbusmenuMenuitemProxy* proxy;
-				GeeArrayList* _tmp32_;
-				DbusmenuMenuitemProxy* _tmp33_;
-				DbusmenuMenuitem* _tmp34_;
-				const gchar* _tmp35_ = NULL;
-				PlayerController* _tmp36_;
-				DbusmenuMenuitem* _tmp37_;
-				DbusmenuMenuitemProxy* _tmp38_;
-				gint _tmp39_;
-				_tmp28_ = specific_items_manager_figure_out_positioning (self);
-				pos = _tmp28_;
-				_tmp29_ = child;
-				item = DBUSMENU_MENUITEM (_tmp29_);
-				_tmp30_ = item;
-				_tmp31_ = dbusmenu_menuitem_proxy_new (_tmp30_);
-				proxy = _tmp31_;
-				_tmp32_ = self->priv->_proxy_items;
-				_tmp33_ = proxy;
-				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp32_, _tmp33_);
-				_tmp34_ = item;
-				_tmp35_ = dbusmenu_menuitem_property_get (_tmp34_, DBUSMENU_MENUITEM_PROP_LABEL);
-				g_debug ("specific-items-manager.vala:92: Proxy item of label = %s added to coll" \
-"ection", _tmp35_);
-				_tmp36_ = self->priv->_owner;
-				_tmp37_ = _tmp36_->root_menu;
-				_tmp38_ = proxy;
-				_tmp39_ = pos;
-				dbusmenu_menuitem_child_add_position (_tmp37_, (DbusmenuMenuitem*) _tmp38_, (guint) _tmp39_);
-				_g_object_unref0 (proxy);
-			}
-		}
-	}
-	_g_list_free0 (children);
-	_g_object_unref0 (root);
-}
-
-
-static void specific_items_manager_on_child_added (SpecificItemsManager* self, GObject* child, guint position) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (child != NULL);
-	g_debug ("specific-items-manager.vala:101: On child added Specific root node");
-}
-
-
-static void specific_items_manager_on_child_removed (SpecificItemsManager* self, GObject* child) {
-	g_return_if_fail (self != NULL);
-	g_return_if_fail (child != NULL);
-	g_debug ("specific-items-manager.vala:106: On child removed Specific root node");
-}
-
-
-static PlayerController* specific_items_manager_get_owner (SpecificItemsManager* self) {
-	PlayerController* result;
-	PlayerController* _tmp0_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = self->priv->_owner;
-	result = _tmp0_;
-	return result;
-}
-
-
-static void specific_items_manager_set_owner (SpecificItemsManager* self, PlayerController* value) {
-	PlayerController* _tmp0_;
-	PlayerController* _tmp1_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = value;
-	_tmp1_ = _g_object_ref0 (_tmp0_);
-	_g_object_unref0 (self->priv->_owner);
-	self->priv->_owner = _tmp1_;
-}
-
-
-GeeArrayList* specific_items_manager_get_proxy_items (SpecificItemsManager* self) {
-	GeeArrayList* result;
-	GeeArrayList* _tmp0_;
-	g_return_val_if_fail (self != NULL, NULL);
-	_tmp0_ = self->priv->_proxy_items;
-	result = _tmp0_;
-	return result;
-}
-
-
-static void specific_items_manager_set_proxy_items (SpecificItemsManager* self, GeeArrayList* value) {
-	GeeArrayList* _tmp0_;
-	GeeArrayList* _tmp1_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = value;
-	_tmp1_ = _g_object_ref0 (_tmp0_);
-	_g_object_unref0 (self->priv->_proxy_items);
-	self->priv->_proxy_items = _tmp1_;
-	g_object_notify ((GObject *) self, "proxy-items");
-}
-
-
-static GObject * specific_items_manager_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
-	GObject * obj;
-	GObjectClass * parent_class;
-	SpecificItemsManager * self;
-	GeeArrayList* _tmp0_;
-	GeeArrayList* _tmp1_;
-	parent_class = G_OBJECT_CLASS (specific_items_manager_parent_class);
-	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
-	self = SPECIFIC_ITEMS_MANAGER (obj);
-	_tmp0_ = gee_array_list_new (dbusmenu_menuitem_proxy_get_type (), (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
-	_tmp1_ = _tmp0_;
-	specific_items_manager_set_proxy_items (self, _tmp1_);
-	_g_object_unref0 (_tmp1_);
-	return obj;
-}
-
-
-static void specific_items_manager_class_init (SpecificItemsManagerClass * klass) {
-	specific_items_manager_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (SpecificItemsManagerPrivate));
-	G_OBJECT_CLASS (klass)->get_property = _vala_specific_items_manager_get_property;
-	G_OBJECT_CLASS (klass)->set_property = _vala_specific_items_manager_set_property;
-	G_OBJECT_CLASS (klass)->constructor = specific_items_manager_constructor;
-	G_OBJECT_CLASS (klass)->finalize = specific_items_manager_finalize;
-	g_object_class_install_property (G_OBJECT_CLASS (klass), SPECIFIC_ITEMS_MANAGER_PROXY_ITEMS, g_param_spec_object ("proxy-items", "proxy-items", "proxy-items", GEE_TYPE_ARRAY_LIST, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
-}
-
-
-static void specific_items_manager_instance_init (SpecificItemsManager * self) {
-	self->priv = SPECIFIC_ITEMS_MANAGER_GET_PRIVATE (self);
-}
-
-
-static void specific_items_manager_finalize (GObject* obj) {
-	SpecificItemsManager * self;
-	self = SPECIFIC_ITEMS_MANAGER (obj);
-	_g_object_unref0 (self->priv->_owner);
-	_g_free0 (self->priv->dbus_path);
-	_g_object_unref0 (self->priv->client);
-	_g_object_unref0 (self->priv->_proxy_items);
-	G_OBJECT_CLASS (specific_items_manager_parent_class)->finalize (obj);
-}
-
-
-GType specific_items_manager_get_type (void) {
-	static volatile gsize specific_items_manager_type_id__volatile = 0;
-	if (g_once_init_enter (&specific_items_manager_type_id__volatile)) {
-		static const GTypeInfo g_define_type_info = { sizeof (SpecificItemsManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) specific_items_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SpecificItemsManager), 0, (GInstanceInitFunc) specific_items_manager_instance_init, NULL };
-		GType specific_items_manager_type_id;
-		specific_items_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "SpecificItemsManager", &g_define_type_info, 0);
-		g_once_init_leave (&specific_items_manager_type_id__volatile, specific_items_manager_type_id);
-	}
-	return specific_items_manager_type_id__volatile;
-}
-
-
-static void _vala_specific_items_manager_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
-	SpecificItemsManager * self;
-	self = SPECIFIC_ITEMS_MANAGER (object);
-	switch (property_id) {
-		case SPECIFIC_ITEMS_MANAGER_PROXY_ITEMS:
-		g_value_set_object (value, specific_items_manager_get_proxy_items (self));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-static void _vala_specific_items_manager_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
-	SpecificItemsManager * self;
-	self = SPECIFIC_ITEMS_MANAGER (object);
-	switch (property_id) {
-		case SPECIFIC_ITEMS_MANAGER_PROXY_ITEMS:
-		specific_items_manager_set_proxy_items (self, g_value_get_object (value));
-		break;
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-
diff -Naur indicator-sound-0.8.5.0/src/transport-menu-item.c indicator-sound-precise/src/transport-menu-item.c
--- indicator-sound-0.8.5.0/src/transport-menu-item.c	2012-03-30 10:32:34.000000000 -0700
+++ indicator-sound-precise/src/transport-menu-item.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,384 +0,0 @@
-/* transport-menu-item.c generated by valac 0.14.2, the Vala compiler
- * generated from transport-menu-item.vala, do not modify */
-
-/*
-Copyright 2010 Canonical Ltd.
-
-Authors:
-    Conor Curran <conor.curran@canonical.com>
-
-This program is free software: you can redistribute it and/or modify it 
-under the terms of the GNU General Public License version 3, as published 
-by the Free Software Foundation.
-
-This program is distributed in the hope that it will be useful, but 
-WITHOUT ANY WARRANTY; without even the implied warranties of 
-MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR 
-PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along 
-with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include <glib.h>
-#include <glib-object.h>
-#include <libdbusmenu-glib/client.h>
-#include <libdbusmenu-glib/dbusmenu-glib.h>
-#include <libdbusmenu-glib/enum-types.h>
-#include <libdbusmenu-glib/menuitem-proxy.h>
-#include <libdbusmenu-glib/menuitem.h>
-#include <libdbusmenu-glib/server.h>
-#include <libdbusmenu-glib/types.h>
-#include <common-defs.h>
-#include <gee.h>
-#include <stdlib.h>
-#include <string.h>
-#include <gio/gio.h>
-
-
-#define TYPE_PLAYER_ITEM (player_item_get_type ())
-#define PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_ITEM, PlayerItem))
-#define PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_ITEM, PlayerItemClass))
-#define IS_PLAYER_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_ITEM))
-#define IS_PLAYER_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_ITEM))
-#define PLAYER_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_ITEM, PlayerItemClass))
-
-typedef struct _PlayerItem PlayerItem;
-typedef struct _PlayerItemClass PlayerItemClass;
-typedef struct _PlayerItemPrivate PlayerItemPrivate;
-
-#define TYPE_TRANSPORT_MENUITEM (transport_menuitem_get_type ())
-#define TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitem))
-#define TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))
-#define IS_TRANSPORT_MENUITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TRANSPORT_MENUITEM))
-#define IS_TRANSPORT_MENUITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TRANSPORT_MENUITEM))
-#define TRANSPORT_MENUITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TRANSPORT_MENUITEM, TransportMenuitemClass))
-
-typedef struct _TransportMenuitem TransportMenuitem;
-typedef struct _TransportMenuitemClass TransportMenuitemClass;
-typedef struct _TransportMenuitemPrivate TransportMenuitemPrivate;
-
-#define TYPE_PLAYER_CONTROLLER (player_controller_get_type ())
-#define PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLAYER_CONTROLLER, PlayerController))
-#define PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-#define IS_PLAYER_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLAYER_CONTROLLER))
-#define IS_PLAYER_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLAYER_CONTROLLER))
-#define PLAYER_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLAYER_CONTROLLER, PlayerControllerClass))
-
-typedef struct _PlayerController PlayerController;
-typedef struct _PlayerControllerClass PlayerControllerClass;
-typedef struct _PlayerControllerPrivate PlayerControllerPrivate;
-
-#define TYPE_MPRIS2_CONTROLLER (mpris2_controller_get_type ())
-#define MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2Controller))
-#define MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
-#define IS_MPRIS2_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MPRIS2_CONTROLLER))
-#define IS_MPRIS2_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MPRIS2_CONTROLLER))
-#define MPRIS2_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MPRIS2_CONTROLLER, Mpris2ControllerClass))
-
-typedef struct _Mpris2Controller Mpris2Controller;
-typedef struct _Mpris2ControllerClass Mpris2ControllerClass;
-#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
-#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
-
-#define PLAYER_CONTROLLER_TYPE_STATE (player_controller_state_get_type ())
-
-struct _PlayerItem {
-	DbusmenuMenuitem parent_instance;
-	PlayerItemPrivate * priv;
-};
-
-struct _PlayerItemClass {
-	DbusmenuMenuitemClass parent_class;
-};
-
-struct _TransportMenuitem {
-	PlayerItem parent_instance;
-	TransportMenuitemPrivate * priv;
-};
-
-struct _TransportMenuitemClass {
-	PlayerItemClass parent_class;
-};
-
-struct _TransportMenuitemPrivate {
-	TransportAction cached_action;
-};
-
-struct _PlayerController {
-	GObject parent_instance;
-	PlayerControllerPrivate * priv;
-	gint current_state;
-	DbusmenuMenuitem* root_menu;
-	GeeArrayList* custom_items;
-	Mpris2Controller* mpris_bridge;
-	gboolean* use_playlists;
-};
-
-struct _PlayerControllerClass {
-	GObjectClass parent_class;
-};
-
-typedef enum  {
-	PLAYER_CONTROLLER_STATE_OFFLINE,
-	PLAYER_CONTROLLER_STATE_INSTANTIATING,
-	PLAYER_CONTROLLER_STATE_READY,
-	PLAYER_CONTROLLER_STATE_CONNECTED,
-	PLAYER_CONTROLLER_STATE_DISCONNECTED
-} PlayerControllerstate;
-
-
-static gpointer transport_menuitem_parent_class = NULL;
-
-GType player_item_get_type (void) G_GNUC_CONST;
-GType transport_menuitem_get_type (void) G_GNUC_CONST;
-#define TRANSPORT_MENUITEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_TRANSPORT_MENUITEM, TransportMenuitemPrivate))
-enum  {
-	TRANSPORT_MENUITEM_DUMMY_PROPERTY
-};
-GType player_controller_get_type (void) G_GNUC_CONST;
-TransportMenuitem* transport_menuitem_new (PlayerController* parent);
-TransportMenuitem* transport_menuitem_construct (GType object_type, PlayerController* parent);
-void transport_menuitem_handle_cached_action (TransportMenuitem* self);
-static gboolean transport_menuitem_send_cached_action (TransportMenuitem* self);
-static gboolean _transport_menuitem_send_cached_action_gsource_func (gpointer self);
-PlayerController* player_item_get_owner (PlayerItem* self);
-GType mpris2_controller_get_type (void) G_GNUC_CONST;
-void mpris2_controller_transport_update (Mpris2Controller* self, TransportAction command);
-void transport_menuitem_change_play_state (TransportMenuitem* self, TransportState update);
-static void transport_menuitem_real_handle_event (DbusmenuMenuitem* base, const gchar* name, GVariant* input_value, guint timestamp);
-static gboolean transport_menuitem_get_running (TransportMenuitem* self);
-void player_controller_instantiate (PlayerController* self);
-GeeHashSet* transport_menuitem_attributes_format (void);
-GType player_controller_state_get_type (void) G_GNUC_CONST;
-static GObject * transport_menuitem_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
-GAppInfo* player_controller_get_app_info (PlayerController* self);
-static void transport_menuitem_finalize (GObject* obj);
-static void _vala_transport_menuitem_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
-
-
-TransportMenuitem* transport_menuitem_construct (GType object_type, PlayerController* parent) {
-	TransportMenuitem * self = NULL;
-	PlayerController* _tmp0_;
-	g_return_val_if_fail (parent != NULL, NULL);
-	_tmp0_ = parent;
-	self = (TransportMenuitem*) g_object_new (object_type, "item-type", DBUSMENU_TRANSPORT_MENUITEM_TYPE, "owner", _tmp0_, NULL);
-	return self;
-}
-
-
-TransportMenuitem* transport_menuitem_new (PlayerController* parent) {
-	return transport_menuitem_construct (TYPE_TRANSPORT_MENUITEM, parent);
-}
-
-
-/**
-  Please remove this timeout when the default player can handle mpris commands
-  immediately once it raises its dbus interface
-  **/
-static gboolean _transport_menuitem_send_cached_action_gsource_func (gpointer self) {
-	gboolean result;
-	result = transport_menuitem_send_cached_action (self);
-	return result;
-}
-
-
-void transport_menuitem_handle_cached_action (TransportMenuitem* self) {
-	TransportAction _tmp0_;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = self->priv->cached_action;
-	if (_tmp0_ != TRANSPORT_ACTION_NO_ACTION) {
-		g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) 1, _transport_menuitem_send_cached_action_gsource_func, g_object_ref (self), g_object_unref);
-	}
-}
-
-
-static gboolean transport_menuitem_send_cached_action (TransportMenuitem* self) {
-	gboolean result = FALSE;
-	PlayerController* _tmp0_;
-	PlayerController* _tmp1_;
-	Mpris2Controller* _tmp2_;
-	TransportAction _tmp3_;
-	g_return_val_if_fail (self != NULL, FALSE);
-	_tmp0_ = player_item_get_owner ((PlayerItem*) self);
-	_tmp1_ = _tmp0_;
-	_tmp2_ = _tmp1_->mpris_bridge;
-	_tmp3_ = self->priv->cached_action;
-	mpris2_controller_transport_update (_tmp2_, _tmp3_);
-	self->priv->cached_action = TRANSPORT_ACTION_NO_ACTION;
-	result = FALSE;
-	return result;
-}
-
-
-void transport_menuitem_change_play_state (TransportMenuitem* self, TransportState update) {
-	TransportState _tmp0_;
-	gint temp;
-	g_return_if_fail (self != NULL);
-	_tmp0_ = update;
-	temp = (gint) _tmp0_;
-	dbusmenu_menuitem_property_set_int ((DbusmenuMenuitem*) self, DBUSMENU_TRANSPORT_MENUITEM_PLAY_STATE, temp);
-}
-
-
-static gpointer _g_variant_ref0 (gpointer self) {
-	return self ? g_variant_ref (self) : NULL;
-}
-
-
-static void transport_menuitem_real_handle_event (DbusmenuMenuitem* base, const gchar* name, GVariant* input_value, guint timestamp) {
-	TransportMenuitem * self;
-	GVariant* _tmp0_;
-	GVariant* _tmp1_;
-	GVariant* v;
-	GVariant* _tmp2_;
-	const GVariantType* _tmp3_;
-	gboolean _tmp4_ = FALSE;
-	GVariant* _tmp7_;
-	gint32 _tmp8_ = 0;
-	gint32 input;
-	gboolean _tmp9_;
-	gboolean _tmp10_;
-	self = (TransportMenuitem*) base;
-	g_return_if_fail (name != NULL);
-	g_return_if_fail (input_value != NULL);
-	_tmp0_ = input_value;
-	_tmp1_ = _g_variant_ref0 (_tmp0_);
-	v = _tmp1_;
-	_tmp2_ = input_value;
-	_tmp3_ = G_VARIANT_TYPE_VARIANT;
-	_tmp4_ = g_variant_is_of_type (_tmp2_, _tmp3_);
-	if (_tmp4_) {
-		GVariant* _tmp5_;
-		GVariant* _tmp6_ = NULL;
-		_tmp5_ = input_value;
-		_tmp6_ = g_variant_get_variant (_tmp5_);
-		_g_variant_unref0 (v);
-		v = _tmp6_;
-	}
-	_tmp7_ = v;
-	_tmp8_ = g_variant_get_int32 (_tmp7_);
-	input = _tmp8_;
-	_tmp9_ = transport_menuitem_get_running (self);
-	_tmp10_ = _tmp9_;
-	if (_tmp10_ == TRUE) {
-		PlayerController* _tmp11_;
-		PlayerController* _tmp12_;
-		Mpris2Controller* _tmp13_;
-		gint32 _tmp14_;
-		_tmp11_ = player_item_get_owner ((PlayerItem*) self);
-		_tmp12_ = _tmp11_;
-		_tmp13_ = _tmp12_->mpris_bridge;
-		_tmp14_ = input;
-		mpris2_controller_transport_update (_tmp13_, (TransportAction) _tmp14_);
-	} else {
-		gint32 _tmp15_;
-		PlayerController* _tmp16_;
-		PlayerController* _tmp17_;
-		_tmp15_ = input;
-		self->priv->cached_action = (TransportAction) _tmp15_;
-		_tmp16_ = player_item_get_owner ((PlayerItem*) self);
-		_tmp17_ = _tmp16_;
-		player_controller_instantiate (_tmp17_);
-		dbusmenu_menuitem_property_set_int ((DbusmenuMenuitem*) self, DBUSMENU_TRANSPORT_MENUITEM_PLAY_STATE, (gint) TRANSPORT_STATE_LAUNCHING);
-	}
-	_g_variant_unref0 (v);
-}
-
-
-GeeHashSet* transport_menuitem_attributes_format (void) {
-	GeeHashSet* result = NULL;
-	GeeHashSet* _tmp0_;
-	GeeHashSet* attrs;
-	_tmp0_ = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL);
-	attrs = _tmp0_;
-	gee_abstract_collection_add ((GeeAbstractCollection*) attrs, DBUSMENU_TRANSPORT_MENUITEM_PLAY_STATE);
-	result = attrs;
-	return result;
-}
-
-
-static gboolean transport_menuitem_get_running (TransportMenuitem* self) {
-	gboolean result;
-	PlayerController* _tmp0_;
-	PlayerController* _tmp1_;
-	gint _tmp2_;
-	g_return_val_if_fail (self != NULL, FALSE);
-	_tmp0_ = player_item_get_owner ((PlayerItem*) self);
-	_tmp1_ = _tmp0_;
-	_tmp2_ = _tmp1_->current_state;
-	result = _tmp2_ == ((gint) PLAYER_CONTROLLER_STATE_CONNECTED);
-	return result;
-}
-
-
-static GObject * transport_menuitem_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
-	GObject * obj;
-	GObjectClass * parent_class;
-	TransportMenuitem * self;
-	PlayerController* _tmp0_;
-	PlayerController* _tmp1_;
-	GAppInfo* _tmp2_;
-	GAppInfo* _tmp3_;
-	const gchar* _tmp4_ = NULL;
-	parent_class = G_OBJECT_CLASS (transport_menuitem_parent_class);
-	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
-	self = TRANSPORT_MENUITEM (obj);
-	dbusmenu_menuitem_property_set_int ((DbusmenuMenuitem*) self, DBUSMENU_TRANSPORT_MENUITEM_PLAY_STATE, (gint) TRANSPORT_STATE_PAUSED);
-	_tmp0_ = player_item_get_owner ((PlayerItem*) self);
-	_tmp1_ = _tmp0_;
-	_tmp2_ = player_controller_get_app_info (_tmp1_);
-	_tmp3_ = _tmp2_;
-	_tmp4_ = g_app_info_get_name (_tmp3_);
-	dbusmenu_menuitem_property_set ((DbusmenuMenuitem*) self, DBUSMENU_MENUITEM_PROP_LABEL, _tmp4_);
-	self->priv->cached_action = TRANSPORT_ACTION_NO_ACTION;
-	return obj;
-}
-
-
-static void transport_menuitem_class_init (TransportMenuitemClass * klass) {
-	transport_menuitem_parent_class = g_type_class_peek_parent (klass);
-	g_type_class_add_private (klass, sizeof (TransportMenuitemPrivate));
-	DBUSMENU_MENUITEM_CLASS (klass)->handle_event = transport_menuitem_real_handle_event;
-	G_OBJECT_CLASS (klass)->get_property = _vala_transport_menuitem_get_property;
-	G_OBJECT_CLASS (klass)->constructor = transport_menuitem_constructor;
-	G_OBJECT_CLASS (klass)->finalize = transport_menuitem_finalize;
-}
-
-
-static void transport_menuitem_instance_init (TransportMenuitem * self) {
-	self->priv = TRANSPORT_MENUITEM_GET_PRIVATE (self);
-}
-
-
-static void transport_menuitem_finalize (GObject* obj) {
-	TransportMenuitem * self;
-	self = TRANSPORT_MENUITEM (obj);
-	G_OBJECT_CLASS (transport_menuitem_parent_class)->finalize (obj);
-}
-
-
-GType transport_menuitem_get_type (void) {
-	static volatile gsize transport_menuitem_type_id__volatile = 0;
-	if (g_once_init_enter (&transport_menuitem_type_id__volatile)) {
-		static const GTypeInfo g_define_type_info = { sizeof (TransportMenuitemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) transport_menuitem_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TransportMenuitem), 0, (GInstanceInitFunc) transport_menuitem_instance_init, NULL };
-		GType transport_menuitem_type_id;
-		transport_menuitem_type_id = g_type_register_static (TYPE_PLAYER_ITEM, "TransportMenuitem", &g_define_type_info, 0);
-		g_once_init_leave (&transport_menuitem_type_id__volatile, transport_menuitem_type_id);
-	}
-	return transport_menuitem_type_id__volatile;
-}
-
-
-static void _vala_transport_menuitem_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
-	TransportMenuitem * self;
-	self = TRANSPORT_MENUITEM (object);
-	switch (property_id) {
-		default:
-		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
-		break;
-	}
-}
-
-
-
diff -Naur indicator-sound-0.8.5.0/src/volume-widget.c indicator-sound-precise/src/volume-widget.c
--- indicator-sound-0.8.5.0/src/volume-widget.c	2012-03-30 10:26:53.000000000 -0700
+++ indicator-sound-precise/src/volume-widget.c	2012-07-26 21:03:55.488143000 -0700
@@ -135,16 +135,28 @@
 
   if(g_ascii_strcasecmp(DBUSMENU_VOLUME_MENUITEM_LEVEL, property) == 0){
     g_return_if_fail (g_variant_is_of_type (value, G_VARIANT_TYPE_DOUBLE) );
+    gdouble update = g_variant_get_double (value);
+
     if(priv->grabbed == FALSE){
       GtkWidget *slider = ido_scale_menu_item_get_scale((IdoScaleMenuItem*)priv->ido_volume_slider);
       GtkRange *range = (GtkRange*)slider;
-      gdouble update = g_variant_get_double (value);
       gtk_range_set_value(range, update);
 /*
       g_debug ("volume-widget::volume_widget_property_update - volume - value %f", update);
-*/
-      update_accessible_desc(priv->indicator);
+      AtkObject* atk_object;
+      atk_object = gtk_widget_get_accessible (priv->ido_volume_slider);
+      if (atk_object != NULL){
+        atk_object_set_name (atk_object, desc);
+      
+      }*/
     }
+    gchar* desc = g_strdup_printf(_("Volume (%'.0f%%)"),
+                                    update);      
+    dbusmenu_menuitem_property_set (priv->twin_item,
+                                    DBUSMENU_MENUITEM_PROP_ACCESSIBLE_DESC,
+                                    desc);
+    g_free (desc);
+    update_accessible_desc(priv->indicator);    
   }
   else if(g_ascii_strcasecmp(DBUSMENU_VOLUME_MENUITEM_MUTE, property) == 0){
     g_return_if_fail (g_variant_is_of_type (value, G_VARIANT_TYPE_BOOLEAN));
@@ -196,6 +208,13 @@
     initial_level = 0;
   }
   gtk_range_set_value(range, initial_level);
+  gchar* desc = g_strdup_printf(_("Volume (%'.0f%%)"),
+                                  initial_level);      
+  dbusmenu_menuitem_property_set (priv->twin_item,
+                                  DBUSMENU_MENUITEM_PROP_ACCESSIBLE_DESC,
+                                  desc);
+  g_free (desc);
+
 }
 
 static gboolean
